welcom .
i'm bob sedgewick , professor of comput scienc at princeton .
thi is our onlin cours algorithm develop by myself and kevin wayn here at princeton .
we're gonna start with an overview discuss of why you might want to studi algorithm and a littl bit of discuss about the resourc that you need to take thi cours .
so , what is thi cours ?
it's an intermedi level survei cours on algorithm .
we're go to concentr on program and problem solv in the context of real applic , and our focu is go to be on two thing , algorithm which ar method for solv problem and data structur which store the inform associ in problem , with a problem and go hand in hand with algorithm .
these ar the basic topic that we'll cover in part on and part two of the cours .
the first part is data type sort and search .
we'll consid a number of data structur and algorithm that ar basic to all the method we consid includ stack , queue , bag and prioriti queue .
then we'll consid classic algorithm for sort , put thing in order .
that's quicksort , mergesort , heapsort and radix sort .
and we'll consid classic method for search .
includ binari search tree , red black binari search tree and hash tabl .
the second part of the cours is for more advanc algorithm includ graph algorithm , classic graph search algorithm , minimum span tree and shortest path algorithm , algorithm for process string includ regular express and data compress .
and then some advanc algorithm that make us of the basic algorithm that we develop earlier in the cours .
so , why should on studi algorithm ?
well , their input , impact is veri broad and far reach .
from the internet to biologi to , commerci comput , comput graphic , secur , multimedia , social network , and scientif applic , algorithm ar all around us .
thei're us for movi and video game , for particl collis simul , thei're us to studi the genom , and all manner of other applic .
so , that's on import reason to studi algorithm , their impact is broad and far reach .
algorithm ar also interest to studi , becaus thei , thei have ancient root .
now the first algorithm we studi goe back to <num> b . c . , date at least to euclid .
the concept of an algorithm wa formal actual here at princeton , by church and ture , in the 1930s .
but most algorithm that we consid , were discov in recent decad .
in fact , some were discov by undergradu in a cours , cours like thi .
and there's plenti of other algorithm wait to be discov by student like you .
the main reason that peopl studi algorithm , is to be abl to solv problem that it could not otherwis be address .
for exampl , in the first lectur , we're go to talk about the network connect problem , where the problem is , given a larg set of item that ar connect togeth pairwis is there a wai to get from on to anoth with a path through the connect .
as you can see from thi exampl , it's not clear whether or not there's such a path , we need a comput program to do it , in fact , we need an effici algorithm to do it .
in thi case the answer is that there is such a path .
anoth reason to studi algorithm is for intellectu stimul .
algorithm ar veri interest object to studi .
don knuth who wrote sever book on , on algorithm and wa a pioneer in the field said that , an algorithm must be seen to be believ . you can't just think about an algorithm you have to work with it .
anoth quot from franci sullivan , sai , the great algorithm ar the poetri of comput . just like vers , thei can be ters , elus , dens , and even mysteri .
but onc unlock , thei cast a brilliant new light on some aspect of comput .
algorithm ar interest for intellectu stimul .
anoth reason mani peopl studi algorithm and i suspect mani of you , is it's necessari to understand good algorithm , effici algorithm , a good data structur in order to be a profici programm .
linu torvald , who creat lin , linux , sai that the differ between a bad programm and a good on is whether he consid hi code or hi data structur more import .
bad programm worri about the code , good programm worri about data structur , and their relationship .
and , i might add , the algorithm that process them .
niklau wirth , anoth pioneer in comput scienc , wrote a famou book call algorithm data structur program .
anoth reason nowadai to studi algorithm is that , thei have becom a common languag for understand , natur .
algorithm ar comput model , and algorithm model ar replac mathemat model in scientif inquiri .
in the twentieth centuri , math , scientist develop mathemat model to try to understand natur phenomenon .
it soon becam clear that those mathemat model were difficult to solv .
it wa difficult to creat solut , to be abl to test hypothes against natur phenomenon .
so , more and more and more now a dai peopl ar develop comput model , where thei attempt to simul what might be happen in natur in order to try to better understand it .
algorithm plai an extrem import role in thi process .
and we'll see some exampl of thi in thi cours .
anoth import reason is that if you know effect , how to effect us algorithm and data structur you're go to have a much better chanc at interview for a job in the technolog industri then if you don't .
so , here's a bunch of reason that i just went through for studi algorithm .
their impact's broad and far reach , thei have old root and present new opportun , thei allow us to solv problem that could not otherwis be address , you can us them for intellectu stimul to becom a profici programm .
thei might unlock the secret of life in the univers , and thei're good for fun and profit .
in fact , a pr ogramm might ask , why studi anyth els ?
well , there's plenti of good reason to studi other thing , but i'll submit there's no good reason not to studi algorithim .
so , for thi cours we have two resourc that i want to talk about and make sure that peopl ar familiar with befor enter into the content .
thi is a publish model that kevin wayn and i develop and have been us for mani year , and we think it's a veri effect wai to support the , kind of lectur that we're go to be give in thi cours .
down at the bottom , and it's option for thi cours , we have a text book .
it's a tradit , text book that extens cover the topic in the cours , in fact mani more topic than we can present in lectur .
and then support that textbook , is free onlin materi that we call the book site .
you can go to book , the book site to see the lectur slide .
but more import , there's code , there's exercis , tere's a great deal of inform there .
in fact , mayb ten time what's in the book , includ a summari of the content .
so , dure thi cours you'll be refer to the book site frequent while work onlin .
peopl often ask about prerequisit .
we're assum that peopl who take thi cours know how to program , and know the basic of loop , arrai , function .
thei have some exposur to object orient program and recurs .
we us the java languag , but we don't dwell on detail of java , we mostli us it as an expositori languag .
we do some math , but not advanc math .
if you want to review the materi that we think is prerequisit for the materi in thi cours , you can do a quick review by look at section <num> and <num> of the book .
either at the book site or in the text book .
if you want an in depth review , we have a full text book call , an introduct to program in java an interdisciplinari approach .
there is a book site and text book as well .
but , the bottom line is , you should be abl t o program , and the quick exercis to get readi is , to write a java program on your comput perhap us a program model , as describ on the book site .
we will provid much more detail inform on that as we get into the assign .
you can us your own program environ if your comfort with on or you download our .
we have instruct on the web on how to do that .
welcom back , todai we're go to talk about balanc search tree , which will lead us to an ultim symbol tabl implement that can provid fast perform for all the simul option we've look at , guarante .
so here's the review of where we were with singl tabl .
we took a look at the last time at the binari search tree , which if thing ar well model by random exert , have a great perform .
thei get search and insert on in time proport for log base two of n and thei support order oper .
but realli our goal is to have these oper be guarante to take time proport to log n , becaus we don't have control over the order of oper and thei mai not be random at all .
and in fact , in mani real applic , thei're not veri random .
so that's what were go to look at now is try to find an implement that can guarante to be fast for all the symbol tabl oper .
.
that's our challeng .
so what we're go to talk about to do it , is an algorithm , that actual pretti old algorithm call <num> <num> tree , and a particular implement that requir veri littl code , call left lean red black bst and then we'll talk about a gener call b tree .
and these method ar all wide us throughout our comput infrastructur .
to start , we'll talk about <num> <num> search tree , which is a model that underli the concis and effici implement that we're go to look at .
so , the <num> <num> tree is a wai to gener bst to provid the flexibl that we need to guarante fast perform .
and the idea is veri simpl , we allow on or two kei per node .
that is , we allow for the possibl of someth call a <num> node that can hold two kei , but then it ha to have three children .
in a regular bst node , the <num> node , we have on link for the kei that ar less than the kei in the node , and on link for the kei that ar greater .
in a <num> node , we need three link , on for less , on for between and on for greater .
anoth properti of these <num> <num> tree is that we ar go to have perfect balanc , that is everi path from the rout to a null link is go to have the same link in the <num> <num> tree .
so , as i mention , the symmetr order is part of the definit of a <num> <num> tree .
everi <num> node ha three link and two kei .
the left link is for the kei that ar , point to a <num> <num> tree with the kei that ar smaller than the smaller of the two kei in the <num> node .
the middl link point to a <num> <num> tree that contain all the kei that ar between the two kei .
and the right link point to all , <num> <num> tree contain all the kei that ar larger than the larger of the two kei in the <num> node .
okai , let's take a look at a demo of search in a <num> <num> tree .
so sai we have thi <num> <num> tree here and we want to search for whether or not h is on of the kei in the tree .
so we start at the root , compar the search kei against the kei or kei in the node .
and follow the link correspond to the interv that we know must contain the search kei by definit of the tree and then we recurs continu the search .
so , if we're look for h , it's less than m , so the onli place it could be in thi <num> <num> tree is in the <num> <num> tree on the left link , so we follow the left link .
now , we compar h with e and j , and in thi case it's between , so now we ar go to take the middl link , that's the onli place that h possibl could be .
in thi case , that node , on node <num> <num> tree contain h , so that's a search hit .
let's take anoth exampl for unsuccess search , a kei that's not in the tree .
as usual , we start at the root .
it's less , so we go left .
and it's less than both kei , so , if it's in the tree , it would have to be in the left link and it's between those two kei .
so if it's in the tree , it would have to be on the middl link .
and that link is null , so that's a search miss .
so the search is a natur gener of the search in , binari search tree .
now what about insert ?
well , it's a similar type of strategi as with regular binari search tree , except that we manipul the two and <num> node to keep perfect balanc in the tree .
so the easi case is if the kei wind up in a <num> node at the bottom , like thi on .
suppos we're insert k .
k is less than m so we go left .
k is greater than both the kei , so we go right .
k is less than l , so the search end at the left link of l .
and to perform an insert all we need to do is replac that <num> node with a <num> node contain k .
now , k is insert into the <num> <num> tree and it satisfi all the rule .
now if we're insert into a <num> node at the bottom , we have to do more work .
and specif , the work we do is , we add the kei to a <num> node to creat a temporari <num> node and then split up that four node and move it's middl kei into the parent .
so , let's see an exampl .
if we ar go to insert z into thi tree , it's greater than n , so we go to the right .
it's greater than r , so we go to the right .
and now it's greater than x , and that's a null link to the right of x , so the search end there and ar , what we want to do is insert z into that <num> node .
and the wai we do it is , first make a temporari <num> node that replac that <num> node .
and then that's not a <num> <num> tree cuz it's got that on <num> node with three kei and four link .
but what we can do is split that <num> node and pass the middl kei up to it parent .
so split into two <num> node and pass the middl kei to the parent .
that's kind of a magic oper and believ me , it's easier to get done in the implement than the graphic .
but now you can see that , that local transform on the <num> <num> tree complet the insert .
now , if that parent were a <num> node , it would becom a temporari <num> node and would continu the process move up the tree .
that's a demo of search and insert in a <num> <num> tree .
so , let's look at a doubl split like that .
so , sai we're insert l in , into thi tree .
so , it goe down to the middl , and wind up need to be insert in the , <num> node in the middl .
so we're go to convert that into a <num> node .
now , l is the middl kei of that on , so we're go to split that <num> node into , two <num> node and move l to the parent .
the <num> node had four link , and the two <num> node have four length , so noth ha to be chang below .
and then thi insert into the parent chang it from a two , a <num> node into a <num> node essenti ad a length cuz of the split with the two <num> node where there wa onli on <num> node befor .
but now , that's not a <num> <num> tree , so we have to split again .
and in thi case there is no paren , so we creat a new on and the height of the tree increas by on .
that's the onli time the height of a <num> <num> tree chang , when the root split the height introduc increas by on .
so , that's a demo of insert into a <num> node at the bottom , in a <num> <num> tree that percol all the wai to the top .
now let's look at construct a <num> <num> tree from an initi empti tree .
so if we start by just insert a kei , well , that just creat a <num> node contain that kei , and that's legal <num> <num> tree , so we're fine .
now , insert e into that well , it's go to b if it's in the tree left of s , that's a null lin .
so we need to convert that <num> node into a <num> node .
okai ?
and that's the legal of <num> <num> tree , so we stop insert a into that .
we convert that <num> node into a temporari <num> node , but then we need to split that <num> node move e to the parent and that creat a new , root node and increas the size of the tree by on , but now that's a legal <num> <num> tree so we stop .
insert r into that , it goe to the right of e .
convert into a <num> node , now insert c into that .
it goe to the left of e , ha to be join with a into a new <num> node .
again , that's a legal <num> <num> tree and we stop .
now we insert h , that kind of goe to the right of e .
that <num> node get convert into a <num> node .
that's a temporari <num> node and we split and move r to the parent , now that parent's a legal and there's noth more to be done .
we , have a legal three tree , <num> <num> tree .
insert x , it's bigger than r , goe to the right .
there's a <num> node , there's room for the x .
insert p , that goe between e and r .
the <num> node contain h , right link is null , so we convert that <num> node into a <num> node and now we have a legal <num> <num> tree .
now , you , you can see thi next insert is go to caus some split wherev it is .
so insert l , that's between e and r .
so it goe in the , <num> node contain h and p and we convert that into a temporari <num> node .
split that <num> node , move l to the parent .
now that parent of <num> node and that ha to be split , and we creat a new root node .
and then the height of the tree grow by on .
and that's a legal <num> <num> tree , so we stop .
so , those local transform , convert a <num> node to a <num> node or convert a three to a four , and then split and pass a node up .
those ar the , onli oper we need to consid to get balanc in our search tree .
all right .
so as i've mention and thi diagram show , the split of <num> node and a <num> <num> tree is a local transform .
it onli involv chang a constant number of link .
so , in thi exampl , it show the gener situat , when the <num> node to be split is the middl length , but the same is true if it's a left or right .
and those six subtre drawn could be huge .
thei could contain million of kei , but it doesn't matter what thei contain .
we don't touch them at all , nor do we touch anyth abov thi node in the tree until the split happen .
so the transform that split that b , c , d , node and insert the c into the <num> node at the root , just involv , make that <num> node into a temporari <num> node .
and make that , <num> node into two <num> node and adjust the length appropri .
just a constant number of oper and that's why , thi oper , is , in gener , effici .
so let's look at the just the global properti that these manipul preserv .
the two thing that ar critic is that the , in a , in a <num> <num> tree , we alwai have symmetr order .
that is the word that we defin , for <num> node and <num> node , and we also have the perfect balanc .
the distanc from the root to the bottom is alwai the same .
and to prove that , we just need to show that each transform maintain symmetr order and perfect balanc , and these ar all the possibl transform that we could do .
if we split the root , then , that's the , what happen at the root , and if there wa perfect balanc befor , there's perfect balanc after , with the height on bigger .
if the parent wa a <num> node then the transform is a local transform and if you look at where the link ar , then it's easi to see by induct that if there wa perfect balanc befor there's perfect balanc afterward , becaus we didn't chang anyth about the perfect balanc in ani of those subtre .
and that's true in everi case .
if the <num> node at the right and thi on is on higher and those four ar on lower and afterward it's the same .
if there wa perfect balanc befor there's perfect balanc afterward , becaus we didn't chang the height of ani node .
we just move thing around local within node .
and thi is when thi parent is a <num> node , then there's the tree case , if we split up the last split at the middl and split at the right , and again , chang the four node to , to a <num> node and ad link .
if there wa perfect balanc befor , there's perfect balanc after , becaus we didn't chang the height of anyth els in the tree .
so our oper maintain symmetr order and perfect balanc in a <num> <num> tree .
so , that's go to give us , a veri easi wai to describ a perform .
the call , or oper have cost that's proport to the path link from the , height to the bottom , and everi path from the root to a null link ha the same length .
how long can those path be ?
well , it's not hard to see that the , in the worst case , if thei're all <num> node , that's the longest thei can be is log base two of n .
now , and if thei're all <num> node , it would be log base three of n , which is less , it's about <num> . <num> log base two of n .
so , all the path in a <num> <num> tree with n node have to have length between those two bound and those ar pretti small number .
for a million node , that's between twelv and twenti .
and , if , if it's a billion node , that's between eighteen and <num> .
those ar remark small number , so we're go to have guarante perform , even for huge databas , we're go to be abl to guarante that we can get search and insert them with just eighteen to <num> oper and it's quit remark , realli .
so , here's what our tabl , will look like , when we finish the implement of <num> <num> tree .
everi oper is guarante to be a constant time log n .
now , the constant depend on the implement , exactli what kind of manipul we need to do to convert , <num> node to <num> node and so forth .
but it's , easi to see from demo and from the diagram that those ar go to be constant , guarante logarithm perform for all oper , which is certainli what we want in a symbol tabl implement now what about the implement ?
well , we're actual not go to talk about a direct implement of <num> <num> tree , becaus it's kind of complic .
it's cumbersom to maintain multipl node type .
you might need , a multipl compar to move down the tree .
if there's a two , a <num> node , it take more compar than a <num> node , so , it's complic to analyz .
we have to take track , keep track the link as we go up and down the tree to take , handl the split , and there's , and there's a lot of case .
i drew all the case and , and , there's a , whether you're split into the middl of a <num> node or the right of a <num> node , there's just a lot of case .
so , you could do it but we're not go to becaus there's a much easier wai .
so that's <num> <num> tree , a , a model for implement balanc tree in guarante logarithm time .
now , we'll look at red black bst which is a simpl data structur that allow us to implement <num> <num> tree with veri littl extra code beyond the basic binari search tree code .
so thi is , and actual the version that we're go to , look at is call left lean red black bst .
on a person note , i wrote a research paper on thi topic in <num> with leo giva and we thought we pretti well understood these data structur at that time and peopl around the world us them in implement variou differ system .
but just a few year ago for thi cours i found a much simpler implement of red black tree and thi is just the a case studi show that there ar simpl algorithm still out there wait to be discov and thi is on of them that we're go to talk about .
so , the idea is that we ar , ar go to repres everi two , three tree as a binari search tree .
and in order to get that done , we just need a simpl represent for three note .
so , what we ar go to do is us intern left lean link to glue the three node togeth .
so , the larger of the two node in the tree node will alwai be the root of a littl binari search tree of size two for the three node and the link between the two node , the left link that link the larger kei to the smaller on we'll color red .
and that's to distinguish those link from the other link in the binari tree so that we can tell when we're insert thing which node belong to tree node and which on don't .
and you can see from thi transform that it's easi to perform thi , see thi correspond the middl link between a and b , those ar the kei that ar less than b and larger than a .
so , that take two comparison to get to them the on that ar less than a , less than , less than a , that's two comparison for that and the on that ar greater than b ar the right link of b .
so , just follow those three case , i see t hat thi correspond is go to work .
so , ani <num> <num> tree correspond to a left lean red black bst in thi wai .
just take the three node and split them into littl binari search tree of size two held togeth by a red link .
and correspondingli given a red black bst then you can get the <num> <num> tree if you want it .
but just look at the properti of look at the properti over a left lean red black bst .
you know , with refer to what we know about <num> <num> tree .
first of all no node ha two red link connect to it cuz the onli red link ar intern to three node .
and those have to have ex , extern link or tree link connect them to some other node .
everi path from the root down to a null link ha the same number of black link that just follow directli from the correspond properti for <num> <num> tree .
a left lean red black bst ha perfect black balanc .
and all the red link lean left .
so , given a bst with some of the link color red that ha those properti that's go to correspond to a <num> <num> tree .
and that's a kei properti is thi on to on correspond between <num> <num> tree and left lean red black tree .
given a <num> <num> tree , we saw how to do it .
given a , a , given a red black tree , we just make the red link horizont , and merg the node togeth to be three node .
so , all of the oper that we're go to look at for red black tree can be understood in term of the correspond oper on <num> <num> tree .
now the first , and realli on of the most critic observ , is that search in a red black bst is exactli the same as for an elementari bst , we just ignor the color .
now , it's go to be much faster becaus of better balanc in the tree , but in term of the code , we don't have to chang the code at all .
our regular search code doesn't examin the color of a link and so we can just us it exactli as is .
and in fact , most of the other oper that we implement on bst ar also ident .
thei d on't need the color , but thei can all benefit from the fact that the tree ar much better balanc .
so thi aspect of red black bst is an extrem nice on becaus of the oper that we implement for regular bst that involv some complic code for floor and ceil and rank and so forth , and we don't have to chang that code at all .
we just dure the insert , make sure that we , we maintain the properti the balanc properti and by do that , we wind up with balanc tree and we make all the oper quick and we don't have to re implement , we don't have to chang it at all .
so first befor we get to the code for insert , we have to look at the represent .
we don't actual have explicit represent of link or link in tree or just refer to node .
you could implement thi by build explicit link but the an easier thing to do is to know that everi node is referenc by just on link in a tree the on from it's parent .
so , you can put the color of a link in the node that it refer .
so , in thi case we have a red link connect e and c .
what we do is put a bit , a color bit in each in the node class .
and then , if the link come into a node is red we set that to true .
so thi simpl thing just test is a node red .
we consid all null node to be black null link to be black , we don't have red link dangl off , that would be incomplet pre node .
and otherwis if the color's red , we return true otherwis return fals to test whether a node is red .
so in thi tree , the color of h . left is red , the color of h . right is black and so forth .
so , that's the wai we repres color by put the , a color bit in the node for the color of the length that point to it .
all right , so now , there's a coupl of elementari oper that we have to perform on red black tree , call rotat .
and the idea is that dure the construct of a tree , or dure an insert oper , sometim we wind up with red link that ar lean in the wrong direct .
and so we'll need what's call a left rotat , and the job of that oper is to take a , a right lean red link that is there for whatev reason and reorient it to lean to the left .
so , in thi case , we have the right link of e point to s and s is red so that's a right lean red link and so now that's the befor and what we want to do is reorient thing so that it lean to the left .
and again , that ha to be a local oper that onli chang a few link and just from the diagram it's not difficult to see that thi littl bit of code will do the job .
if we start with a right lean red link .
so , first thing we do is take the refer of h . right , and save that in x .
so , that's the node that's go to be the new root of the three node so to speak .
and , and then , x . left after the rotat is go to be h .
and also whatev color h wa , well , it look like it should be black .
but actual thi situat is where it could be red .
then x is go to have that color cuz the link come into h is go to be the link come into x .
and then h's color is go to be black afterward .
and then , we return x to link further up the tree which happen dure our standard recurs insert .
so , that's a rotat left oper .
now , the properti of thi oper that's veri import is it maintain a symmetr order .
the kei between e and s ar still there .
we just chang the wai we get to them .
and the kei less than e and so forth .
and also we maintain perfect black balanc becaus we didn't chang the black height , height of anyth by do thi transform .
all those subtre , those three subtre ar exactli the same rel to the top and bottom of the tree , as thei were befor the rotat .
now paradox and you'll see why veri soon it also turn out that to get the insert done properli we sometim need to take a left lean red link and temporarili make it lean right .
and later on , we'll get it back to the left again .
but anywai , that's a basic oper that we sometim need .
and so that's just the symmetr code to the code that we just did .
now again , now x is h . left .
and h . left is go to be x . right after the rotat .
x's color is still go to be h's color .
and h's color is go to be red .
and the right rotat implement thi and again that's go to maintain a , a symmetr order in perfect black balanc we chang the wai the red goe but we didn't chang anyth about the black .
okai , that's a right rotat .
now , here's the third elementari oper that we're go to perform .
it's call a color flip .
sometim dure the insert , we might wind up with a node that's got two red link come out of it .
that's correspond precis to our temporari four node when we're do <num> <num> tree .
and what we want to do with the temporari four node wa to split it and pass the center node up to the root .
well , you can see from thi structur that we're all set to do that all we need to do actual is not chang ani link , just chang all the color .
and so , that is , we chang the link from e to a and from e to s to be black .
that essenti split the four node .
and then , we want to insert the e into it parent .
and we just do that by chang it link to be red .
so , that's flip the color .
and that's the wai we split a temporari four node in a left linear red black tree .
and again , that's just flip color .
it doesn't chang ani link so it still , of cours , maintain symmetr order and perfect black balanc .
so , those ar the three basic oper we're go to us .
rotat left , rotat right and flip color .
so , the basic s trategi is , with those oper , maintain on to on correspond with <num> <num> tree when we do insert .
so , here's an exampl .
if we want to insert c into thi red black tree which is a represent of thi <num> <num> tree , then c is go to be less than e greater than a .
so , it will get ad to , as the right link of a and everi time we add a node we just creat a red link to it parent and so , that's chang the two node into a three node .
in thi case it's three node that's orient the wrong wai so we need to do a left rotat .
after we do the left rotat , we have a legal left lean red black tree , and it exactli correspond to that <num> <num> tree , so the insert of c give us exactli what we would want , that correspond with the <num> <num> tree .
we have to work through other case that can aris but there's not too mani so we'll work through and we have the basic oper , left rotat , right rotat , and flip color .
all right , so first , warm up , insert into a tree with exactli on node .
well , if it goe on the left , then we just make a red link and add it on then we're done .
if it goe on the right , then we attach a new node with the red link on the right but we have to rotat it to the left to make a legal three node .
so , that's insert to a tree with the on node and make it a tree with two node .
and that on gener to help us insert into a two node at the bottom .
so , we do the standard bst insert color the new link red and then if that new three node happen to lean right , rotat to the left .
that's the case that we just did .
so now , let's look at the second warm up .
so , sai , we have just two node in the tree , so it's we have two node and that mean it's a singl three node .
then there's three case .
so , on is that the new on is larger than both of the kei .
if that's true , then we attach the new node with the red link as alwai .
and that give us a temporari four node .
and what we want to do is split that four node and in thi case , sinc we ar at the root that's all so that just flip the color .
now , the color of the root in our code will temporarili turn red and then we turn it black again .
so , that's insert into a tree that's a singl three node a node that's larger than both of them , a kei that is larger than both of them and we get wind up with a four node .
well , let's look at the other two case and these understand need is crucial to understand the whole algorithm .
let's sai , the new kei is smaller than both of the kei in our three node .
now , we attach a new link at the left of the smaller node .
and now , we've gotta find bst .
but it ha two red link in a row .
and that's someth that's not allow .
so , what we're go to do is we're go to rotat the top link to the right .
so that put b at the root .
and now , it's got two red children .
it reduc to thi case .
and we flip the color and we have a singl four node .
sorri a , a red black .
a tree that's got three two node and no red link so same situat as befor .
so , we had a singl temporari four note and we split it up into a two , two note not connect to a four note .
and then , so that's the case when it's smaller .
now , we have to look at the third case , which is , when it's , the new node insert thi in between and come out of thi link here .
again , we just had a red link and now we have a bst with two red link along the path connect to a and that's not allow .
in thi case it's a bit trickier to affix the situat , what we do is we rotat the bottom link left .
so , and that give us thi and reduc it to the other situat that we had befor .
and then we rotat the top link right and then , we flip the color .
so , thi on we us all three of our oper , rotat left rotat right and flip the color .
and that get us an insert into a tree that ha from a tree that i s a singl three node to a tree that is three two node that is contain three kei .
so that sort of oper is go to work in a big tree when we insert into a new three node at the bottom .
we do the standard bst insert , color the new link red , and we do the rotat that we need , either on or two rotat to balanc the temporari four node , and then we flip color to pass the red link up on level and then remind me to rotat to that to make that on lean left .
so , for exampl if we insert h in to thi tree here , it come off as the left link of r so that give us a temporari four node that's not balanc so we need to rotat the link from s to the right and that give us now temporari four node that is balanc and again , these ar all local transform it's not chang the rest of the tree .
now , we flip color and that give us a , a good red black tree , except that , that on red link that we just is lean the wrong wai .
so , now we need to rotat left and then onc we've done that , now we have a legal left lean red black tree .
so that's a insert into a three node at the bottom .
so , here's anoth on that involv , rememb , we pass that red link up .
there might , if that get pass up to a three node , then we have to continu move up the tree and just treat it in the same wai as we just treat insert at the bottom .
we have a new red link appear into some three node .
there's the three case that could happen and here's an , an a , an exampl .
so , sai , we're insert p into thi left lean red black tree it goe to the right event so we get a temporari four node that's got two red link both children ar red in that thing so we want to flip the color .
we flip the color and now our temporari <num> node is up higher in the tree but it's not balanc so we ar go to have to do two rotat to make that balanc .
first on is to make the bottom link left lean and then the second on is to make the top link right lean so that we can have the temporari four node balanc .
and then the last thing we do is flip the color and now that's the result of that insert .
it's a bunch of transform but thei're all simpl us our flip color or left or right rotat .
and that on happen to be at the root .
if that red link were , were wai down in the tree and there were anoth three node about it , we might have to do it again .
again , exactli as what would happen in a <num> <num> tree .
so , let's do a demo of construct the red black bst from our standard set of kei .
so , we start with a singl kei .
now , if we want to insert e , if it goe to the left , that's fine .
that's a legal left lean red black tree .
a would go to the left of e two left in a row so we have to rotat that to right .
and then we have to flip the color .
and that's a legal red black bst .
so now , if we insert r into thi on then it goe on a red link to the left of x , s and that's fine , it's a red black bst .
and now , if we insert c into thi on , it goe less than e , greater than a it's a red link connect a and c but it's lean the wrong wai .
so , we have to do a left rotat , legal red black bst .
and you want to insert h that goe to the left of r , two red in a row , rotat the top .
rotat the top , our temporari four node is balanc , flip color .
now , we have a three node , but the red link is lean right so we have to rotat .
and now , we have a legal red block bst .
insert x into that on that goe to the right of s , it's lean the wrong wai , rotat left .
insert m into thi on , goe to the right of h , lean the wrong wai , rotat left .
most of the oper ar simpl on like thi happen at the bottom .
insert p , that goe to the right of m that make m a temporari four node that happen to be balanc , so flip the color .
flip the color , now we h av a temporari four node that's out of balanc so we need a doubl rotat .
first rotat e to make that link point lean to the left , then rotat r to make the , bring the temporari four node into balanc .
and then , flip the color and that's a legal red black bst .
insert l into that on .
it goe to the right of h , lead the wrong wai rotat left .
and that's an exampl of build a red black bst from our standard set of kei .
now , we're readi to look at the implement for , of the code for insert into a left lean red black tree .
and the kei to understand thi code is to realiz that the same code , code handl all of the case .
and the wai that it work is we ar alwai reduc on case to anoth .
we get thi most complic case we did a left rotat on the bottom node and that , that transform it to thi case where thei're both lean left .
and then we did a right rotat on the top node , and that transform to the case where our temporari four node is balanc .
and then we flip color on that .
so , for a particular insert , we can take advantag of thi reduc on case to anoth by , in , in the wai that we're move in the tree , not to get everyth happen with just a , a few extra line of code in our standard binari search tree .
so , in grai is our , standard insert code for binari search tree .
and rememb we took some pain to think about the recurs implement where when we go down a link we replac that link by whatev the recurs routin give us back and that strategi is go to pai off in give us a realli simpl code .
and becaus in thi implement for left lean red black tree we're go to return the link whenev we're done , and then that will get that link instal up in the node abov whether it be left or right .
typic implement of red black tree that do not us thi recurs strategi wind u p have lot of case depend on whether left or right or doubl rotat to the left or doubl rotat to the right can be critic of thi code becaus my own wa thi wai for the first three edit of the book .
and it's onli in thi edit that we figur out how to make the code thi simpl .
okai .
so what ar the thing left to be done ?
let's just check .
when we insert a new node all we want to do is creat a new node with the , i've given , associ the given valu with a given kei , as befor but now we just make that node red .
so , that's ad a new node with a red link at the bottom insert that into whatev the two or three node it's attach to .
and then we do the comparison as , as befor and that , and that's all fine .
now , when it's return then that's the point at which we're go to check whether the left , the link ar lean to the left as thei ar suppos to and whether or not there ar ani doubl link or not .
so the first thing is if , if is red h . right and not is red h . left ?
so , that mean h is h . right is red so that mean the right link of h is lean the wrong wai .
so , h is a three node lean the wrong wai .
so we just rotat left h .
so , whenev we find a right link , we're sit on a right red link we just rotat it left and return that .
so , that would be in thi case here , we'd rotat it left and reduc it to that on .
or in , in you know , in the case when we're just insert a new node and it's turn out to be the right red link attach to a black on , if that handl that case .
now , if h . left is red and h . left is also red that's thi case here where we have two left lean red link .
and then in that case , we just rotat the top on right and that bring us to thi on .
so , notic , we're in thi case we do thi rotat first , we're on thi node and then , that return and we come up to deal with the situat on thi node after the return , and then we do that rotat .
and then after that rotat , or if there were no rotat at all , if the insert happen over here then we'd test and flip the color .
it's a littl mind bend at first becaus of the recurs structur but it won't take you long to convinc yourself that thi littl bit of extra code complet the implement of left lean red black tree .
it's quit remark , actual .
so , let's look at a visual .
watch the , thi is a balanc tree get construct in the worst case where everyth that come in is in ascend order .
a regular binari search tree will just be all strung out in a singl line and wouldn't have quadrat time for thi input but a left lean red black tree actual when , whenev it becom a power of two is complet balanc as you can see from thi exampl .
even though thei came in , in ascend order , the tree wind up be perfectli balanc .
and what about descend order .
well , it's left lean and the process is a littl bit differ and sometim the left path can get long but not that long .
the wors that can happen is that it altern red and black .
and then after it get to that wors case it also wind up be complet balanc when we have a power of two .
interest to think just , just about thi case and to prove to yourself that it's alwai go to be perfectli balanc when it's descend .
and thi is just for random insert .
the tree stai veri balanc .
it's guarante that the longest path which is altern red and black can be no more than twice as long as the shortest path which is all black .
and so in thi case the longest path is ten and the averag path is seven for <num> .
veri close to log base two of n .
so easi to prove by correspond with <num> <num> tree that t he height is guarante to be less than two log base two n .
everi search in left lean red black three is guarante to take less than two log base two of n cuz everi path get the same number of black link so you never have two red link in a row .
and actual , in typic applic with ani kind of random or even if there is a lot of order it difficult to find situat order of kei that build the trace of height is bigger than actual on log n in , in a real applic , it veri close to fulli balanc all the time .
so , that complet our summari for a symbol tabl implement with red black bst .
we have full code it's the regular bst code with the coupl of line ad the call and the basic oper .
she rotat right , rotat left .
in color flip , we could guarante logarithm perform not just research , insert , in delet code .
delet code is a bit more complic but it's on the book side and in the book .
but also , sinc it's the compar to interfac , and sinc it's a binari tree represent all the other compar oper extend oper for order symbol tabl ar go to be implement and take time proport to the log n .
a lot of peopl ask why us the name red black .
well we invent thi data structur thi wai of look at balanc tree at , at xerox parc which wa the home of the person comput and mani other innov that we live with todai enter graphic user interfac and internet and object orient program and mani other thing .
but on of the thing that wa invent there , wa the laser print and we were veri excit to have nearbi color laser printer that could print thing out in color and out of the color , the red look the best .
so , that's why we pick the color red to distinguish red link the type of link in three node .
so , that's an answer to the question for peopl t hat have been ask .
now , here's anoth war stori about red black bst .
as i mention thei're wide us .
and there wa an exampl not that long ago , where a telephon compani contract with a databas provid to build a databas that could store custom inform and the provid implement the databas us red black bst for search and insert .
now , our , our origin paper on red black tree wa the wai the paper wa laid out , it turn out that the delet implement happen to be place after all the refer .
so , a lot of peopl didn't see the delet implement .
and also we didn't have the simpl left lean represent .
so it wa more complic and involv a lot more case and so usual not all the case were put in the text book .
so , peopl found delet more difficult .
in fact , that's what lead to analyz the situat then come up with a left lean variant .
so , what thei did in thi implement wa thei just put in regular hibbard delet in the binari search in the red black bst .
not the delet algorithm that's guarante to keep the constant black height all the time .
and so but , but thei still thought that it should be balanc and it shouldn't matter much .
and thei had a complex error recoveri process that , that got trigger if the height limit got too big .
and thei rebuild the whole tree and , and then becaus of the wai thei did thi delet , well , the end of the stori wa that thei had extend the client had extend outag becaus the implement didn't us the full algorithm .
and there wa a lawsuit and some legal testimoni and i am happi to report that , that it wa clear that hibbard delet wa the problem onc the expert analyz it and the expert wit , who's a colleagu of mine , said if implement properli , the height of a red black bst with n kei is at most two log n .
and so that's the st ori of red black bst's guarante logarithm perform for all symbol tabl oper .
okai .
we're go to finish up by talk about some , practic applic of red black tree .
and in particular , b tree which ar a gener , gener version .
so the idea the sign behind bee tree is that often , the data that we're , try to store is , is realli huge .
there's a , a larg amount of data .
and we're , we're go to look at a more gener model for extern storag .
where , we work with continu block of data that ar big .
mayb four , 4k or bigger , or mayb even a whole file .
and all we want to count is the first time we access a page , becaus the main cost is try to find where the page is .
onc it's read in we get to read all of the page for free pretti much .
so the real properti of extern storag that not your local memori , is that the time requir to get to a page is wai larger than the time to access data within a page .
so what we want to do is try to access data that's out , extern , us a minimum number of probe .
that's a model of a file system that is pretti workabl .
and so bee tree ar a gener of .
balanc tree , that allow for thi .
the idea is to , allow not just two or three , kei per node , but a larg number like the number that can fit in a page .
so , might be , m <num> or m <num> .
and well , we've gotta have at least , two , kei at the root .
and , and the onli other restrict is that , we don't want the node to get too empti .
so we have less than m .
but we want to have at least m over two .
and as you'll see , thi is , a gener of , two three tree .
that allow us to , build balanc tree that , ar veri , veri shallow .
typic , these ar set up so that , the , all the data is in the extern node .
and so the extern node have no link , thei just have kei .
and their in , kept in sort order .
so , for exampl , thi is a extern , thi is m six .
thi is an extern five node .
so it's got five kei .
it's got , room for on more temporari on , and then what will happen is , when you insert into a full node , it'll split in the same as befor .
and then we'll pass the s plit up caus a split up higher so the red kei in the intern node ar copi of kei down below that direct the search .
and it is that , that's a littl extra detail .
it just make the implement a littl bit easier and that's the wai it's usual done .
so but for now the main idea is that it's like a <num> except that we allow wai more kei per node .
and then when a node get fill it split .
into two so a node is alwai between half full and full .
so it's in <num> , it split in two .
and then each side ha <num> .
and then we can us , that properti of the tree , in the analysi to , show that , it's not go to be veri mani probe to get to ani kei .
so the , search is , you know , just the same as we've been do , just gener .
there's a list of kei at everi intern node and that kei , tell you that , then link for everi kei that give you , a place where your kei would have to be .
so , thi link is for all the kei in the b tree that ar between thi kei and the next on and in everi case , it's that wai .
so if we're look for e .
b and thi b tree would go down the left link .
and then look on the second link cuz e is between d and h .
and that's just the wai it organ .
and then when you get to an extern node you just look for and so that's a , that's the all search termin in extern node , in other word that's just a gener of what we just did .
and insert , work the same wai , where we get to the bottom , and then , and then we split .
so let's look at just insert a into thi b tree .
it come into the node on the left .
and then that make that temporarili over .
it's got on too mani .
so we split it into two node .
and that caus us to add a new entri into thi intern , node .
in thi case , it's the c , which is the smallest on in thi new page .
and that had to be ad .
and we can move all those over .
there's plenti of time by the memori model .
we're onli count the number of time we access the page .
we get to move thing around for free .
and you could have some hybrid struc ture where you us someth differ for the intern model .
but usual it's fine just to do that .
now that on becom overful .
so it ha to split and we have to creat a new rout , just in the same wai as we've been do .
so without see all the detail yo can understand that the same basic idea is go to work in thi situat where we're deal with much , much more memori .
and so the end result is that a search or an insert in a b tree in a order m , that's where we're put m kei per page , requir between log base m 1n and log .
base m over two m probe and that's go to be a realli small number , so sai m is a <num> , log base m over two is , is log base <num> .
so what power do you have to rais <num> to get bigger than n ?
in practic that's go to be like four or five .
and we can keep the root page in memori so that it mean , for ani conceiv applic , you can get to ani piec of data .
even if it's trillion of , of piec of data in thi huge , huge file .
you can get to ani on with onli five or six probe .
that's quit amaz .
it's realli an astound exampl of algorithm technolog .
do someth that , you wouldn't realli , necessarili think that you could do so easili .
maintain a dynam search symbol tabl with trillion of kei , so that you can get to ani kei just by look five or six place but that's what b tree provid for us .
thi is a simul that show a , a grow b tree so when a page , at the top , there's just on page that fill up .
when it fill up , it's red , and that split into two half page and then kei get ad on on side or the other so each .
ly in thi tabl some page get a new kei and eventu on of them fill up and split .
now we have three page and we keep go eventu on of them fill up and split .
now we have four page and now thi time the first on fill up and split and so forth .
so the black is the occupi part of the page .
the white is the unoccupi part .
and the full page about to split then right below there's two page .
s o thi show the process of build a larg b tree .
and that and you can see the amount of black .
it's kind of half empti .
it's a littl more than half empti usual now , as thi show .
and , and peopl have variant of these algorithm that keep it more , much more than half empti if that kind of space is a , is a consider .
so , as i've mention , red black tree and b tree ar wide us as system symbol tabl .
the java implement of tree map and tree set is red black tree , c , the standard templat librari us , red black tree .
and it's also , us in the , linux kernel , and in mani other system .
b tree , there's mani differ variant that , give differ characterist of , space usag and other characterist .
in most databas , nowadai that , that you might us .
sql or oracl databas and other , ar base on , some variant of b tree becaus thei're so , so effect .
but you realli know that your data structur and algorithm is us by a lot of peopl when it appear in the popular cultur .
my friend philipp flajolet who recent di wa a famou french mathematician send me an e mail late on night .
he wa quit excit becaus he wa watch a re run on , of an english actual canadian tv show on french tv .
i didn't know he spend hi time do that but he wa veri excit becaus he saw thi clip .
it wa the red door again .
i thought the red door wa the storag contain .
but it wasn't red anymor , it wa black .
so red turn to black mean what ?
budget deficit , red ink , black ink .
it could be from a binari search tree .
the red black tree track everi simpl path from a node to a descend leaf that ha the same number of black node .
doe that help you with the ladi ?
so not onli is there some excit in that dialogu but it's also technic correct which you don't often find with math in popular cultur of comput scienc .
a red black tree track everi simpl path from a node to a descend leaf with the same number of black node thei got that rig ht .
and that's also true of b tree and both of these method ar veri effect and wide us .
welcom back .
todai , we're gonna take a look at a number of interest applic of symbol tabl and the binari search tree data structur to address problem with process geometr data .
so let's take a look at it .
the idea is that we're gonna be talk about geometr object , not simpl kei like string and number .
so here's an exampl .
so sai your geometr object ar point in the plane and you specifi a rectangl that's orient with the horizont vertic ax .
and you might wanna ask , which point ar insid the rectangl or how mani point ar insid the rectangl ?
or mayb what you ar process is rectangl .
you have a set of rectangl , and we want to know which of these rectangl intersect ?
or how mani rectangl intersect ar there ?
these ar interest problem that have lot and lot of applic , from computer design , to game and movi and also in abstract such as data base and other situat where you might have multipl kei or multipl dimens .
and it's a veri interest extens of the idea that we've look at for symbol tabl for all sort of familiar applic .
and , surprisingli binari search tree and these associ algorithm that we've look at ar go to provid veri effici solut to a number of import problem in thi area .
and realli have enabl a new develop and new technolog in all of these kind of applic .
so , to get start , we're go to look at a simpl problem call on dimension rang search .
and it realli form the basi for what we're go to do .
it's a littl bit of an extens of the order symbol tabl api that we gave befor and we're go to have oper rang search and rang count .
so , a on dimension just mean we have on kei , so we'll insert a kei valu pair befor and what we want to do is to be abl to search for a kei , and a valu associ with it , want to b e abl to delet .
but then we want these oper rang search and rang count .
so , find all the kei that ar between two given kei , or give how mani kei ar there between two given kei .
so , for thi exampl at right we have insert a number of kei and , and we're just show them in sort order .
but then , you might sai , well , how mani kei ar there that ar between g and k ?
in thi case , there's just two .
and then the client might sai , well , what ar those kei and you want to be abl to return them .
and thi is a veri common oper , sai , in databas .
you want to return how mani taxpay have salari between on million and ten million and then which on ar thei and so forth .
so , rang search is a veri import fundament oper .
now , in geometr interpret , we just think that the kei as point on a line .
and so , the kei valu well , ar just specifi as point on a line .
we might convert the letter to number , or we might , kei might be number .
and then , what we're look for is to find or count the point in a given interv in on dimens .
so how we're go ti implement that ?
well thi is the basic problem that is veri similar to our symbol tabl problem .
we might consid keep the thing in an unord arrai .
just put them in an arrai , and then , well , insert is , is fast .
we just add it to the end of the arrai .
we might have to us resiz to make the arrai grow .
but thi is unattract becaus for larg number of kei , in order to count the kei that fall within a given rang , you have to go through all the kei and test whether thei're in the rang or not and to return them the same wai .
so take linear time for larg number of kei .
if you keep the thing in order like in a binari search situat then to insert in order to keep it in order in an arrai , you might need to move the larger on over on po ition and so forth or elementari implement of binari search when we did symbol tabl did thi .
so , the insert time might be linear , but then you can us binari search , to look for the two endpoint , that's onli go to take time proport to log in .
and then from that , you can figur out how mani kei there ar or return them all between the index , the lowest on in the rang , index the highest on in the rang .
so , those elementari implement ar no accept for a larg number of kei cuz thei have the linear time oper .
so , what we realli want is to have time proport to log in .
for insert and , and for count .
for rang search , of cours , we , we have to touch everi kei that we return , so the run time is go to be proport to the number of kei that match .
but anywai , those ar reason goal .
and thei're easi to achiev .
so so , for exampl what about on dimension rang count ?
well , what we're go to do is just keep the kei in a binari search tree and we look at the implement of the rank function for binari search tree where for everi kei , we can comput how mani kei ar there that ar strictli less than that kei .
so in thi case , the rank of e is two and h is three and so forth .
so , in a binari search tree , those rank number go in an increas order as we do in an order travers and that's easi to comput .
you need to keep that rank tree as a field , or keep a field which ha the size of the tree and it's easi to complet the rank from that .
so how mani kei between , sai e and s ?
well on , two , three , four , five .
it's actual just the differ between the rank plu on if the high entri in the rang queri is in the tabl and not on over .
so , there's the same number of kei between e and s as there ar between e and t five .
between f and t , there's onli f our .
so , that's a , a realli 1d rang count is a veri easi comput to perform in , in log time with a binari search tree .
the number of node examin when we do a search is the length of the search path to low plu the length of the search path to high to find their rank and that's go to be time proport to log n .
so and a rang search .
well , we just do a recurs search and to find all the kei between low and high you look in the left subtre if ani of them could fall in the rang .
you look at the current node and you look at the right subtre , if ani of them could fall in the rang .
and it's easi to tell whether ani of them could fall in the rang by just check whether thei're rang overlap the root or not .
so , if we ar look for all the kei between f and t then we have to look at both the subtre of the root s .
but we don't to look at the left subtre of e becaus all of those ar less than e and therefor ar less than f .
so , we don't have to have to look there .
but otherwis , it's a simpl modif of recurs tree search to find all the kei and it's easi to see the run time to that is go to be proport to the number of kei return plu log n .
so , that's on dimension rang search us binari search tree .
so now let's look at a basic geometr data process problem of determin intersect among a set of line segment .
so , it's call the orthogon line segment , segment intersect search where the line segment or constrain to be either horizont or vertic .
and so , suppos we have a larg number of such line segment and what we want to be abl to do is to find all place where thei intersect .
and as we'll see thi extend to a practic problem in a number of situat .
so , in thi case there's four place where these line intersect .
so , how ar we go to be abl to determin these intersect effici ?
now , the natur algorithm , or the naiv brute forc algorithm , is quadrat in time .
so that is , for everi line segment , you check whether it intersect with everi other line segment .
and again , as we know , such an algorithm is not go to be practic , for huge number of line segment .
so , just , to simplifi our code in the slide in it's off , off from the case for geometr data process .
we don't have to worri about degeneraci where lot of thing have the same x or y coordin .
and just to simplifi the code and to get it the main principl of the algorithm , we're go to assum that all the coordin that we have ar distinct that we've preprocess in some wai to remov the on that touch without intersect .
so the method that we're go to look at is a so call sweep line algorithm and the idea is to think of vertic line that sweep left to right through the data .
in to .
consid it as a everi time it hit some line segment as an event where we have to do someth .
so sweep from left to right mean we consid each x coordin as an event .
so first thing is if we hit a horizont line segment .
well we're go to hit the left endpoint first , and so what we'll do when we hit the left , endpoint is , insert , the y coordin of that line into a binari search tree .
so , we're go to keep track of y coordin in a binari search tree .
so that's what's happen over in the right there .
so now again , sweep from left to right .
what's the next smallest x coordin ?
in thi case it's the line number on there , and we'll rememb it y coordin in a binari search tree .
and then two and three .
so those that's on kind of event that can happen as we sweep from left to right .
anoth kind of event is that we hit the right endpoint of a horizont line segment .
in thi case we hit the right endpoint of line segment two .
so , at that point the right point of a horizont line segment we just remov it becaus we've process that line complet .
in thi case we didn't find ani intersect .
so , left endpoint insert the y coordin into a bst , right endpoint remov that ycoordin from the bst .
so , the bst contain the y coordin of all the horizont line that current might involv an intersect .
and then the third kind of event is what happen when we hit a vertic line segment ?
well , in that case all we want , need to do is just do a rang search , for the interv of y end point .
so , ani point that's insid that interv , is go to repres a horizont line segment that is an intersect .
that's the basic idea behind the sweep line algorithm , to find intersect in set of horizont and vertic line .
and it's actual a veri simpl algorithm , and it's veri easi to see that the run time is go to be proport to n log n plu the number of intersect return .
where there's n horizont vertic line segment .
and it's , and a coupl of wai to implement it , on thing is you could sort accord to the x coordin , or you could just put them all on a prioriti queue .
and then , so , so that's go to take n log n for everi on of the line to process them all either n to build the priorit y queue and then log n to take the smallest off each time , or n log n for the sort .
and then put the y coordin into , into a binari search tree is , again , n log n .
and same for delet .
each point ha to be insert , delet .
it could be as mani as n in the tree for each on .
so it's a total of n log n .
and then the , rang search , in the binari tree , for each , each on of the rang search .
it might take , log n , it might be as mani as n .
and then there's , plu the number of point return .
so , that's a , quick sketch of the proof of thi proposit .
now we're go to look at kd tree , which is an extens of bst that allow us to do effici process of set of point in space and it's veri flexibl and veri us in lot of applic .
so now we're go to extend the api to talk about two dimension kei .
so that's just , you can think of two dimension kei as , point in the two dimension geometr space .
so we're go to talk about insert , and search .
we won't talk about delet and then rang search and rang count .
so , we want to be abl to insert and delet , point .
you can think of a two dimension kei as a point in two dimension space .
and we want to be abl to find all kei that lie within a two dimension rang .
that's a rectangl .
as i mention at the begin or count the number of kei that lie in a two dimension rang .
so again , the geometr interpret is the kei or point in the plane .
and we have a , a , a rang , 2d rang is a , a rectangl , or is orient , to align with the horizont , vertic ax .
and we want to be abl to find or count the point in a given rectangl .
in thi on ha mani , mani applic and we'll talk about some of them later on .
and even if it's not point in the plane , just databas you might ask for all the peopl with incom between <num> , <num> , <num> and <num> , <num> , <num> who ar between <num> and <num> year of ag .
and thi kind of algorithm and data structur would be us for that kind of situat too .
so how ar we go to solv thi problem , implement thi api ?
we build a data structur contain point that can effici support rang search and rang count .
well on easi wai to do it is to just think about divid space into a grid of squar .
so we'll pick a paramet m and divid space into an m by m grid of squar and then process all the point and make a list of point that ar contain in each squar .
we can us a two dimension arrai to directli index , relev squar .
and for insert , you just , take x , y .
figur out which squar it belong to .
simpli divid by , both coor dinat by n , and look into the two dimension arrai .
and just add the point to the list for the correspond squar .
and then rang search , onli find the squar that intersect the queri , and process the point , in that squar .
and depend on the valu of the paramet m , you have a space time tradeoff .
the amount of space requir is m <num> for the grid n .
you have to have a link list element , or whatev for each point .
and then the time , though , get divid by m <num> .
your number of point and were spread out over the n squar , differ squar .
and so on averag you examin n over m <num> point per squar .
so you don't want to make m too big that would be too much space , you don't want to make m too small that would be too much time .
so what we want to choos is the squar size that would best balanc these two need and then it is easi to see that what you should choos is m to be about n squar root of n .
so then your space is within a constant factor of n and your time is constant .
so if the point ar randomli distribut , then thi is ideal .
it take us , linear time to initi the data structur .
and to insert and search , it take constant time per point in the rang .
and thi is absolut a fine method that , is not that difficult to implement , in the case that the point ar evenli distribut .
unfortun , it's usual the case that , in geometr data , that the point ar not evenli distribut .
there's a well known phenomenon known as cluster that sai that , the , the point aren't go to be evenli distribut all over the whole thing .
in the case of the , the grid implement , thei might all fall on the same squar .
and so , the averag list length is short .
thi is like what we encount with hash .
if you take , all the point in on squar , and zero and all the rest of them .
your averag is still , n over m squar .
but .
thei ar all in that long list and you're go to have a slow algorithm if it's , if it's base on thi .
so we need a data structur that more gracefulli adapt to the distribut of the data .
and again it , it's well known that most geometr data ha thi kind of problem .
so for exampl here's some data which citi in the us .
it's got <num> , <num> point , but if you try to us the grid implement for thi , you'd find that half the squar would be empti .
and half the point ar in just ten percent of the squar .
so , the cluster in the data is go to make the implement ineffici .
we need to adapt to the data .
and thi is veri , veri typic , in geometr data .
particularli , in higher dimension data , as we'll see in a minut .
so , peopl have develop all differ kind of , method for , adapt in thi wai .
and what we're go to look at is on of the most wide us .
which is basic to us a tree to repres a recurs subdivis of the plane , of two dimension space .
it's go to be recurs .
it's go to be base on the point the wai in which we divid into half plane .
and it on of mani differ algorithm that , have been , studi for thi , but again it a simpl on and wide us .
so , for exampl if you plai the game doom or us the flight simul , that , these type of graphic simul and anim ar made possibl onli through the us of space partit tree , like 2d tree and quad tree and also in all differ type of scientif data process these thing ar extrem import whenev you're process .
geometr data , do some kind of geometr search .
where is the closest thing ?
how am i go to find the closest thing effici ?
what thing ar nearbi , and so forth ?
so , rest assur , these type of algorithm , lie at the heart of , ani program that you us that , is involv a lot of geometr data .
so , those ar just , two exampl .
so let's look at how it look now .
so , a 2d tree , is , again , it's go to be a data structur base on a bunch of point that's go to facilit , effici data process of these point .
so , just as we do for , symbol tabl , where we take , kei .
now we're go to ta ke point , and we're go to build a data structur base on these point .
and the idea is to , build a tree that correspond to recurs partit the plane .
so arbitrarili our first point we're go to divid the plane into two part base on a vertic line through that point .
so now , in the tree on the right there , all the point that fall to the left of the first point ar go to be on the left , and all the point that fall to the right .
that first point , you're go to be on the right .
but then we get to the next point , we'll switch and we'll partit on a horizont line .
so now , our second point , in the tree , the left sub tree correspond to everybodi below that horizont line , and the right sub tree correspond to everybodi abov it .
similar if our third point come on the left again we'll partit accord to the horizont line through that point on the left .
so if we go left and then left that mean all the point to the left of on and abov three , so the squar in the upper left is repres .
by , that node in the tree .
and , again .
now , when we go on level below , we switch again to vertic .
altern between horizont and vertic partit , of the plane .
so it's a regular binari search tree .
but it's got thi interpret base on the geometr data , where we switch which kei we us for , the comparison , the x coordin or the y coordin , at each level .
and that correspond to thi partit of the plane .
so now five come in , that's to the left of four becaus it wa partit at a vertic and five's go to partion on a horizont .
thi is simpl , and complet well defin partion of the plane correspond to a binari tree .
now the ninth point well it's to the left of eight , abov to and to the left of eight and then correspond to horizont partit , tenth point is to the right of on , it's below two and we go to the left and it's to the right of seven so we go to the right .
so that's a wai to build a binari tree correspond to a partit of the pla ne .
and it's realli the same as the binari search tree .
it's just that we altern which coordin we us as the kei .
at the even level , we think of a vertic line .
and the left subtre is all the point to the left , and the right subtre is all the point to the right .
on odd level , we us a horizont line , in the left subtre all point below .
in the right subtre , all point abov .
and the , and the code for thi is , you know , the same as for binari search tree .
it's simpli , which , coordin we us for the comparison .
that's the onli differ .
so that's 2d tree implement .
so now what about solv a problem like thi rain search problem for a 2d tree .
so now we have a queri like thi green rectangl and what we want to find is all the point in the data structur that fall within that rectangl .
well , we're go to us , the 2d tree repres our point and we ar go to us the structur and definit of that tree , to go ahead and help us find the point that ar in the rectangl .
if , if the root node li in the rectangl then we're done .
we can return that , that point but we have to look on both side to look for more , but if the rectangl li to the left of the root node then we have to look at the left and so forth .
so let's look at how thi work in the demo .
all right , so , we're go to try to find all the point that ar contain in that green queri rectangl .
so first thing is , to check if our rectangl contain the node of the root .
in thi case it doesn't .
so sinc , it's to the left of the split line of the root we onli have to search in the left sub tree .
now , we search the left sub tree and we're go to check if it contain . <num> .
it doe not contain . <num> , but now which , sub tree do we search ?
in thi case , now the rectangl intersect a split line , so we have to search both subtre , both abov and below .
so , first we search the left subtre that's the on below doe it contain . <num> ?
no .
it's to the left so we're go to have to search the left sub tree of . <num> .
and so we search the left sub tree and we check if it contain point five and it doe , that's the on that we return .
it , it also intersect the split line , we have to search both the sub tree , in thi case thei're both empti .
so we're done with that but now we have to go back and we have to search the other sub tree of point three and that's the abov , so now we check thi . <num> in the rectangl .
in thi case , it's not .
and it's still a left swai if it's to search the left sub tree a . <num> and that on's empti and now we return and we're done .
so we don't alwai go down just on branch if our split line hit a rectangl we have to go down both branch but still thi is a veri effici algorithm , particularli think about the rectangl be small , it's go to be not that differ than a regular search in a binari search tree .
all right .
so what about the analysi of how long is thi go to take ?
well again , a typic case .
a rectangl's small that we're onli go to examin , realli , a path of the three , mayb a coupl of other node along the path .
and the run time will be proport to the number of point return plu lg n .
with geometr data the worst case can be bad .
so , like all the point could be arrang in a circl .
all , all differ type of problem that might occur in , with some difficulti .
it's possibl to prove , that even if the tree is balanc , you can get a worst case proport to squar root of that .
so analysi of 2d tree that the under scope .
but , for mani practic applic thei ar easili implement and worth us .
let's look at anoth us 2d tree to solv anoth problem , a so call nearest neighbor search .
so now , instead of a rectangl , we have a queri point .
and our goal is to find the closest point to that point .
so in thi case our queri point is , over here in green .
and our algorithm's go to want to return to <num> .
that's the closest on to the queri point .
so let's see how that look in a demo .
so again , we start at the root .
and wh at do we want to do ?
well , we're go to check .
and i , whenev we're at a node , it repres a point so we're go to check that point and we'll comput the distanc from that point to our queri point .
and , if that distanc is less than the best found so far , then we'll keep that as the champion .
so the first point , that's the closest we've found so far to the queri point .
so we'll sai , number on is the distanc .
and we'll onli worri about the possibl of find someth closer , than that .
and so just us that distanc we recurs search , ani part of the tree that could contain a closer point .
and so that's well it continu to do so in thi case the queri point is to the left of the split line and will alwai go toward the queri point first and so in thi case we have to search both to see if there might possibl be a closer point than on over on the right if you come like straight across , there might be a closer point .
we're go to have a look at both as far as we know now but we'll go toward .
the queri point and see if we can find someth closer .
so in that case now we go to . <num> .
comput the distanc of that point to the queri point .
it's closer so we updat three to be our new champion .
so now we ar go to look in part of the tree that could give us a point that is closer to our queri point then three .
so alreadi that would mean when we search the point on we wont search the right sub tree becaus there could be no point on the right sub tree right of the split line .
so let closer to queri point than three and so that idea get closer and closer to the queri point is go to cut out differ part of the tree as we process so , but anywai start at point three as far as we know that we mai have to look at both sub tree , so sometim when we look at both sub tree but as we get closer and closer we onli look at on so let look at point three now .
so , again , go toward the queri point .
so we'll , go to the top first , and that take us to six .
six is not ani closer than three wa .
so that's not go to , updat our champion .
and so we'll search <num>'s left sub tree which is empti which is right sub tree and the nearest neighbor can't , we don't have to go down the right sub tree of six becaus you can't have a point in that rectangl that's closer to the queri point than three .
so now we can return from that , and now we have to look at the bottom sub tree associ with three .
and so that take us to four , and that on is , not closer .
so we still have three as our current champion .
so now , we'll search the left subtre of four first becaus that queri point is to the left of that split line .
and that take us to five and five is our new champion .
so that's the closest point that we know about .
could there be a node that's closer to five , to our right queri point than five in the right subtre of four ?
oh .
we have to go abov .
sorri to look at the top sub tree associ with five , and we find that it's empti .
and now we're back at four .
do we have to search the right sub tree of four ?
no , becaus there can't be a closer point , than five in the right sub tree of four .
so we're done with four , and we return to , come to three , and now we search the , suppos to search and return from there we ar now at on , suppos to search the right subtre on next but we can term that nearest neighbor couldn't be in there .
so , then we ar done and we found that the nearest neighbor , is five .
and thi is go to be , veri effici becaus as we get closer and closer , the queri point , we ar cut out all the subtre that ar awai , and again in practic , the run time of thi algorithm , is go to be close to logarithm .
so in , in typic case that the run time of nearest neighbor search in a 2d tree is go to be proport to logarithm .
it is possibl to concoct case where you ar go to have to examin all the point for exampl if thei're all arrang in a circl and your queri point to the center or someth of that sort .
but for typic data it's veri effici .
now we're go to look at an applic where we simul a phenomenon in natur .
and thi is what kind of pattern do thing like starl and gees or crane or , or fish or firefli ?
how do thei flock togeth .
and we'll look at a simul that correspond to that .
and then , when the moment is right , thei behav in a wai , that should be imposs .
and it happen everydai , right through the winter .
just a coupl of mile from my doorstep .
help you desir .
so to , there's a simpl model develop by craig reynold awhil ago for simul thi situat call the boid .
and the idea is to us three simpl rule to you get someth veri close to thi complex flock behavior .
so , you have col , collis avoid where you alwai try to point awai from the k nearest boid .
you have center where you try to point near the center of mass of the k nearest boid , and veloc match where you updat your .
philosophi to the averag of the k nearest boid .
and that algorithm work like thi .
so as that exampl show , 2d tree ar extrem effect in quickli process huge amount of geometr data , and what's more , it expand to more dimens .
with a veri simpl modif we can take it to d tree and creat data structur known as a kd tree , which even work for k dimens and the idea is even if there is k dimens , what we will do is recurs partit on dimens at a time , so that's call a kd tree and we us the same idea for two d tree , but instead of cycl through just horizont vertic , we cycl through , howev mani dimens there ar , so it where in three space , we us a plane and do abov and below and then simpli cycl through the dimens .
at level i , we put on the left point whose i th coordin ar less than p and on the right , we put the point to whose i th coordin ar greater than p and at level in cycl three of the dimens at the level i might k we just us that dimens of the point to do the comparison .
the implement is simpl , ex cept for the comparison .
and we get the same kind of partit for three dimension data , so we could do boid in three dimens or for databas with larg number of dimens .
you could do even much higher dimension data .
and find nearest neighbor and do rang search extrem effici .
it's a veri effici and simpl data structur for process k dimension data that's veri wide us and the whole idea is that data cluster , particularli , in high dimens .
and also on point to make for thi class is that , thi algorithm wa discov by an undergradu in an algorithm class , so that's , john bentlei , who discov thi while an undergradu at stanford .
and , so it's a simpl idea that , but , expert scientist where struggl with , deal with huge amount of geometr data , and , bentlei found thi wai , to process it effici that's been wide us ever sinc .
and in , in particular just as anoth exampl consid the idea of n bodi simul which is a classic problem in physic .
where you've got n particl mutual affect by graviti and basic the comput is base on comput the interact forc for each pair of particl .
and so then there'd be mutual gravit pull .
and thi is what happen with a larg number of particl in a certain simul and peopl understand properti in the univers by come up with , do these kind of calcul and compar against what's observ in space .
now but the thing is for each pair of particl , so if you have m particl and you have to do it for each pair , that's m <num> so the progress of scientif investig is go to be affect by how quickli , you can do thi calcul for a larg number of particl .
there's a lot of particl out in the univers .
and , you can't do a quadrat calcul for larg n .
so , anoth , undergradu in an algorithm class discov , thi idea , for n bodi simul .
and that's , andrew appel .
and hi idea wa that if some part .
particl is wai awai from som e cluster of particl , we can treat that cluster as a singl aggreg particl .
and not do the individu forc calcul between our particl and everi on of those in the aggreg .
but us the center of mass .
and you get a veri accur approxim to the n bodi do that .
and the algorithm that he us is base on 3d tree .
with the n particl as node and store the center of a mass of a sub tree in each node .
and then to comput the total forc , travers the tree of all the inform that you need , to , complet the n bodi calcul .
but in time , much closer to n lg n than to n <num> .
and that , idea that , you didn't need to take time proport to n <num> but with a , a geometr algorithm , like a 3d tree , you could get the time to n lg n .
okai next we're gonna look at anoth extens of geometr algorithm to process slightli more complic object and then we'll see an import applic .
thi is call interv search .
so now instead of point , our data is interv .
so thi is , we'll start with on dimens as befor and right awai you can see that it's a more complic problem than we've been deal with .
so we want to support the follow oper .
we wanna be abl to insert an interv .
so an interv is just a left endpoint , right endpoint of a <num> dimension data or point on the line .
we wanna be abl to insert an interv search for an interv , delet an interv but the main thing is we want the interv intersect queri .
so given a queri interv , we want to find all interv in the data structur that overlap that interv or find ani interv we'll start with that simpler problem .
so how ar we go to support that ?
so thi is the api in java code , so we , have , interv , so instead of on kei we have two , which is left and right end point of the interv for input .
and , and then we have delet , and then we have intersect .
and again simplifi the code , we ar go to make the non degeneraci assumpt that no two interv have the same left end point .
and , easi , easi to fix but , but we don't simplifi the code .
so now we'll look at a data structur call an interv search tree that help to solv thi problem .
and , it's a extrem , simpl algorithim , but surprisingli , complic to understand , so we'll go slowli .
so the first thing is what we're go to do is us the left end point of each interv as the binari search tree kei .
so our , eh , our node store interv , but we onli us our left end point as the kei .
so thi is the binari search tree that's built from those five interv , six interv in our exampl .
seventeen , nineteen is at the root , so everybodi with a le ft end point less than seventeen is to the left , the left end point greater than seventeen is to the right and so forth .
so that's a binari search tree built , from those interv .
so that's easi .
i just build a binari search tree .
i just us , the left end point , as the search kei .
but we're also in the , each node of the tree , we're gonna store , not just the interv .
but we're gonna store the , largest endpoint in the subtre root at that node .
so at everi node , we're gonna store the maximum endpoint and subtre root at that node .
so at the root , the maximum endpoint or the rightmost point cover by an interv , is <num> .
so we <num> at the root , and , of cours , the right subtre .
and the left subtre .
the max end point is that eighteen so that's what we store for the associ data with the note to the left of the root and so forth .
so .
we go to have to , that's data that we're go to have to maintain when we do an insert and it's data that we'll us when we're do an interv intersect search .
so let's take a look at an insert into an interv search tree with a demo .
all right , so , the , insert algorithm is pretti simpl .
we do the bst insert , just so we have to do that , updat of the maximum in each node on the search path .
so , to insert <num> <num> in thi tree , while we us the , left endpoint as the search kei , sixteen is the left endpoint of our insert interv we compar that with seventeen and therefor go left .
how sixteen is bigger than five so we go right .
now sixteen is bigger than fifteen so we go right .
and that's null , so that's where we insert our new , interv .
so now , we're gonna go back up the tree .
and , for everi node that we encount , it could be that , our right endpoint of our interv , is bigger than what wa there .
so we have to check , all the wai up the path , the maximum in each node on the path .
so we have to check each node , to see if <num> is bigger , and , for the three node to the left it is bigger than eighteen .
for the node at the root , it's not .
that stai to be <num> .
so , it's just binari tree insert , but then after the insert on the wai up , we go ahead and , check , if the maximum that we have is bigger than the maximum there and updat it if necessari .
so easi to code .
all right , so now about , how do we do a , a search .
so the search is definit more complic and kind of mysteri , but let's look at the rule for search in an interv search tree .
all right so now we're gonna look to see if we have an intersect what a .
we want to find just .
ani interv that intersect thi queri interv <num> <num> .
we're not gonna try to find them all we'll get back to that in a minut .
try to find ani interv that intersect our queri interv .
so let's , let's see what we have to do .
so first thing is if at the root , we have an intersect , then we're done .
we just return .
in thi case , <num> doe not intersect , <num> .
so , we have to go down the tree somewher .
so left subtre is right , okai ?
otherwis , we have to check whether the max endpoint in the left subtre is less than , the low point in our interv .
it's easi to see , well , if that's the case , then we're not gonna find an intersect .
in the left .
the maximum end point in the left is <num> , and we're look for <num> , and we're not gonna find anyth there , so we just wanna go right .
so in thi case we'll go right <num> , <num> no inter section left , so we go right and now we do find an intersect <num> , <num> doe intersect with <num> , <num> becaus <num> is in the middl there , so we find an intersect .
now on the other hand , let's sai thei were look for <num> , so no intersect .
so .
all the algorithm sai is that , if you didn't go right , go left .
so let's go left , in thi case .
so we weren't abl to show that there wa no intersect , on the left .
so , so we're gonna go left .
in thi we compar twelv fourteen to five eight , so now we appli the same rule .
doe it intersect ?
no , it doesn't intersect .
so should we go left .
well no , the maximum , end point in the left node is eight .
so we can have intersect there , so we gonna go right , to twelv and go right .
so , now doe twelv , fourteen intersect fifteen , eighteen it doe not so there's no intersect so now what do we do .
should we go left no the max in point on left is ten so we shouldn't go left .
so we're go to go right .
those <num> <num> intersect <num> <num> .
it doe not , so , now , the left end point's null .
and so we're just gonna go right .
and there's no intersect .
so in both case we just went along on path in the tree to determin whether or not there wa an interv or intersect .
let's look at on more exampl .
<num> , <num> .
so let's see .
<num> thru <num> to seventeen , nineteen .
thei do not intersect , so now , what ar we gonna do next ?
well we're gonna compar the left sub tree , and it's not , <num> fall within our interv so it's not less than'r' so there might be an intersect there so we better go to the left , so we do go to the left .
now we compar against <num> <num> , and there's no intersect .
so now , we're gonna go left to right .
well , we're gonna go to the right , becaus , the max endpoint in the left subtre is eight , and our interv's <num> , so no intersect on the left .
so we're gonna go right .
intersect <num> .
thei do not intersect .
so now , do we go left or right ?
again ten is less than our left endpoint <num> .
so we better go to the right .
and now <num> doe intersect <num> , so we return and intersect .
again on path through the tree to determin an intersect .
so from these rule you can see that the man of code requir to implement thi intersect inter role is extrem low .
just check for an intersect , if we find it ret urn if left is no we go right .
otherwis if the max is less than low we go right .
otherwis we go left .
could hardli be simpler .
realli amazingli simpl and effici algorithm .
we should convinc ourselv realli that it alwai work and so we'll spend just a moment on a short proof .
so let's look at the , the case that could happen .
so first thing is if the search goe right .
then there's no intersect on the left .
and that's easi to convinc ourselv of that just from , from what we did in the demo .
of cours , if the last sub tree's empti , there's no intersect there .
but if the max endpoint in the left sub tree is less than low , that mean everi interv in the left sub tree ha a max endpoint less than mah , low , and so therefor it can't intersect .
so if you go right , there's no intersect in the left .
ani possibl intersect would have to be in the right , and then the other point is that if you go left , then either there's an intersect there , or there's no intersect at all .
so let suppos that there is no intersect , and that's equival to sai , if there is no intersect in the left then there is no intersect in the right .
so let look at it if there is no intersect in the left , sinc we went to the left and then we have got , low less than max .
but , for ani interv , in the right subtre , it got to appear after .
low .
be , becaus sinc there's no intersect in the left sub tree high ha gotta be less than c .
where , becaus thei're sort by left n point .
and then that mean that c s got to be less than a if it is in the right , so therefor there can't be ani interesect in the right either .
no intersect in the left mean no intersect at all , so those two case is enough to show that thi algebroid find an intersect , if there is on .
and the other thing we can do with thi is just us a red black bst to guarante that we solv thi in time proport to log in .
so insert , find , delet , and find ani interv that intersect .
all take time , guarante , proport to log in .
and if we wanna find all interv we just have to run the algorithm fur each interv that's , until we come up against no intersect , so it'll take time proport to r log n if there's r interv that intersect .
the theoret best that you could possibl do would be r plu log n but in practic r log n is quit effici .
thi is an easi and veri effici algorithm to solv thi interv search problem and as we'll see thi algorithm .
to finish up , we're go to look at the rectangl intersect problem that's got import practic applic and , us the techniqu that we've been studi so far .
and it's a simpl gener of our line intersect problem .
so now , we have a bunch of rectangl .
thei're all orient horizont or vertic .
and what we need to do is find all the intersect in that set of rectangl .
and again n could be huge in applic , as we'll talk about in a second .
and the naiv brute forc algorithm involv check each pair of rectangl for intersect .
and what we want is a more effici algorithm than that as usual .
and again , to keep the code simpl we're go to assum that all the coordin ar distinct .
we don't have ani , ani equal line that we have to worri about whether we consid rectangl that touch to be intersect , and so forth .
so that's , that's the problem , rectangl intersect search .
thi is histor , an extrem , import problem .
in the 1970s , when we switch to veri larg scale integr for comput , we were switch from a situat where we were wire physic devic togeth , to a situat where we were essenti draw the comput .
and there were machin that would take draw and , and return , and from those draw , like thi , make , physic thing that implement comput with differ layer and differ , physic materi interact , in differ wai .
some thing ar wire , and some thing ar switch that , ar us to , implement memori bit and comput logic .
but the kei point about it is that design a comput becam a geometr problem .
and so , peopl , to design new comput , would , make huge draw that just show the line that correspond to the materi that had to be creat to make the comput .
now , it wa veri expens .
you didn't want to have ani bug when you're make a chip .
and , there were variou rule about what you can do on these draw .
and basic , these rule had to do with do thi ortho , orthogon rectangl intersect search .
you , you can't have line that come too close to other line , certain type of line can't intersect .
need space between certain type of wire and , you want to , befor you tri to make the physic circuit to do thi check , which involv thi orthogon rectangl intersect sort .
and it wa actual the case that the progress of faster and faster processor with more and more compon wa slow becaus peopl were us the naiv quadrat algorithm to do thi design rule check .
and it exampl of , of moor's law .
so , as we built a faster comput sai , in 1970x , we need to check in rectangl .
but now , mayb a year and a half later , you have a comput that's two time faster but you also want to build a bigger comput so you have twice as mani rectangl to check .
so you have two end rectangl to check now , and your comput's twice as fast .
so , we get to us the faster and bigger comput to build faster and bigger circuit but that doesn't help if you're us a quadrat algorithm .
if you're us a quadrat algorithm and it take you n dai to check your design rule , and peopl were run these thing on the order of dai , then for the next comput , it would take 2n dai , it would take twice as long .
and so peopl that were us quadrat algorithm were definit held back and , it wa , ed , ed mccreight at xerox park who , discov interv search tree and the logarithm algorithm that allow us to sustain moor's law and keep build bigger and bigger comput .
by chang thi quadrat algorithm to a linear logarithm algorithm , and let's see how it work .
realli , it's a modif of the sweep line algorithm that we look at for intersect line .
but now we're go to us that for intersect rectangl rather than us rang search as our basic oper , we're go to us interv search .
so now , everi time the line sweep hit a rectangl , that correspond to an interv .
if it's the left part of a rectangl , then we put that interv into our interv search tree .
so in thi case we put on zero and then we put on on and then we put on two .
and , and that will give us now three rectangl on our sweep line .
and so now , the question is when we hit a , a new rectangl , we want to do an interv search to , if we're at the left to check which on intersect and the interv search tree algorithm is go to tell us which intersect there ar right awai .
when we reach the right then we remov interv and so forth .
but with the basic interv search tree algorithm and the sweep line process that we've talk about , you can get the orthogon , orthogon rectangl intersect search problem solv in time proport to analog n log n r log n , where r is the number of intersect .
and typic , in design rule check , you wouldn't expect too mani intersect .
so again , just as with , line intersect search , us a prioriti queue or a sort is onli n log n for process the x coordin .
and becaus the interv search tree take log n for everi oper , the insert and delet interv is n log n total and the search is n log n r log n .
so , the bottom line is that the sweep line algorithm take thi rectangl intersect problem and reduc it to 1d interv search and we have an effici algorithm for that problem and that enabl us to solv the problem in linear rhythmic time instead of quadrat time .
and that definit enabl new progress in technolog and it's a fine exampl of the import of algorithm technolog .
so here's our summari of applic of binari search tree for geometr problem .
we start with on dimension rang search and just us regular binari search tree to comput rank to get the answer .
but that as the basi , we're abl to solv the two dimension line segment intersect search us the sweep line algorithm .
then we look at rang search and other oper us kd tree .
again , modif of binari search tree .
and then the interv search tree to solv the on dimension n over search problem and then how that correspond to the basic algorithm that you get to if you us the sweep line algorithm to solv rectangl intersect .
mani of these problem ar the basi for geometr process of huge amount of data that we see all over the web .
and our basic search tree mental and api , and binari search tree data structur give us effici solut to these import practic problem .
welcom back .
todai we're go take a look at hash , which is anoth approach to implement symbol tabl that can also be veri effect in practic applic .
here's our summari where we left of with red black bst , where we can get guarante logarithm perform for broad rang of symbol tabl oper .
and the question is , can we do better than that .
is logarithm perform the best we can do .
and the answer is that actual we can but it's a differ wai of access the data .
and also doesn't support order oper .
but there's plenti of applic where the extra speed for search and insert that we can get thi wai is worthwhil .
the basic plan is to think of the symbol tabl , as realli try to reduc the problem to be like an arrai .
and what we do is us the function known as a hash function , that take the kei a symbol tabl kei and reduc it to an integ and arrai index .
now we us that arrai index to store the kei in the valu in an arrai , mayb the valu in a parallel arrai .
now , there ar a lot of issu in do thi .
first thing is we need to be abl to comput the hash function that is easi for some type of data , but it can get complic for more complic type of data .
then the other thing is that instead of do compar we're go to be do equal test .
so we have to be sure we've got the method that we want for check whether two kei ar equal .
all we're go to do is look in to the tabl and try to see if the kei that's there is equal to the kei we're look for .
and then is the problem of collis resolut where it's , sinc there ar so mani possibl valu for typic data type , your go to get the situat where two valu hash to the same arrai index .
and we need a collis resolut strategi to try to figur out what to do in that case .
and these thing ar not difficult , but thei ar all worth articul as separ issu that we have to deal with in order to get an effect symbol tabl implement .
hash realli at it core is a classic space time tradeoff .
if we had no limit on space at all , then we could have a veri huge arrai with space for everi possibl kei and just us the kei itself as an index .
if our kei ar <num> bit integ kei and we've got a tabl of size two <num> , then we're just fine .
if there were no time limit at all , then i would just hash everyth to the same place and then do sequenti search .
but sequenti search can be slow if we have lot of kei .
so what hash is kind of in the real world where we're try to trade off thi idea that we don't have unlimit space and we also don't have unlimit time .
so we ar try to find someth in between .
so we'll look at hash function , separ chain .
and then two collis resolut method , call separ chain and linear probe .
now look at the implement of hash function .
so idealist what i'd like is to be abl to take ani kei and uniformli scrambl it to produc a tabl index .
we have two requir .
now on is that , we have to be abl to comput the thing effici in a reason amount of time .
and the other is that it should be the case that everi tabl index is equal like for each kei .
now mathematician and comput scientist have research thi problem in , a lot of detail and it quiet a bit known about it , but in practic , thi is someth that's still , we have to worri about , somewhat .
so for exampl , let suppos that our kei ar phone number .
probabl a bad idea if you us the first three digit of the phone number as a hash function becaus so mani phone number'ill have the same area code .
it's not equal like that each phone number ha the same , same first three digit .
you have a better chanc us the last three digit .
but actual , in most case , you want to find a wai to us all the data .
anoth exampl , social secur number .
again , it's not to good to us the first three digit becaus , their associ with some geograph region and it's better to try and us the last three digit .
and the real practic challeng with hash is that with develop hash function is , , that everi type of kei need a hash function and you need a differ approach for everi kei type .
now , for standard kei like integ , and string , and , doubl , and so forth .
the , we can count on the implement , design and implement of java to implement good hash function .
but , if we're go to be implement symbol with our own type of data .
we're go to have to worri about these thing in order to get a hash function that's effect that lead to an effect symbol tabl implement .
so hash is , wide us for , system program and applic , so , some convent for hash ar built into java .
in particular , all java class inherit a method call hash code , which is , return a <num> bit int valu .
and it's a requir that if , x and t y ar equal , then their hash code should be equal .
so , that's , someth that is a convent that's built into java and that enabl the hash code to be us for hash .
also , of cours , if thei're not equal then you'd like it , like it to be that their hash code ar not equal but you can't alwai get that .
now the default implement for hash is the , memori address , of the object .
for hash an object is the memori address of an object .
so that , kind of , meet these two requir for java .
the on that it doesn't , mayb , meet is the idea that everi tabl posit should be equal like .
so , so usual we'll do some more work , to try to , make that on happen .
as far as the algorithm go , as far as the rule go , you could alwai return seventeen that's legal .
it doesn't have thi , highli desir attribut .
but everyth would compil .
so you have to be a littl care that somebodi isn't in there do that .
and again for import .
kei type that lot of peopl ar go to us .
some care ha gone into the design of hash function and the built in implement .
so java ha custom implement for the standard data type that peopl would us for simpl tabl kei .
and that's the sweet spot for hash where some expert ha done implement of the hash code .
and also , your applic doe not need order .
but for us to find type , you're on your own .
and we'll talk a littl bit about how to implement hash code .
so here is the java librari implement for a few standard type .
and thei ar what thei ar , and what we'll do is , with knowledg that that's what the hash code is we'll do some extra work to try to get thi extra properti that everi tabl posit should seem to be equal like .
so if it's an integ , the hash code suppos to be <num> bit , the integ suppos to be <num> bit , so thei just return the valu .
if it's a boolean , thei pick out a coupl of particular valu that thei return so hash a boolean type , there's onli two differ valu so well it's hard to think about what you realli might want there .
for doubl valu thi is the code thei convert to <num> bit and x or the most signific <num> bit with the least signific <num> bit .
thi illustr someth that you want to do if you have a lot of bit , you want to try and involv all the bit somehow in the hash function .
and for string it kind of creat the string as a , a huge number and then realli comput the valu of that number a mod <num> it us an arithmat a wai of evalu a polynomi or a number , a so call horner's method , where for each digit , you just multipli .
so it treat it as a base <num> number and to get , to comput that whole number you multipli <num> time where you have so far and add the next digit .
and that's call horner's rule and if you're familiar with it , fine .
if you're not you can look at thi littl exampl and decid what it is .
and again it involv all the charact of the string , in complet the , hash function .
so .
and actual , sinc string ar immut , what java doe is keep the hash valu in an instanc variabl so it onli get comput onc .
and that is go to be veri effect for perform in lot of applic .
so onc it comput the hashcod , it store as an instanc variabl .
and the next time you ask for the hascod for that string , it will just provid it .
and that work becaus string ar immut .
so how about implement a hash code for our own type of data .
and so , we might have , our transact type might have a coupl of instanc variabl , a string , a date , and a doubl .
and we need to comput a hash code , so return a <num> bit valu .
and again , we want to try to make us of all the piec of data that we have .
and we also want to make us of the hash code implement for the type of data that we're us .
so , on thing , to do is , start out with some , small prime number , and thi kind of mimic , horner's method , to , just add in more data as we get it .
so we pick some other small prime number and for each field we multipli by <num> and then add the hash code for that field .
so , if it's a refer type just us the hash code , so who wa a string ?
so string ha a hash code method , so we add that in and date and when's a date , so we add that hash code , multipli it by <num> and add that hash code in .
try to take all the bit and scrambl all the bit and us'em and for primit type , take the wrapper type and us the hash code .
so that's a , a simpl exampl of implement a hash code for our own type of data that might includ sever differ type of instant variabl .
so that's the standard recip .
us the <num> x plu y rule to combin all the field .
if it's a primit type , us the wrapper hash code .
if the field is null , return zero .
and if it's a refer type , us that hash code and appli it recurs .
and if you have an arrai , you have to appli it to each entri .
or actual java implement that in the arrai , in it arrai librari .
so thi recip work pretti well in practic and it's us in sever , in java's librari .
now in theori it's possibl to do someth that ha the properti that , that all posit ar equal like .
it's call univers hash function .
these thing exist , but thei're not so wide appli in practic .
so the basic rule is if you're comput your own , try to us the whole kei , but consult an expert if you're see some perform problem or you realli want to be certain in some perform critic situat .
now what we get back from the hash code is a int valu that's between two <num> and two <num> on .
now , what we need is , if we have a tabl of size m , an arrai of size m that we're go to us to store the kei , we need an int valu between zero and m on .
and the valu of m is mayb a power of two or sometim we pick , pick a prime becaus of the wai that we normal would get the big hash code valu down to be a number between zero and m on is just to do mod m .
and if mod , if m is a prime then , then from math , modular arithmet , we know that we ar us all the bit in the number in that point too .
now , sinc the hash code can be neg thi doesn't quit work the wai thi arithmet is implement in java cuz it's on in a billion time .
you realli have to take the absolut valu well sorri you have to take the absolut valu i would becaus other wise it'd be neg and you cannot have a neg , you want it to be between zero and on .
but even if you take the absolut valu there's go to have two <num> is possibl .
so you have to just take the <num> bit .
you get the hash code out make it posit and then mod m as the wai to go .
the math doesn't quit work out right so anywai , that code down at the bottom is you can us that as a templat for what you might want to do .
and that's what we do in order to get the hash code to be a number between zero and m minu on .
and if m is prime , it give us some comfort that we have some possibl of each tabl posit appear with equal likelihood .
so that's our assumpt .
that each kei is equal like to hash to an integ between zero and m <num> .
and thi assumpt again , it's , with work it's possibl to come close to thi .
lot of research have done good work to show thi .
we'll assum that as a start point .
and that allow us to model the situat with the so call bin and ball model that directli relat the studi of hash function to classic probabl theori .
so we've got the n bin , that's our that's our correspond to our hash tabl and we get m ball and with some number of ball , howev mani kei we have and we throw'em uniformli , at random , into m bin .
and , with .
these thing ar studi in classic combinator analysi .
for exampl , there's the birthdai problem .
which , how mani ball do you throw befor you find two hit the same bin ?
when do you get the first collis ?
and the answer to that is , it's about squar root of pi  m over two .
when doe all the bin fill up ?
that's call the coupon collector problem .
after about m , natur log m toss , everi bin ha at least on ball .
those ar just exampl of classic result from commonatori analysi .
it help us understand what happen when we do thi , which is what we're do with hash .
and we'll look at more advanc version of these problem when we wanna studi hash .
and in particular it's known that after you've thrown n ball into the n bin , then the most load bin ha about log m over log , log n ball .
so that's go to help us get a handl on the perform of hash algorithm when we get to the implement .
so thi is just an exampl show all the word in a tale of two citi us the modular hash function for string like the on that java us .
and their pretti uniformli distribut .
and that's the summari for hash function .
next we'll look at separ chain , a collis red solut strategi that make us of elementari link list .
so , what ar we suppos to do when two differ kei hash to the same index ?
the birthdai problem tell us that we're go to have collis .
you need a quadrat amount of memori to avoid collis .
in the lower balanc , a coupon collector analysi tell us that the collis ar go to be evenli distribut , distribut among the tabl , around the tabl .
so , what we want to do is have an easi wai to deal with collis .
and so the first wai we'll look at is call separ chain and it's a veri diagon idea back1953 , and the idea is just build a link list for each of the tabl posit .
so , we'll have a tabl that's smaller than the number of kei that we have , the hash function will map each kei to some integ .
so in thi case , we have a tabl of size five .
so the hash function will map ani kei .
in thi case , we us singl letter kei .
it'll map ani kei to an integ between zero and four and then to do an insert we'll just keep a link list at the tabl posit correspond to the hash valu .
so s hash is to posit two , it'll be on the link list that is first link is at posit two .
and e goe to zero , and a goe to zero .
and for search , we're go to have to go to , if we're go to look at is c in thi tabl sai , we're go to find the hash valu for c and we'll look down the list to see if we can find c .
so we have to look through the whole list for search but you onli have to look through on list out of all the list .
essenti if you have m entri in the hash tabl and m kei the link of list you're go to look at is about n over m cuz thei're evenli distribut .
so that's a straightforward and simpl scheme for implement symbol tabl with hash .
now , we could us a interv bag or some data structur like that and hide the link list structur underneath and that's a perfectli fine wai to proce in modern program .
thi implement directli implement the link list .
now , for a practic situat we pick some kind of , some valu of m .
you could make it so that the hash tabl itself grow onc it get realli huge and such hybrid method ar easi to implement .
so we won't talk to much about that .
we need to just in term of implement detail , our kei and valu have to be object .
becaus we can't have an arrai of gener .
so , sinc we're make arrai of node , a node would have gener if we us to kei in valu .
so we have to make them object then when we get thing off , we're go to have cast .
so thi is the get procedur .
so to look for a kei in the hash tabl we comput the hash valu .
in our hash function is pull out the system hash code , make it posit by end off the sign bit and then mark with m to get a number of , zero and on .
so we pick that number , i and then we just go to that list and thi is the standard code for divers a link list start at the first node as long as it is not null go x x dot x .
and if you find a kei that's equal to the kei you're look for , return the valu and we have to cast it to valu becaus of the gener recreat problem in java , otherwis return null .
so that's not much code , and it's trivial code at that for do an effici symbol tabl search us hash .
and insert is not much more difficult if you do the same thing and if you find a node where kei equal to kei on the link list , reset the valu and return .
otherwis , you make a new node and put it at the begin of the link list with the standard code .
now , replac stfi with a new node that link to the old stfi .
so again , veri littl code to implement search and insert us hashin g and that's why it's so popular .
and what about the analysi ?
well , again thi the standard probabilist analysi of the ball and bin problem tell us a lot of inform of what goe on .
and again , if the uniform hash assumpt hold the probabl that the number of kei within a list is within a constant factor of n over m is extrem close to on .
so , it mean that we've divid the search cost which would be n if we have a sequenti search by a factor of m .
and , and in mani applic even set m <num> or <num> , <num> is go to be veri effect .
and that's why so mani system program refus that .
so , number of pro for search and insert's proport to n over m .
now typic , what we'd what a programm would do is try to figur on make m about equal to the number of kei divid by five sai .
so , you can't make m too larg , you have too much space and you'll have empti chain or short chain .
and if you make m too small then thei're too long , you have to search through them all .
so let's sai , n over five and then you get constant time search and not much extra space .
you have extra space for the link to implement the link list but the rest of the tabl is not much extra space .
and those ar typic paramet .
if you want a full servic symbol tabl which is go to , go to grow from small to huge and then back down to small again then you'd want to us arrai re size to make sure that m is alwai within a constant factor of n but we will leav that detail out for now .
so that bring us to thi summari where red black tree , we were happi with a log base two of n for search and insert with separ chain , you can realli get it down to a constant number of oper for search and insert .
so hash's go to be prefer for short kei where the hash function's easi to comput .
and where we don't need order iter or ani of the order symbol tabl oper becaus it ha realli fast access to the symbol tabl .
that's our first collis resolut method , hash with separ chain .
anoth popular closur resolut method is known as linear probe .
in thi you know mani differ version of hash that ar base on thi idea .
with linear probe is call open address and is also around the same time in the <num>'s the idea is just us an arrai .
instead of us space for the length in a length list .
i us that same space , and just , alloc an arrai .
in thi case , the size of the arrai is go to have to be bigger than the number of kei that we expect .
and we us the empti slot in the arrai .
to .
essenti termin the length of the list that we have to search through when we're do a insert .
so let's look at a demo of how it look .
so to hash again we do the same thing , we just map the kei to a index .
but , in linear probe , to insert what we do is when we put it in posit i if that's free , if not we just look at i plu on , and i plu two , and wrap around to the begin if we reach the end .
now that's also simpl to implement and it work well as long the size of the arrai is , significantli bigger than the number of kei .
let's look at , well it's a demo .
so we start with an empti tabl , insert s , it's hash valu is six , six is empti so we put it there .
now we look at e , hash of e is ten , we look at ten , it's empti so we put e there .
so at the begin we're go to be fine .
a is four , empti , put it there .
r is fourteen , empti , put it there .
so we just essenti , us the hash funtion as an arrai index .
c is five , that's empti and we put it there .
so h now , the hash valu of h is four .
so now we look at four , and that's occupi , so we can't put the h there .
and then linear probe sai , just look at the next posit , look at five .
that's still not empti .
so we look at six .
and we keep go till we find an empti place , and then we put h there .
now when we search , we're go to have to do the same thing .
we'r e go to have to look at all those posit to look at h .
the .
group of four kei , continu kei in a tabl space there is call a cluster and clearli we want to keep those cluster small .
and we do that by jut by not put too mani kei in to the tabl .
so x hash to fifteen , that's empti so we put it there , m hash to on , that's empti and we put it there .
p hash to fourteen , <num>'s occupi , <num>'s also occupi , now we run off the end of the tabl , and look at zero , and that's empti so we put it there .
l hash to six .
six is occupi .
we look at seven , seven is occupi .
we look at eight , and we put it there .
and , so that's an exampl of insert , kei into a hash tabl .
and now , for a search , we just do the same thing .
we , us the hash function .
to search for e , e's hash valu is ten so we look in ten and there it is .
so that's a search hit .
if we're go to search for sai l l's hatch valu is six so it's not there .
so in order to look at everi place in the tabl where l could be , we have to keep look til we found an empti tabl posit , or we find l itself .
so now we look at seven l not there , we look at eight l is there , that's a search hit .
if we have a valu that's not in the tabl like k , well hash and is in posit five , no , six no , seven no , eight no and we find an empti posit at that point we can conclud that k is not in the tabl .
becaus if k were in the tabl it would be somewher between it's hash point five and that empti posit nine .
that's a search miss , and we return all .
so that's a short demo of linear probe hash .
so here's a summari of linear probe , hash .
to .
to get start we map a kei to a integ between zero and m <num> where m is the side of our arrai where we ar store the kei .
to insert we put the kei valu pair .
us parallel arrai and the valu arrai with the same index .
we put the entri at the tabl index a for three .
if not try i <num> i <num> until get to a empti posit .
and for search you do the same thing you hash to the tabl posit and you look there into the right .
to find the kei and you stop when you find an empti tabl posit .
find the kei or find an empti tabl posit .
now , it's essenti that the arrai size is greater than the number of kei valu pair n .
and for linear probe hash , realli , the implement need to includ arrai resiz , whenev the hash tabl get too full .
here's the implement .
and it's , quit straightforward , given the demo that we talk about .
you us the same hash function .
and we us parallel arrai for the valu in the kei .
and we have to us ugli cast , 'caus we can't have a race of gener .
then let's do the search .
so .
we just have a for loop start at hash of kei and go until we get to a posit that's null .
as long as it's not null , we stai in the loop and increment i mod m .
so that's when i get to the end it get to the end , it's in the posit m minu on and it goe . . .
in the next increment goe back to zero at the left end of the tabl and we just test for all the non null kei .
if it's equal , if it is , go ahead and return the associ valu and if you get to an empti posit , then return null .
and the implement of put is similar .
find a , a posit , if it's , that's equal , and then , reset the kei , in the valu .
if the kei's there , it just reset the valu .
if thei kei's not there , it put a new entri in .
so again , that's , fairli littl code , to implement , a fast symbol tabl and insert , search and insert .
but it's onli go to be fast , if the , tabl size is set appropri .
in ancient time , memori wa , at quit a premium and so peopl were veri concern in m m make sure that the hash tabl never , got too empti .
rememb in the first comput , each bit wa a physic thing , a magnet core that somebodi had to string a wire through , so .
the bit were realli expens , and peopl want to make sure , that thei were make best us of the memori .
and just leav empti posit around , in a hash tabl , or us link in a link list , did not seem like an appropri us of space .
and , so there wa quit a bit of effort , devot to figur it out , how full we could get the hash tabl , in linear probe .
and how close it could get to full without sacrif perform .
and on wai to think about what goe on is to just watch what happen when a hash tabl fill up .
so here we just as , as it goe up we're show each kei get insert in the number of probe of the tabl that ar need for the insert ar j hash to the same posit that a ; you had to look for a while , and the on thing to notic is as the tabl get full , is that first of all .
you have , these cluster or these chain build .
and so , what's clear about that is that , it mean that , the new hash is like to hash into a big cluster .
and not onli that onc you have a big cluster and you hash into the middl of it you've got a good chanc that , that cluster go to get longer , or wors .
that's it's even go to merg with anoth big cluster .
and so , that's the situat as the tabl fill up .
you get long cluster and thei're like to get longer .
and the math bare that out .
now thi wa studi in detail by knauf , don knauf , in the <num>'s and actual thi problem , knauf sai , wa the origin of the origin of analysi of algorithm .
mathematician were try hard to understand thi problem and were readi to give up and he realiz you could us classic ball and bin type probabilist analysi .
not an easi analysi , but we actual could make precis accur statement about the perform of thi algorithm .
and those statement can be born out in practic , becaus the hash function approxim random , the math assum random and the formula predict what actual happen in practic .
no wai can you formul the problem as so call park problem .
so , what happen is that you ar on a on wai street and you ar look for a park place and , it's , the idea's you start look for a park place at particular time and sai okai , now i need a park place , and what you're do is linear probe hash .
if the current space is taken , you try the next space and the on after and so forth .
and the question is .
if everi car .
start look for a place at a random time .
that .
then that model the hash function , then how far do thei have to go to look for a place ?
that's canoot's park problem .
and he wa abl to show , and we'll talk just a littl bit about thi , that if , there's , onli half of the park space ar occupi , then , on averag , half the peopl find , find it after on place and the other half have to look on extra .
so that's the kind of perform that we want .
but as it get full .
the displac get up to squar root , of pi  m over eight .
which is obvious much higher than we want .
we don't want our search to take that long .
and that actual , the analysi , is amaz function that goe back to famou roman nuygen and other classic result from our commentori analysi .
what canut's theorem sai is that under the uniform hash assumpt , the number of probe in the linear hash tabl size m , that is alpha percent full , so the number of kei is a fraction of m , is for a search miss half on plu on over alpha , and a search miss on plu on over on minu alpha squar .
on myse alpha is for the hit , on myse alpha for the squar for the insert .
now as alpha get close to on , you can see these thing ar go to grow , and particularli the search miss is grow to grow quit , quit a bit .
if it's <num> <num>'s full on over on minu alpha squar is <num> on over <num> , so it mean it's go to be <num> p robe for a search miss if it's <num> <num>'s full , and that's independ of n and m , wherea if it's half full then we get the nice .
number of onli <num> hous for a hit , and onli <num> hous for a miss .
and , again these formula ar nice approxim formula , but knuth , onc he figur thi out , in <num> , tell stori , that time , he decid to write hi famou seri of book on algorithm .
now there's four volum out and more plan , and thi is where , all comput scientist go .
for detail inform on a perform , eval grievanc .
so , in , in summari .
you can't have m too larg , what we want to us nowadai is arrai resiz to make sure that the arrai is alwai about half time , half full .
and if we can keep the arrai about half full then we get constant time perform for search hit and search miss .
and linear probe is veri attract in thi case .
there's other thing that we can do algorithm to bring down the search time a littl bit .
like us anoth hatch function rather than look at the next entri .
us anoth hatch function to determin the stride that we're go to us .
and that bring it down somewhat and allow us to keep the tabl more full .
but the bottom line is that now we have two method that under the uniform hash assumpt can give us constant time , search , search it insert and delet .
for symbol tabl implement where we don't need order .
and we've got a reason hash function .
so , that's a summari of linear probe or second hash , collis avoid strategi .
so let's just look at a littl bit of the context of hash in practic applic .
as i mention , it's veri wide us .
so here's an , here's an exampl right from java .
the first .
implement of java <num> .
the design found that the cost of comput the hash function for string seem to be excess , particularli for long string .
and that wa on of the main us of hash , wa just to be abl to do search with string kei .
and so what thei decid in the first implement wa let's just look at everi eighth or ninth charact , and that wai , we don't have to spend a lot of time comput the hash function .
so thei had a hash function pretti much like the on that we us .
except that it comput a skip that would mean that , that onli look at about everi eight kei and thei wouldn't have to do quit so much work perform the hash function .
and that's diffid on thing to consid when us hash is that the cost of comput the hash function for a complic kei might exce the cost of search and us a simpler structur like a binari search tree .
and anywai for java <num> what happen wa that there wa a huge potentail for realli bad collis pattern on typic data .
so here's the exampl of typic data , which is a url .
all of these kei , which ar total differ , would wind up have the same collis .
and so client program and system program on the java system were have terribl perform on their symbol tabl becaus of the shortcut in hash .
so thi well illustr that you need to us all of the data in the hash function and sometim we do a closer analysi .
the cost of comput the hash function can mean that someth like red black tree will even outperform hash even for just search and insert .
so there is anoth thing about the uniform hash assumpt is that it is an assumpt and if you ar write code where we have to have guarante perform like when your aircraft is land or you ar control a nuclear reactor or somebodi's pa cemak .
that , if that assumpt doesn't hold and you get bad perform you're go to have disastr consequ .
so that's anoth reason to think about mayb pai a littl extra and us to guarante that you get with red black search tree .
instead of hash .
and there's anoth surpris situat that happen in todai's world .
for exampl java publish it hash function .
and so if you're try to provid a servic over the web .
an adversari can learn your hash function and just send you data that caus huge perform problem by just make all that data hash to on particular item .
and that's definit someth to worri about .
and , and in the real world you can nowadai find on the web particular sequenc of kei that will caus particular servic to crash .
and again , that's a littl harder to do with someth like a red black tree where we have perform guarante .
when you make an assumpt you better be sure and you're depend on that assumpt , you better be sure that it hold somehow .
thi is differ than for exampl for quick sort when we , our assumpt wa we're go to creat random and we ar go to depend on that random .
in thi care we're kind of hope for random and mayb that doesn't realli alwai hold .
so that's certainli someth to be awar of when us hash in practic .
so here's just simpl exampl on hash in java .
so what we can do is it's pretti easi to find a famili of string that have the same hash code for exampl with just a littl fool around now dai you can just look it up on the web , you can see that these two charact kei , both have the same hash code becaus when you just do the math in a base <num> hash code it'll tell you that answer .
well what that mean is that actual , just like work in binari you got , you can combin those thing .
in all possibl wai , and you can get two to the n string , for ani n of length to n that all hash to the same valu .
and somebodi's implement a servic in java that it us a simp le tabl that take string kei , you can caus that to crash in thi wai .
littl bit scari for some system design .
at least reason for paus in us hash .
now , hash also ha a extrem import applic in todai's internet commerc .
and so the , it's the concept of so call on wai hash function which mean that we , we , us it for secur to try to be , have some secur fingerprint for us on the web .
and there's been a lot research done to develop function that take kei as input , and then produc valu that look random .
in such a wai that , it's hard for someon els to find anoth kei that collid with that .
thi technolog is , is us for store password and digit fingerprint and thing .
but it's too expens for us , in a symbol tabl .
so the bottom line is separ chain versu linear probin collis resolut messag method .
now there's a number of consider to take into account .
separ chain is realli easi to implement both insert and delet it perform , it degrad , it doe so gracefulli and the cluster is , is mayb less of a problem if you have a bad hash function .
linear probe tend to make better us of space .
and also it'll perform better for huge tabl wherea cach is involv .
and if , in the classic algorithm or comput scienc problem for peopl to think about is what do we do to delet in these two situat and exactli how do we resiz .
those ar all at the level of exercis in the context of the kind of algorithm that we've seen .
and as i mention , there's been mani , mani improv version of hash that have been studi .
i mention the two probe , or doubl hash version .
anoth wai to us two hash function is just to hash the two posit and put the kei in the shorter of the two chain .
in , in that case , then the expect length of the longest chain will be lg , lg n which is quit an improv .
you get constant time expect and lg , lg n worst case .
doubl hash is the variant of layer probe where you just skip a variabl amount , not on each time .
and that pretti much wipe out cluster but it , it is more difficult to implement delet for that on .
in a new method call , rel new method call cuckoo hash .
it's anoth variant of linear probe where we hash a kei to two posit and insert the kei in either on .
if occupi you , you reinsert the displac kei into it altern .
it wa in on , each on can go to two .
and that on actual give constant worst case time for search .
that's anoth variat on the team .
and all of these thing allow us to make better us of memori , allow the tabl to becom nearli full .
it would have been veri excit .
thing to be research in the <num>'s who care so much about memori and nowadai a littl extra memori is not someth that peopl care about so much and most peopl just go with the easi algorithm except for realli perform critic applic .
what about hash tabl versu balanc search tree ?
well hash tabl ar realli simpl to code usual if you don't have to do the hash function .
and if you don't have order in the kei at all then you need the compar to , to implement balanc search tree .
so you have to us hash if you don't have the comparison .
and it'll probabl be faster for simpl kei to us hash .
it's a few arithmet oper to do the hash versu lg n and compar for the balanc tree .
and there's some better system support in java for string that cach hash code mean that you don't even have to comput the hash if your , your simpl tabl for string is in an inner loop .
on the other hand , balanc search tree have a much stronger perform guarante .
it , you don't have to assum anyth .
it's go to be less than lg n and compar and it's got support for all those order st oper , and compar to and is pretti easi and natur function to implement .
so it's more flexibl and more broadli us .
and actual the java system and other system includ both so that programm can make us of either on in diff erent situat .
that's our context for hash algorithm .
welcom back .
todai we ar go to look at some symbol tabl applic , give you some idea of how symbol tabl might be us , by client program for practic problem .
first when we look at , seem even simpler than the regular symbol tabl , and that's about set .
so , a mathemat set is just a collect of distinct kei .
and so , there ar plenti of applic where we want to just be abl to implement , thi realli simpl api .
i want to be abl to creat an empti set , we've got method to add a kei to the set , and to check whether a given kei is in the set or not .
to remov a kei , and mayb return the number of kei in the set , and also have an iter to iter through kei in the set .
thi is simpler than symbol tabl becaus it's got no associ valu .
so , it's a veri simpl api but of cours , we're go to be abl to do these oper effici , how we'd we go ahead and implement that .
well , if you think about it for just a minut , you see that what you need to do is just remov all refer to valu from ani of the symbol tabl implement that we'd look at .
the implement is easi .
take on of our symbol tabl implement and get rid of the code that refer to valu .
okai , so let's look at a coupl of applic where thi set api might be us in client program .
on thing that is veri common is the idea of an except filter .
so the wai we'll set that up is to think about have a list of file a list of word in a file that ar except in some wai .
in thi case , we'll have the word , the file list . text that ha these four word in it wa , it , the , and of .
so thi two , complimentari wai to look at thi .
on is so call white list where we want to take the word in that file and , and then we have some other much bigger file .
and what we want to do is print out all the occurr of our except word in our given file .
those ar the on that we care about , that we want to get through .
so in thi case , tinytal . txt the first coupl of word from a tale of two citi . and these word appear often , it wa the of , it wa the of . anoth , a complementari approach is to think of these word as word that we don't want to ever see .
thei're blacklist , and we want to take them out of our sourc file .
so a blacklist client would print out all the word in our sourc file , tinytal . txt except wa , it , be , and of .
in thi case , best time , worst time , and so forth .
so that's the except filter , and that's us in lot of applic such as the on list here .
for exampl , you might have a spellcheck where you want to identifi misspel word .
so , then your kei would be a word or a string .
and in your except list would be word that ar in the dictionari .
and you'd want to print out all the word that ar not in the dictionari .
that's an exampl of a , an except filter .
or in a browser you might want to mark your visit page or block site and so forth .
or like the on at the bottom credit card .
mayb , you run a credit card compani and you want to check for stolen card then your kei would be number .
i .
and in your list , might be kind of short , which would be the stolen card that you know about , and you'd want to run a , a white list filter for those card and print out in your long list of transact which ever transact have that stolen card , so , that's just a coupl of exampl of except filter .
what's the implement of an except filter ?
here's a simpl on us the said api that we just articul .
so , we start by creat an empti set of string , and again sinc we don't have associ valu , we just have the on gener for string , and then creat a new input stream from , from the first argument so that's the name of the file that contain the except word and so thi just read the string while the input string is not empti and then add the m to the set .
so that now , we have our set of except word .
and now , from standard input we read word , as long as our set contain the word , we print it out .
and if doesn't contain it , we don't print it out .
so that's an exampl of a white list filter .
and to implement black list we just thi call to contain , we just chang that to a , a not .
if it's not in the except list , then we print it out .
so that's a simpl exampl of a filter us set .
now , let's look at a dictionari client , anoth veri us and common applic of symbol tabl .
so , in thi case , we ar go to write a client call lookup csv that is go to take three argument .
the first will be a file name , a so call common separ valu file and the next two argument ar integ which will tell us what to treat as kei and valu in the file .
in thi exampl or csv file relat url to ip address .
so , each line ha a url and ip address and ar separ by comma .
and in gener , a csv file might have mani field separ by comma , comma .
so , we number them zero , on , and so forth start from the left .
so , what we ar go to do with thi client is specifi with integ which field is the kei , and which is the valu .
so , if we call thi client with second argument zero and third argument on , that mean we want to us the url field zero on the csv file as the kei , no on us the ip address that's field on in the csv as the valu , you want to associ kei with valu .
so the client will build a symbol tabl that make us associ for everi line in the file and thi could be huge file .
and then , if we want to look up the ip address associ with a given url we can just type in url and the client will return the ip address , it'll do the look up .
so , adob . com ha got thi ip address that's shown if thi line here in the tabl , and so forth .
princeton . edu ha thi ip and ebai . edu is not in the file .
now , on the other hand , we could , from thi same file , we could build a symbol tabl where we treat the ip address as the , as the kei and the url as the valu .
so , in that case , it'll build a symbol tabl with ip address as kei and we can type in an ip address and get the associ url .
so , with on client we can handl lookup of all kind in csv file .
for exampl , here's anoth csv file that from biologi that deal with , amino acid and codon and name .
so , in thi case , the first field is three letter from the dna sequenc which , repres a codon .
and certain codon have name , that's the amino acid .
so , tcc is call serin , and so forth .
and that's an associ that's well known to biologist and then you can us thi lookup csv client to quickli get the name associ with ani given codon .
that's just anoth simpl exampl .
thi is a veri gener tool .
ani csv file , you can pick ani field as the kei , ani other field as the valu .
so here's still anoth exampl where we might us for a class list , which ha the person's year of graduat , last name , first name precept name and login name .
and so in the first call over here , we might us the login name as the kei and the first name as the valu .
so , we type in somebodi's login name we get their first name .
and again , with the same client login is kei and get the section as a valu .
so , all kind of inform process that we might need to do for larg amount of data , repres in comma , comma separ valu file thi on client which is base on a symbol tabl will provid us function .
and here's the implement there's veri littl to it given the symbol tabl api that we've articul and the implement that we have .
so what do we do to get lookup csv implement ?
well , first thing is to set up the input stream from the first argument , so that's our input file .
and then , get the number of the field , so the kei and the valu .
and now build a simpl tabl that associ string with string .
then there there's a while loop where we just read a new line in that read line , read line and then split accord to comma into token in an arrai .
and then , the index in the arrai is go to build the field that we're go to us .
so , the kei is the string in the kei field entri of the arrai , and the valu is the string in the valu field entri in the arrai , and we simpl y put that into symbol tabl .
so , thi valu loop just build the symbol tabl from the file .
then from standard input we take queri , just read a string , check if the symbol tabl contain the string .
it , it doesn't , print not found .
and if it doe , print the valu associ with the kei .
so , a veri small amount of code base on a symbol tabl implement that give us the dictionari function .
here's anoth simpl client program for symbol tabl relat to index .
again , anoth common function that's easili handl by symbol tabl .
there's all kind of case where we just have a lot of inform , mayb on our pc or all over the web , and we want to creat an index that allow us to specifi .
a search kei and get all the associ inform .
and you've , you've us program like thi on , on your comput mani instanc , most like .
so , more gener , here's the goal .
so , we're go to list of file that ar specifi .
and then , and mayb it's all file on the comput , or mayb it's specifi in , in some other wai .
and what we want to do is creat an index , so that we can effici find all the file that contain a given queri .
string .
so , in thi small exampl .
so , our client is go to call file index .
and in thi small exampl sai we ar go to have five text file .
and these ar just piec of literatur .
and so what we want to do is , build and index from that set of text file .
and then given a kei , a string kei , we want it to print out the file that might contain that kei .
so , for exampl , the word freedom appear in the magna ca , carta and in mobi dick and a tale of two citi in all three of them but not in tom sawyer and not in aesop's fabl .
the word whale is onli in , mobi dick .
the word lamb appear both in tom sawyer and aesop's fabl , and so forth .
so we're look for a piec of inform somewher in a comput , and it'll give us the name of the file that contain that inform .
so , with the , more complex user interfac , thi is , veri much what the spotlight or find function on your comput is do .
and a programm might us the same program , to find place where certain , program term ar us in a bunch of program .
so , normal we have a bunch of dot java file when we're work on an applic .
like these ar all the on associ with thi , lectur , so we might build an index from that set of file , and then we might wonder well where do we us the import statement .
so we just search for import and it'll tell us , look in those three file .
or , did we us compar anywher here ?
in , thi index will tell us no .
so again , a veri gener capabl that's got lot and lot of applic and easi to implement with our symbol tabl api .
and the idea is , that what we're go to do is associ .
on kei with valu well the kei is the string we type what's the valu ?
well what we're go to us for valu is a set of file , the file that contain the queri string .
so just given that high level descript then the implimint is pretti direct .
here's the implement of file index us our symbol file implimint .
so now we're go to build a symbol tabl .
that associ string kei with set of file .
so thi creat a new symbol tabl associ string kei with set of file .
so first thing we do , as befor , is build the index .
so we're go to take , thi time we're go to take the list of file name from the command line .
and for each file we're go to creat an input stream .
we're go to read everi word in the file if the symbol contain doe not contain the word .
will creat a new set for that word and put that in the symbol tabl , and then , we simpli get the set associ with the kei and add the new word to that set , the new file name to that set .
so , thi on , for each word in the file .
it'll add that file name to the correspond set for that word .
that's build a symbol tabl associ kei with set of file .
and then process queri is the same as befor , as long as standard in is not empti we take a queri .
and then simpli print out the set of string associ with that word which is a list of file name .
so again , our symbol tabl api give a veri easi wai to implement thi file index function , which is veri wide us .
and similarli , mayb we want to build a , a book index , mayb for a real book , or mayb for an ebook .
or more gener , peopl want to often process , preprocess text to , mayb a huge amount of text , to support , so call , concord queri .
so what you want to do , is given a word , find all occurr of that word along with immedi context .
and context just mean a few word befor and a few word after .
so for exampl , in tail of two citi .
the word citi actual onli appear in thi on place and thi is context that it appear .
with the forward tongu of the two befor and that were blend in after .
the word majesti appear in three place , and there's , there's the context .
in well , thi is , the veri special case that you're veri familiar with .
in web search .
you type in a word , and then you get place that , where that word appear in context .
again , our symbol tabl api provid for an easi wai to implement thi .
thi is a , a .
concord client that that doe the job .
now what we want to do is read text , and we want to build an index for each word .
so thi is a a , a java construct for .
read all the string on an input stream , on standard input , and , split em by blank space and put em into arrai , so now all the word , ar , in the an arrai .
on standard input .
and then we're go to creat a new symbol tabl that associ string with set of integ .
and again the string is the kei and the set of integ ar go to be the place in the arrai where the given work appear .
so , we go through .
all the word , pick out our kei , s , and again , if , it's not there yet , we creat a new set associ with that s , and , then , afterward , we go ahead and .
get that set , and put the new index on that set .
and then that allow us to process queri , where we take a queri , and then get the set of indic associ with that queri .
and then we left out , left out the code where you print out the nine word that you want .
the four to the left and the four to the right .
again , quit us and familiar function and veri easi to implement with our simul tabl client .
as a final exampl of a symbol tabl client , we'll take a look at a mathemat applic where we want to implement spars vector and matric .
so , thi is a standard matrix vector multipl that you learn in math where we have a squar matrix and a column vector and we want to do a dot product of , of first row with the column vector to get the first entri in the result .
so , in thi case , thei're all zero , except for <num> . <num> <num> which is <num> . <num> .
and then similarli , dot product of thi with that column is <num> . <num> and so forth .
so standard implement of thi is quit easi .
we have a two dimension matrix on dimension column vector for the multiplicand and the result .
and then thei get initi in some wai , but the main comput is a pair of nest four loop for each row in the matrix we have to go through each entri in the column vector and comput a run sum of for that row in the matrix , that correspond expand entri with the entri in the column and them , keep the run sum and then that's the result that we put in the result column factor for everi valu of i .
and the kei thing about thi standard implement that it's two nest four loop that each run up to n .
so , that's n <num> or quadrat run time .
and that's fine in typic applic when the matrix is small , or when there's lot of entri in the matrix .
but the fact is that in mani practic applic , the matric ar what's call spars .
thei , most of the entri ar zero .
and so , symbol tabl provid us with a wai to provid a more effici implement of , of thi process when we have lot of zero entri .
so in a typic thing , sai , mayb the matrix dimens would be <num> , <num> , and mayb there would onli be ten non zero entri per row .
or , even nowadai you might have matric that ar , ar even bigger .
<num> , <num> by <num> , <num> if , if there wa , if it wa full , that would be a billi on or <num> million entri .
and so that's definit go to be costli eh , if you're do thi oper a , a lot .
and the idea is to cut down on that cost by take advantag of idea that there's a lot of zero .
so let's start by just look at vector .
so the standard represent that we us for vector is to simpli us a on dimension arrai .
we have constant time access to everi element , but the space is proport to n .
so , even if there's a lot of zero we , we still have to take the space to store them all .
instead , we're go to us a symbol tabl represent where our kei is the index and the valu is the entri .
and we just us that for everi non zero entri in the vector .
so , thi ha got the same amount of inform .
it sai that index on ha got <num> . <num> , index five also ha <num> . <num> , index fourteen ha <num> . <num> and so forth .
but the space is proport instead of to n , it's just proport to the number of non zero entri which again , in typic applic , mai be wai , wai less .
and so now , just we , we know we have a symbol tabl implement that ha effici iter .
and also access is not bad .
it's just that we're abl to do it with wai less space .
so , here's what the implement of a spars vector might look like .
so first thing is the represent is go to be a symbol tabl .
and in thi case , we might as well us a hash tabl becaus the order in which we process thing is not import .
uh huh , we just want to get at the , all the non zero entri .
so the constructor is go to creat in thi symbol tabl .
just a new symbol tabl that associ integ indic with doubl valu .
so , the put which is to store a valu associ with an index i , is just put into that hash tabl , associ kei i with valu x .
associ an integ with a doubl .
and get i'll return zero if the index kei is not in the symbol tabl .
we didn't , that's the whole poin t wa , we don't repres zero .
other , otherwis it return the valu associ with the index .
and the iter just return all the kei to iter .
and the most import thing is that if we want to do a dot product with a vector , sai , then the time that it take is onli proport to the number of non zero kei .
the zero kei ar go to be zero on the dot product so what we're go to do is take the item kei of the vector and multipli it by whatev valu we get for the non zero entri .
so , it's a dot product that take time proport to the number of non zero entri in the vector .
and , and that's go to be import in the us of a matrix .
so instead of us the standard matrix represent , where everi row of a matrix is an arrai , that's what a two dimension arrai is and the space is proport to n <num> .
now we're go to us a spars matrix represent , where each row of the matrix is a spars vector .
we can iter through the element in , in constant time , and with a hash tabl , we can get at them in near constant time and then constant time in the averag .
but the space is onli proport to the number of non zero element plu n for the extra symbol tabl overhead .
so , those ar independ symbol tabl object .
but thei allow us to have a much more effici matrix multipl method .
so now if we have a spars matrix time a vector our run time is go to be constant for each row or proport to the number of non zero entri for each row which mean that the run time is go to be linear for a spars matrix just by the us of a symbol tabl .
and thi clearli can make the differ between be abl to address a huge problem .
if we have a <num> , <num> by <num> , <num> matrix we can get it done nearli instantli linear time versu <num> , <num> <num> .
if we now run out of space , we might run out of time .
welcom back to algorithm .
todai , we're go to talk about the union find problem .
a set of algorithm for solv the so call dynam connect problem .
we'll look at two classic algorithm .
quick find and quick union , and some applic and improv of those algorithm .
the subtext of todai's lectur realli is to go through the step that we'll follow over and over again to develop a us algorithm .
the first step is to model the problem .
try to understand , basic , what ar the main element of the problem that need to be solv .
then we'll find some algorithm to solv the problem .
in mani case , the first algorithm we come up with would be fast enough and mayb it fit in memori and , we'll go ahead and us it , and be off and run .
but in mani other case mayb it's not fast enough , or there's not enough memori .
so , what we do is try to figur out why , find a wai to address whatev's caus that problem , find a new algorithm and iter until we're satisfi .
thi is the scientif approach to design and analyz algorithm , where we build mathemat model to try and understand what's go on , and then we do experi to valid those model and help us improv thing .
so , first we'll talk about the dynam connect problem , the model of the problem for union find .
so , here's the idea .
thei're go to have a set of n object .
doesn't realli matter what thei ar .
we're go to us the number , zero through n to model our object .
and then , we have the idea of a connect between two object .
and , we'll , postul that there's go to be a command that sai , connect two object .
given two object , provid a connect between them .
and then kei part of the problem is find queri or the connect queri , which just ask , is there a path connect the two object .
so for exampl , in thi set of ten object , we perform alreadi , a bunch of union command , connect four and three , three and eight , six and five , nine and four , two and on .
and now we might have a connect queri that sai , is zero connect ed to seven ?
well , in thi case , there is no connect , so we sai no .
but if we ask is eight connect to nine ?
we ar go to sai ye , even no we don't have a direct connect between eight and nine .
there is a path from eight to three to four to nine .
so , that's our problem , to be abl to offici support these two command for given set of object .
now , let's sai we add a union five , zero .
so , that creat a connect between five and zero .
seven and two creat a connect between seven and two .
and six and on , between six and on .
so , now if we ask our zero connect to seven , well on and zero we can do that too .
and that's a redund connect .
and now , if we ask is zero connect to seven we're go to answer ye .
so that's our problem , intermix union , command and connect queri and we need to be abl to offici support those command for a larg number of object .
so , here's a much bigger exampl .
and you can see that we're go to need effici algorithm for thi .
first of all , you can see we're go to need a comput for thi .
it would take quit , quit some time for a human to figur out whether there's a connect .
in thi case there is a connect .
now , the algorithm that we're look at todai ar not go to actual give the path connect the two object .
it's just go to be abl to answer the question , is there a path ?
in part two of the cours , we'll consid algorithm that explicitli find path .
thei're not as effici as union find becaus thei have more work to do .
now , applic of these , these algorithm involv object of all type .
these ar us for digit photo , where the object ar pixel thei're us for network , where the object ar comput , social network , where it's peopl , or comput chip , where it's circuit element or abstract thing like variabl name in a program , or element in a mathemat set , or physic thing like metal site in a composit system .
so , all differ type of object for , but for program we're go to associ each object with a name and we'll just name the object with a number , integ from zero to n <num> .
that's a veri conveni initi start point for our program becaus we can us integ as an index into an arrai then , and then quickli access inform relev to each object .
and it also just supress a lot of detail that ar not relev to union find .
in fact , to make thi map from an object name to the integ zero through n on is to find applic of a symbol tabl or a search algorithm , which is on of the thing that we'll be studi later in thi cours algorithm and data structur for solv that problem .
now , the connect , well , we need , a few abstract properti that these connect have to satisfi .
and thei're all quit natur and intuit .
so we assum that is connect to is an equival relat .
that is , everi object's connect to itself , it's symmetr .
if p's connect to q , then q's connect to p , and it's transit .
if p's connect to q , and q's connect to r , then p's connect to r .
now these properti ar veri intuit .
but it's worthwhil to state them explicitli and make sure that our algorithm maintain them .
when we have an equival relat a set of object and connect divid into subset call connect compon .
a connect compon is a maxim set of object that's mutual connect .
for exampl in thi small exampl here , there's three connect compon .
on consist of just object zero , second on object on , four and five .
and third on the other four object .
and these compon have the properti that if ani two object in them ar connect and there is no object outsid that is connect to those object , that's connect compon .
our algorithm will gain effici by maintain connect compon and us that knowledg to effici answer the queri that's , that thei're present with .
okai , so to implement the oper , we have to find queri and the union command .
and so we're go to mai ntain the connect compon .
the find is go to have to check if two object ar in the same compon and the union command is go to have to replac compon contain two object with their union .
so , for exampl , if we have these compon , and we get the command to union connect , two and five .
essenti , we need to merg the connect compon contain the on contain two or the on contain five to get a big connect compon and now we have onli two connect compon .
all of that lead up to , in a program world to specifi , a data type which is simpli specif of the method that we ar want to go to implement in order to solv thi problem .
so you know , typic java model , what we will do is creat a class call uf that contain two method , on to implement union , the other on to implement connect , which return a boolean .
the constructor , take sr unit , the number of object , so that it can build data structur base on the number of object .
so , and we have to , bear in mind , as we're build our logarithm , that both the number of object can be huge , but also , the number of oper .
we can have a , a veri larg number , of union and connect , oper and our algorithm ar go to have to be effici , under those condit .
on of the practic that will follow often in thi cours is to check our api design befor get too far into deal with the problem , by build a client that is go to us the data type that we develop .
so , for thi exampl , we've got a client that , will read inform from standard input .
first , an integ which is the number of object that ar go to be process .
and then a seri of pair of object name .
and what the client doe is it , it'll , first it'll read the integ from standard input , and creat a , a uf object .
and then as long as standard input is not empti , it's go to read two integ from the input .
and if thei're not connect , then it'll connect them and print them out .
if thei ar connect it'll ignor .
so , that's our test client and that's a fine test client to make sure that ani implement doe what we expect that it will .
so , that's the setup .
now we'll look at our first implement of an algorithm for solv the dynam connect problem , call quick find .
thi is a so call eager algorithm , for solv kind activ problem .
the data structur that we're go to us to support the algorithm is simpli an integ arrai index by object .
the interpret is the two object , p and q ar connect if and onli if , their entri in the arrai ar the same .
so for exampl in thi exampl with our ten object the idea arrai that describ the situat after seven connect is illustr in the middl of the slide .
so that , after the , at thi point zero , five , and six ar all in the same connect compon , becaus thei have the same arrai entri , zero .
on , two , and seven all have entri on .
and three , four , eight , and nine all have entri eight .
so that represent is , show that thei're connect .
and clearli , that's go to support a quick implement of the find oper .
we just check the arrai entri to see if thei're equal .
check if p and q have the same id .
so , six and on have differ id .
on ha id on , six ha id zero .
thei're not in the same connect compon .
union is more difficult in order to merg the compon , contain two given object .
we have to chang all the entri , whose id is equal to on of them to the other on .
and arbitrarili we choos to chang the on that ar the same as p to the on that ar same as q .
so if we're go to union six and on , then we have to chang entri zero , five , and six .
everybodi in the same connect compon as six .
from zero to on .
and thi is , as we'll see , thi is a bit of a problem when we have a huge number of object , becaus there's a lot of valu that can chang .
but still , it's easi to implement , so that'll be our start point .
so we'll start with a , a demo of how thi work .
so , initi , we set up the id arrai , with each entri , equal to it index .
and so all that sai is that all the object ar independ .
thei're in their own connect compon .
now , when we get a union oper .
so , sai , four is suppos to be unio n with three .
then we're go to chang , all entri , whose id is equal to the first id to the second on .
so in thi case , we'll chang the , connect three and four mean that we need to chang the four to a three .
and we'll continu to do a few more so you'll get an idea of how it work .
so three and eight now so to connect three and eight now three and four have to be connect to eight .
so both of those entri have to chang to eight .
okai ?
so now , what about six and five ?
so again , we chang the first on to match the second on .
so to connect six and five , we chang the six to a five .
what about nine and four ?
so , now we have to chang the , to connect nine and four , we have to chang , <num>'s entri to be the same as <num>'s .
so now we have three , four , eight , and nine .
all have entri eight .
thei're all on the same connect compon .
two and on mean that we connect two and on by chang the <num> .
eight and nine ar alreadi connect .
thei have the same , entri in the idea arrai .
so , that connect queri , that find sai , true , thei're alreadi connect .
and five and zero have differ entri .
thei're not connect , so we'd return fals , in that case , not connect .
and then , if we want to connect five and zero .
then , as usual we'll connect , the entri correspond to both five and six to zero .
seven and two , union seven and two .
that's an easi on .
and union , six and on so there is three entri that have to get chang .
all those zero have to get chang to on .
so , that's a quick demo of quick find .
now next we'll look at the code for implement that .
okai , with thi concret demo in mind then move to code up thi algorithim is pretti straight forward .
although it's an interest program exercis that a lot of us would get wrong the first time .
so let's start with the constructor , well we have a , a privat integ arrai .
that's our id arrai .
that's the data structur that's go to support thi implement .
the constructor ha to creat the arrai and then go through and set the valu correspond to each index i to i .
that's straight forward .
the find oper , or connect oper .
that's the easi on .
thi is the quick find algorithm .
so it simpli take it two argument , p and q , and check whether their id entri ar equal , and return that valu .
if thei're equal , it return true .
if thei're not equal , it return fals .
the more complic oper implement is a union .
and there , we find first the id correspond with the first argument , and then the id correspond to the second argument .
and then we go through the whole arrai , and look for the entri whose id ar equal to the id of the first argument , and set those to the id of the second argument .
that's a pretti straightforward implement .
and i mention that a lot of us would get us wrong .
the mistak we might make is to put id of p here rather than first pick out , that valu .
and you can think about the implic of that .
that's an insidi bug .
so , that's a fine implement of quickfind so the next thing to decid is how effect or effici that algorithm is go to be and we'll talk in some detail about how to do that but for thi it's suffici to just think about the number of time the code ha to access the arrai .
as we saw when do the implement , both the initi and union oper involv the for loop that go through the entir arrai .
so thei have to touch in a constant proport to n time after touch arrai entri .
find oper is quick , it's just to a constant number of time check arrai entri .
and thi is problemat becaus the union oper is too expens .
in particular if you just have n union command on n object which is not unreason .
thei're either connect or not then that will take quadrat time in squar time .
and on of the theme that we'll go through over and over in thi cours is that quadrat time is much to slow .
and we can't accept quadrat time algorithm for larg problem .
the reason is thei don't scale .
as comput get faster and bigger , quadrat algorithm actual get slower .
now , let's just talk roughli about what i mean by that .
a veri rough standard , sai for now , is that peopl have comput that can run billion of oper per second , and thei have billion of entri in main memori .
so , that mean that you could touch everyth in the main memori in about a second .
that's kind of an amaz fact that thi rough standard is realli held for <num> or <num> year .
the comput get bigger but thei get faster so to touch everyth in the memori is go to take a few second .
now it's true when comput onli have a few thousand word of memori and it's true now that thei have billion or more .
so let's accept that as what comput ar like .
now , that mean is that , with that huge memori , we can address huge problem .
so we could have , billion of object , and hope to do billion of union command on them .
and , but the problem with that quick find algorithm is that , that would take ten 18th oper , or , sai arrai axis or touch memori .
and if you do the math , that work out to <num> some year of comput time .
obvious , not practic to address such a problem on todai's comput .
and , and the reason is , and the problem is that quadrat algorithm don't scale with technolog .
you might have a new comput that's ten time as fast but you could address a problem that's ten time as big .
and with a quadrat algorithm when you do that .
it's go to be ten time as slow .
that's the kind of situat we're go to try to avoid by develop more effici algorithm for solv problem like thi .
all right so quickfind is too slow for huge problem .
so , how ar we go to do better ?
our first attempt is an altern call , quick union .
thi is so call lazi approach to algorithm design where we try to avoid do work until we have to .
it us the same data structur or arrai id with size m but now it ha a differ interpret .
we ar go to think of that arrai as repres a set of tree that's call a forest as depict at right .
so , each entri in the arrai is go to contain a refer to it parent in the tree .
so , for exampl , <num>'s parent is four , <num>'s parent is nine .
so <num>'s entri is four and <num>'s entri is nine in the arrai .
now each entri in the arrai ha associ with it a root .
that's the root of it tree .
element that ar all by themselv in just , in their own connect compon , point to themselv , so on point to itself but also nine point to itself .
it's the root of the tree , contain two , four and three .
so , from thi data structur we can associ with each item a root , which is repres , sai , of it's connect compon .
so that's the root of three is nine , go up that root .
now , onc we can calcul these root , then we can implement the find oper just by check whether the two item that we're suppos to check with ar connect where thei have the same root .
that's equival to sai , ar thei in the same connect compon ?
so that's some work , go to find the root of each item but the union oper is veri easi .
to merg compon contain two differ item .
two item that ar in differ compon .
all we do is set the id of p's rout to the id of q's rout .
let's make p's tree point to q .
so in thi case , we would chang the entri of nine to be six to merg three and five .
the compon contain three and five .
and with just chang on valu in the arrai we get the two larg compon emerg togeth .
that's the quick union algorithm .
becaus a union oper onli involv chang on entri in the arrai .
find oper requir a littl more work .
so let's look at the implement , a demo of that on in oper first .
so again we , we start out the same wai but now the idea arrai entri realli mean that everi on of these thing is a littl tree where the on node each everyon point to itself .
it's the root of it's own tree so now if we have to put four and three in the same compon , then all we do is we take the root , of the compon contain the first item and make that a child of the root of the compon , compon contain the second item .
in thi case we just make four as parent three .
so now three and eight .
so again , we take the first item and make it a child of the root of the tree contain the second item .
so now three , four , and eight ar in the same compon .
six and five six goe below five .
nine and four , so now four is the root of the tree contain four is eight .
and the root of tree contain nine is nine .
and so we make nine a child of eight .
two and on , that's an easi on .
now if we get our , our eight and nine connect , we just check that thei have the same root and thei both have the same root eight and so thei're connect .
five and four <num>'s root is eight .
<num>'s root is five .
thei're differ .
thei're not connect .
five and zero .
five goe to be a child of zero .
seven and two seven goe to be a child of <num>'s root which is on .
six and on .
<num>'s rout is zero <num>'s it own rout , so zero becom a child of on .
each on of these union oper just involv chang on entri in the arrai .
and final , seven and three .
so seven's root is on , three's root is eight , on becom a child of eight .
okai and now we have on connect compon with all the item togeth .
all right , so now let's look at the code for implement quick union .
the constructor is the same as the other on .
we creat the arrai and then set each element to be it's own root .
now we have a privat method that implement thi process of find the root by chase parent pointer until we get to the point where i is equal to id of i , and if it's not equal , we just move i up on level in the tree , set i equal id of i and return it .
so start at ani node , you just follow id equal id of i until thei're equal and then you're at a root and that's a privat method that we can us to implement the find oper or the connect oper .
you just find the root of p and the root of q and if you check if thei're equal .
and then the union oper is simpli find the two root i and then set the idea the first on could be the second on .
actual less code than for quick find , no fore loop .
there's thi on wild loop that we have to worri about a littl bit .
but that's a quick and eleg implement of code to solv the dynam connect problem call quick union .
so now we're go to have to look at can thi code be effect for larg problem ?
well unfortun quick union is faster but it's also too slow .
and it's a littl differ kind of too slow then for quick find , there's time when it could be fast , but there's also time when it could be too slow .
and the defect for quick union is that the tree can get too tall .
which would mean that the find oper would be too expens .
you could wind up with a long skinni tree .
of each object just point to next and then to do a find oper for object at the bottom would involv go all the wai through the tree .
cost involv in the rai axis just to do the find oper and that's go to be too slow if you have a lot of oper .
okai .
so , we've look at the quick union and quick find algorithm .
both of which ar easi to implement .
but simpli can't support a huge dynam connect problem .
so , how ar we go to do better ?
that's what we'll look at next .
a veri effect improv , it's call weight .
and it might have occur to you while we ar look at these algorithm .
the idea is to when implement the quick union algorithm take step to avoid have tall tree .
if you've got a larg tree and a small tree to combin togeth what you want to try to do is avoid put the larg tree lower , that's go to lead to long tall tree .
and there's a rel easi wai to do that .
what we'll do is we'll keep track of the number of object in each tree and then , we'll maintain balanc by alwai make sure that we link the root of the smaller tree to the root of the larger tree .
so , we , we avoid thi first situat here where we put the larger tree lower .
in the weight algorithm , we alwai put the smaller tree lower .
how we , let's see how we implement that .
let's see a demo first .
okai , so again start out in our normal start posit , where everybodi's in their own tree .
and for when there's onli two item to link it , it work , work the same wai as befor .
but now , when we have eight to merg with four and three , we put the eight as the child , no matter which order their argument came , becaus it's the smaller tree .
so , six and five doesn't matter , whichev on goe down doesn't matter .
nine and four , so now , nine is the small on four is the big on .
so , nine is go to be the on that goe down below .
two and on , five and zero .
so now , five and zero five is in the bigger tree so zero goe below .
seven and two , two is in the bigger tree so seven goe below .
six and on thei're in equal size tree .
and seven and three , three is in the smaller tree so it goe below .
so , the weight algorithm alwai make sure that the smaller tree goe below .
and again , we wind up with a singl tree repres all the object .
but thi time , we h av some guarante that no item is too far from the root and we'll talk about that explicitli in a second .
so , here's an exampl that show the effect of do the weight quick union where we alwai put the smaller tree down below for the same set of union command .
thi is with a hundr site and <num> union oper .
you can see in the top the big tree ha some tree , some node , a fair distanc from the root .
in the bottom , for the weight algorithm all the node ar within distanc four from the root .
the averag distanc to the root is much , much lower .
let's look at the java implement and then we'll look in more detail at , at that quantit inform .
so , we us the same data structur except , now we need an extra arrai , that for each item , give the number of object in the tree rout at that item .
that will maintain in the union oper .
find implement is ident to for quick union , you're just check whether the root ar equal .
for the union implement , we're go to modifi the code to check the size .
and link the root of the smaller tree to the root of the larger tree in each case .
and then after chang the id link , we also chang the size arrai .
if we make id , i a child of j , then we have to increment the size of j's tree by the size of i's tree .
or if we do the other wai around , then we have to increment the size of i's tree by the size of j's tree .
so , that's the full code in white for implement quick union .
so , not veri much code but much , much better perform .
in fact we can analyz the run time mathemat and show that defin oper , it take time proport to how far down the tree ar in the node in the tree , the node ar in the tree , but we can show that it's guarante that the depth of ani node in the tree is at most the logarithm to the base two of n .
we us the notat lg alwai for logarithm to the base two .
and , and , so for , if n is a thousand , that's go to be ten , if n is a million that's twenti , if n is a billion that's <num> .
it's a veri small number compar to n .
so , let's look at the proof of that .
we do some mathemat proof in , in thi cours when thei're critic such as thi on .
and why is it true that the depth of ani node x is , at most , log base two of n ?
well , the kei to understand that is to , take a look at exactli when doe the depth of ani node increas ?
when doe it go down further in the tree ?
well .
the x's depth will increas by on , when it tree , t1 in thi diagram , is merg into some other tree , t2 in thi diagram .
well , at that point we said we onli do that if the size of t2 wa bigger than the or equal to size of t1 .
so , when the depth of x increas , the size of it tree at least doubl .
so , that's the kei becaus that mean that the size of the tree contain x can doubl at most log n time becaus if you start with on and doubl log n time , you get n and there's onli n node in the tree .
so , that's a sketch of a proof that the depth of ani node x is at most log base two of n .
and that ha profound impact on the perform of thi algorithm .
now instead of the initi alwai take time proport to n .
but now , both the union and the connect or find oper take time proport to log base two of n .
and that is an algorithm that scale .
if n grow from a million to a billion , that cost goe from twenti to <num> , which is quit not accept .
now , thi wa veri easi to implement and , and we could stop but usual , what happen in the design of algorithm is now that we understand what it is that gain perform , we take a look and see , well , could we improv it even further .
and in thi case , it's veri easi to improv it much , much more .
and that's the idea of path compress .
and thi idea is that , well , when we're try to find the root of the tree contain a , a given node .
we're touch all the node on the path from that node to the root .
while we're doi ng that we might as well make each on of those just point to the root .
there's no reason not to .
so when we're look , we're try to find the root of , of p .
after we find it , we might as well just go back and make everi node on that path just point to the root .
that's go to be a constant extra cost .
we went up the path onc to find the root .
now , we'll go up again to just flatten the tree out .
and the reason would be , no reason not to do that .
we had on line of code to flatten the tree , amazingli .
actual to make a on liner code , we us a , a simpl variant where we make everi other node in the path point to it grandpar on the wai up the tree .
now , that's not quit as good as total flatten actual in practic that it actual is just about as good .
so , with on line of code , we can keep the tree almost complet flat .
now , thi algorithm peopl discov rather earli on after figur out the weight and it turn out to be fascin to analyz quit beyond our scope .
but we mention thi exampl to illustr how even a simpl algorithmah , can have interest and complex analysi .
and what wa prove by hopcroft ulman and tarjan wa that if you have n object , ani sequenc of m union and find oper will touch the arrai at most a c n m lg star n time .
and now , lg n is kind of a funni function .
it's the number of time you have to take the log of n to get on .
and the wai to think , it's call the iter log function .
and in the real world , it's best to think of that as a number less than five becaus lg two <num> is five .
so , that mean that the run time of weight quick union with path compress is go be linear in the real world and actual could be improv to even a more interest function call the ackermann function , which is even more slowli grow than lg<i> .
and anoth point about thi is it< i> seem that thi is< i> so close to be linear that is t im proport to n instead of time proport to n time the slowli grow function in n .
is there a simpl algorithm that is linear ?
and peopl , look for a long time for that , and actual it work out to be the case that we can prove that there is no such algorithm .
so , there's a lot of theori that goe behind the algorithm that we us .
and it's import for us to know that theori and that will help us decid how to choos which algorithm we're go to us in practic , and where to concentr our effort in try to find better algorithm .
it's amaz fact that wa eventu prove by friedman and sach , that there is no linear time algorithm for the union find problem .
but weight quick union with path compress in practic is , is close enough that it's go to enabl the solut of huge problem .
so , that's our summari for algorithm for solv the dynam connect problem .
with us weight quick union and with path compress , we can solv problem that could not otherwis be address .
for exampl , if you have a billion oper and a billion object i said befor it might take thirti year .
we can do it in six second .
now , and what's most import to recogn about thi is that it the algorithm design that enabl the solut to the problem .
a faster comput wouldn't help much .
you could spend million on a super comput , and mayb you could get it done in six year instead of <num> , or in two month but with a fast logarithm , you can do it in second , in second on your own pc .
all right .
now that we've seen effici implement of algorithm that can solv the unifi problem for huge problem instanc let's look to see how that might be appli .
there's a huge number of applic of union find .
we talk about dynam connect in network there's mani other exampl in our comput infrastructur .
down at the bottom is on of those import on is in imag process for understand how to label area in imag .
we'll see later kruskal's minimum span tree algorithm , which is a graph process algorithm which us union find as a subroutin .
there's algorithm in physic for understand physic phenomenon that we'll look at an exampl and mani other on thi list .
so , the on we're go to talk about now is call percol .
that's a model for mani physic system i'll give an abstract model and then just talk briefli about how it appli to physic system .
so let's think of an n by n grid of squar that we call site .
and we'll sai that each site is open .
that's white in the diagram with probabl p or block , that's black of the diagram with probabl on p and we defin a system to , we sai that a system is percol if the top and the bottom ar connect by open site .
so the system at the left , you can find a wai to get from the top to the bottom through white squar , but the system to the right doe not percol , there's no wai to get from the top to the bottom through white squar .
so , that's a model for mani system .
you can think of for electr .
you could think of a vacant site as be a conductor and , and a block site as be insul .
and so if there's a conductor from top to bottom then the thing conduct electr .
or , you could think of it as , as water flow through a porou substanc of some kind .
where a vacant side is just empti and a block side ha got some materi , and either the water flow through from top to bottom , or not .
or you could think of a social network where it's peopl connect and either there's a c onnect between two peopl or not and these ar a wai not to get from on group of peopl to anoth commun through that social network .
that's just a few exampl of the percol model .
so if we , we ar talk abouta random model where the site ar vacant with the given probabl .
and so it's pretti clear that if it's .
probabl that a site is vacant is low as on the left , two exampl on the left in thi diagram , it's not go to percol .
there's not enough open site for there to be a connect from the top to the bottom .
if the probabl is high and there is a lot of open side , it definit is go to percol .
there would be lot of wai to get from the top to the bottom .
but in the middl , when it's medium , it's question whether it percol or not .
so the scientif question , or the , mathemat question from thi model is , how do we know , whether it's go to percol or not ?
in thi problem and in mani similar problem , there's what's call a phase transit .
which sai that , you know , when it's low , it's not go to percol .
when it's high , it is go to percol .
and actual , the threshold between when it percol and when it doesn't percol is veri sharp .
and actual there is a valu as n get larg that if you're less than that valu it almost certainli will not percol , if you're greater it almost certainli will .
the question is what is that valu .
thi is an exampl of a mathemat model where the problem is , is veri well articul .
what's that threshold valu but , nobodi know the solut to that mathemat problem .
the onli solut we have come from a comput model , where we run simul to try and determin the valu of that probabl .
and those simul ar onli enabl by fast union find algorithm , that's our motiv exampl for why we might need fast union find algorithm , so let's look at that .
so what we're go to run is call a so call mont carlo simul .
where we initi the whole grid to be block ed all black and then we randomli fill in open site .
and we keep go .
and everi time we add an open site , we check to see if it make the system percol .
and we keep go until we get to a point where the system percol .
and we can show that the vacanc percentag at the time that it percol is an estim of thi threshold valu .
so what we want to do is run thi experi million of time , which we can do in a comput , as long as we can , effici do the calcul of doe it percol or not .
that's a mont carlo simul , a comput problem that give us a solut to thi , scientifc problem where , mathemat problem nobodi know how to solv yet .
so , let's , look in a littl bit more detail of how we're go to us our dynam , dynam connect model to do thi .
so , it's clear that , we'll creat an object correspond to each site .
and we'll give'em a name , from zero to n <num> <num> as indic here .
and then we'll connect them togeth .
if thei're connect by open site .
so the percol model on the left correspond to the , connect model on the right , accord to what we've been do .
now , you might sai , well , what we want to do is , connect , check whether ani site in the bottom row is connect to ani site in the top row , and us union find for that .
problem with that is , that would be a brute forc algorithm .
would be quadrat , right on the face of it .
becaus it would have n <num> , call to find , to check whether thei're connect .
for each site on the top , i'd check each site on the bottom .
much too slow .
instead , what we do is creat a virtual site on the top and on the bottom .
and then , when we want to know whether thi system percol , we just check whether the virtual top site is connect to the virtual bottom site .
so how do we model open a new site ?
well to open a site we just connect it to all it's adjac open site .
so that's a few call to union but that's easi to implement .
and then with that , simpl , relationship we can us the exactli the code that we develop to go ahead and run a simul for thi connect problem .
and that's where we get the result that , by run enough simul for a big enough n , that thi , percol threshold is about . <num> .
with thi fast algorithm we can get an accur answer to the scientif question .
if we us a slow union find algorithm we won't be abl to run it for veri big problem and we won't get a veri accur answer .
so in summari , we took an import problem .
the , the dynam connect problem .
we model the problem to try to understand precis what kind of data structur and algorithm we'd need to solv it .
we saw a few easi algorithm for solv the problem , and quickli saw that thei were inadequ for address huge problem .
but then we saw how to improv them to get effici algorithm .
and then left us with , applic that , could not be solv without these effici algorithm .
all of thi involv the scientif method .
for algorithm design where we try to develop mathemat model that help us understand the properti of the algorithm that we're develop .
and then we test those model through experiment enabl us to improv algorithm iter , develop better algorithm and more refin model until we get what we need to solv the practic problem that we have of interest .
that's go to be the overal architectur for studi algorithm that we're go to us throughout the cours .
welcom back .
todai we're go to do some math and some scienc .
not a lot , but we need to have a scientif basi for understand the perform of our algorithm to properli deploi them in practis .
so todai we're go to talk , about how to , observ perform characterist of algorithm .
we're go to look at how to make mathemat model and how to classifi algorithm accord to the order of growth of their run time .
we'll talk a bit about the theori of algorithm and also how to analyz memori usag .
so to put thi all in perspect , we're go to think about these issu from the point of view of differ type of charact .
so the first on is the programm who need to solv a problem and get it work and get it deploi .
second on is the client who want to us the whatev program did to get the job done .
third on is the theoretician , that's somebodi who realli want to understand what's go on .
and , and the last on is kind of a team , thi basic block and tackl sometim necessari to get , you know , all these thing done .
so , there's a littl bit of each on of these in todai's lectur .
and actual when you're a student you have to think that you might be plai ani or all of these role some dai .
so , it's pretti import to understand the differ point of view .
so , the kei that we'll focu on is run time .
and actual the idea of understand the run time of a comput goe wai back even to babbag and probabl befor .
and here's a quot from babbag , as soon as an analyt engin exist , it will necessarili guid the futur cours of the scienc .
whenev ani result is sought by it aid , the question will aris by what cours of calcul can these result be arriv at by the machin in the shortest time .
if you look at babbag's machin call the analyt engin , it's got a crank on it .
and liter the concern that babbag had in know how long a comput would take is , how m ani time do we have to turn the crank .
it's , it's not that differ , in todai's world .
the crank mai be someth electron that's happen a billion time a second .
but still , we're look for , how mani time doe some discreet oper have to be perform in order to get a comput done .
so , there ar lot of reason to analys algorithm .
in the context of thi cours we ar mainli interest in perform predict .
and we also want to compar the perform of differ algorithm for the same task , and to be abl to provid some guarante on how well thei perform .
along with thi , is understand some theoret basi for how algorithm perform .
but primarili , the practic reason that we want to be analyz algorithm and understand them is to avoid perform bug .
we want to have some confid that our algorithm go to complet the job in the amount of time , that , that we think it will .
and it's veri , veri frequent to see , in todai's comput infrastructur , a situat where the client get bad perform , becaus the programm did not understand the perform characterist of the algorithm .
and todai's lectur is about try to avoid that .
now , we're go to focu on perform and compar algorithm in thi cours .
there's later cours in typic comput scienc curricula that have more inform about the theoret basi of algorithm and i'll mention a littl bit about that later on .
but our focu is on be abl to predict perform and compar algorithm .
now there's a long list of success stori in design algorithm with better perform in , in enabl the solut of problem that would otherwis not be solv .
and i'll just give a coupl of exampl .
on of the first and most famou is the so call fft algorithm .
that's an algorithm for break down the wave form of n sampl of a signal into period compon .
and that's at the basi for dvd and jpeg and , and mani other appl icat .
there's an easi wai to do it that take time proport to n <num> .
but the fft algorithm , take onli n log n step .
and the differ between n log n and n <num> is , is the differ between be abl to solv a larg problem and not be abl to solv it .
a lot of the digit technolog , digit media technolog that we have todai is enabl by that fast algorithm .
anoth exampl wa actual develop by andrew appel , who's now the chair of comput scienc here at princeton .
and it wa develop when he wa an undergradu for hi senior thesi .
it's a fast algorithm for the n bodi simul problem .
the easi algorithm take time proport to n <num> , but appel's algorithm wa an n log n algorithm that again , meant that scientist can do n bodi simul for huge valu of n .
and that enabl new research .
s0 , o the challeng is that we usual face is , will my program be abl to solv a larg practic input ?
and , and actual , the work programm is actual face with that all the time .
why , why is my program run so slowli ?
why doe it run out of memori ?
and that's face programm for a realli long time and the insight to address thi .
deuter kanoof , in the 1970s , wa that , we realli can us the scientif method to understand the perform of algorithm in oper .
mayb we're not unlock new secret of the univers but , we can us the , scientif method , and treat the comput , as someth to be studi in that wai and come to an understand of how our program ar go to perform .
and let's take a look at that in more detail .
so thi just a quick summari of what we mean by the scientif method , which ha , been success for a coupl of centuri now .
so , what we're go to do is , observ from some featur of the natur world .
in thi case , it's go to be the run time of our program on a comput .
then we're go to develop hypothesi some model that's consist with the observ , and we're go to hope that , that hypothesi is good enough that it'll allow us to predict someth .
usual predict a run time for larger problem size , or on a differ comput .
and then we'll verifi the predict by make more observ , and valid until we're comfort that our model hypothesi and observ all agre .
that's a wai to get comfort that we understand the perform of our program .
now , the within the scientif method , there's some basic principl and the , the first is that if you're go to run experi , you should expect that somebodi els should be abl to run experi and get the same result .
and also the hypothes have to have a specif properti that the experi can show the hypothesi to be wrong .
so , it ha to be carefulli craft , and we'll be sure to try to do that .
so , and again the futur of the natur world that we're studi is some particular comput that exist in the natur world .
it chang the algorithm from an abstract to a , some , some kind of actual physic thing happen like electron race around insid the comput .
okai , so the first step is to be abl to make some observ about the run time of the program .
and for analysi of algorithm that's easier than in a lot of scientif disciplin , as we'll see .
for a run exampl we're go to us the so call <num> sum problem .
and it's an easi to state problem .
if you've got n distinct integ , how mani tripl sum to exactli zero ?
for exampl in thi file 8int . text .
text which ha eight integ in it .
there's four tripl that sum to zero .
<num> <num> , ten .
<num> twenti ten and so forth and so our goal is to write a program that can comput thi quantiti for ani input file , ani set of n integ .
thi is actual a , an extrem import comput that's deepli relat to mani problem in comput geometri which is a branch of comput scienc that cover the algorithm and underli scienc relat to graphic and movi and geometr model of all sort .
so thi is a actual an import practic problem .
but it's a simpl on to write code for in a view you could write down thi program without much effort .
it's a , got a static method count that is go to go ahead and take a integ arrai as an argument .
and , is that , that's a number of integ , that's the length of the arrai .
we will start with a variabl count equal zero , and then a tripl for loop , that check each tripl i j k , we go i from on and j from i <num> to n , and k from j <num> to n , so that we get each tripl just onc .
and then if i j , ai aj ak zero , we increment the count .
all right .
and after that tripl four loop , we return the count .
and then the main method , in thi simpl class just read in , all the integ , and print out the count .
so that's a brute forc algorithm that is a fine method for solv the three sum problem , now what we're interest in is how much time doe thi take as a function of' n ?
well , on to time our program is to is just look at the watch .
if you have a stopwatch , or look at the clock or your phone , or whatev you might need you can just go ahead and time it if you want or we have , java ha thi part of it's standard librari , a stopwatch class that will go ahead and comput a laps time .
so , in order , anytim you run a program , if it is setup to easili take input of differ size , a natur thing to do , is just run it for bigger size .
so for eight int thi program take not too much time , for <num> int it take half a second .
for <num> , <num> .
take more time .
that's <num> second run it again , still take <num> second for <num> , <num> , so each time we're doubl the size of the input and it's definit take more time each time .
and actual as we'll see if programm who get in the habit of test or ani time on their program in thi wai can get so that you can actual pretti easili and quickli evalu when it's go to finish .
in fact .
while you're wait for it to finish you can often figur it out .
so that on took <num> second for 4k and definit we could figur it out how long it's go to take for 8k befor it finish , and you'll see how in just a second .
i'm not go to wait right now .
you can think about what you think .
okai so that's empir analysi , analysi .
run it for variou input size and measur their run time .
now if thi were some scientif problem where we were count someth that happen in the natur world .
the number of ant in an ant hill or whatev then we'd have onli a few data point and we would try to understand what wa go on by do a plot of or run time with quit interest in on the y axi and problem size with the x axi .
hit a curv like thi and actual what scienc usual do becaus of some mani problem fall into out of thi class is do the plot as a lg , lg plot .
if you do it as a lg , lg plot veri often you'll get a straight line .
and the slope of the straight line is the kei to what's go on .
in thi case , the slope of the straight line is three and so you can run what's call a regress to fit a late , the straight line through the data point .
and then , it's not difficult to show to do the math to show that if you get a straight line and the slope is b , then your function is proport to a , n b .
that's call the power law .
and that's true of mani , mani scientif problem includ most algorithm .
so here's a littl bit of the math for that .
so the straight line mean that sinc we did a lg , lg plot with power of two , that lg t n b lg n c .
and we have our empir valu of b and c and then if you rais both side of that equat to two to that power then you get t n a constant time n b .
so right awai just from observ we have a pretti good model for the run time for our program , we can figur and do the math and figur out that it seem as though the run time is about ten <num> n <num> second .
we can us that hypothesi to go ahead and make predict .
just plug in for differ valu of n and it sai it will take us <num> second for <num> , <num> .
<num> second is plenti of time but now we can go ahead and invest and run that experi and sure enough we're pretti close to that <num> second when we run it .
and now we can make a predict for <num> , <num> or for or for whatev els we might be interest in .
the model help us do predict without invest the expens to run the experi .
in fact , in thi situat if there is a power law , and again in a veri great major of comput algorithm run time is go to be a power law .
what we can do is just doubl the size of the input each time the wai we were and take the ratio of the run time for n and 2n .
and if you do that , that ratio go to converg to a constant .
and in fact the log of the ratio is go to converg to that constant , which is the expon of n and the run time .
and you just need a littl math to check that on , but that's a veri easi and natur wai to go ahead and predict run time .
so that's what i said befor is , so we have thi quick wai to estim b in the power law relationsh ip .
how do we estim a ?
well we can just run it and solv for a .
so onc we've decid that , that expon is three let's run it for some big n and we get pretti close model to the on we had from plot thing .
so it's almost ident hypothesi and we just got it by run the program doubl n each time .
okai so there is a lot of effect in try to understand the run time of a program on , on your machin .
so .
kei effect ar independ of what comput it is .
and that's the algorithm you're us and what's the data .
and that's go to realli determin the expon in the power law .
and then there's a lot of , system depend effect .
what kind of hardwar do you have ?
do you have a fast comput or a slow on ?
what kind of softwar ?
what's go on in your comput ?
all of those thing realli determin the constant a in the power law .
so .
in modern system it is so much go on in the hardwar and softwar , it's sometim difficult to get realli precis measur .
but on the other hand we don't have to sacrific anim , or fly to anoth planet the wai thei do in other scienc , we can just run a huge number of experi and usual take care of understand these kind of effect .
observ what's happen as we did in the last section it give us a , a wai to predict perform but it realli doesn't help us understand what the algorithm's do .
so next , we're go to look at mathemat model .
a wai to get a better concept of what's realli happen .
again , thi concept wa realli develop and popular by don knuth start in the late 60s .
at that time , comput system were realli becom complic for the first time .
and comput scientist were concern about whether we realli were go to be abl to understand what's go on .
and knuth wa veri direct in sai that thi is someth that we certainli can do .
we can calcul the total run time of a program by identifi all the basic oper , figur out the cost , figur out the frequenc of execut and sum up the cost time frequenc for all the oper .
you have to analyz the program to determin what set of oper and the cost depend on the machin and the comput in the system is what we talk about befor .
the frequenc lead us to mathemat becaus it depend on the algorithm and input data .
knuth ha written a seri of book that give veri detail and all exact analys within a particular comput model for a wide rang of algorithm .
so , from knuth , we know that in principl , we can get accur mathemat model for the perform of algorithm or program and oper .
all right .
so what , what doe thi process look like ?
well you can , if you want run experi .
in , in ancient time , we would actual look at the comput manual and everi comput came with a manual that said precis how long each instruct would take .
but nowadai , it's a littl more complic .
so , we run experi and , and you can go ahead and do a billion ad and figur out that mayb on your comput , an ad take <num> nano second .
or you can do more complic function s like comput sign or an arc tangent although that's alreadi get close to the analysi of algorithm .
so , there's some wai to determin the cost of the basic oper .
and so , we'll just in most , most of the case we'll just postul that it's some constant and you can figur out what the constant is .
although when we're work with a collect of object , of anobject there ar some thing that take time proport to n like if you're go to alloc a arrai of size n it take time proport to n becaus in java the default is that all the element in the arrai initi to zero .
in other oper it depend on the system implement and an import on is string concaten .
if you concaten two string the run time is proport to the length of the string .
in mani novic program in java , make a mistak of assum that's a constant time oper when it not .
all right , so that's the cost of each oper .
more interest is the frequenc of oper , of execut of the oper .
so thi is a , a , it's a veri simpl variant of the three sum problem .
that's the on sum problem .
that's how mani number ar actual equal to zero ?
how mani singl number add up to zero ?
so , that on , it's just on four loop , and we go through , and we test the number zero and increment or count .
and by analyz that code you can see that i and count have to be declar and then thei have to be assign to zero .
there's compar of i against n and there's n on of them .
there's compar of a i against zero , there's n of those , n arrai axis and the number increment is number of time there's an increment is variabl .
i ha increment n time , but count could be increment ani number from zero to n time .
and so that frequenc is depend on the input data .
or we might need a model for describ that or mayb there's other oper that ar more e xpensiv and we won't need to worri about that .
so , let's look at the next more complic problem is what about the frequenc of execut of instruct in thi program which is the two sum problem , how mani pair of integ sum to zero ?
well , in thi case , you have to do a littl bit of math to see that when we when i goe from zero to n , and j goe from i a to n the number of compar that we do work , plu arrai axis that we do is two for each time the if statement is execut for ai and aj and that time is , thing is execut n on time the first time through the loop and n two <num> and so forth .
it's the sum of the integ from zero up to n on which is a simpl discret sum on half n , n on and sinc , and sinc we're do it twice the number of arrai axis is n , n on .
so , we can go ahead and get these actual exact count .
but alreadi , it's get a littl bit tediou to do that .
and as far back as ture who also knew that and as well as babbag did , that we want to have a measur of the amount of work involv in the process .
he recogn that you didn't want to necessarili go through and do it in full detail .
it's still help to have a crude estim .
so , you could count up the number of time that everi oper is appli , give it weight and , and count the and so forth .
but mayb we should just count the on that ar most expens that's what ture said in <num> , and realist that's what we do nowadai .
so rather than go in and count everi littl detail , we take some basic oper that's mayb the most expens and or and or the on that's execut the most often .
the on that cost and frequenc is the highest and us that as a proxi for run time .
essenti , make the hypothesi that the run time is , is go to grow like a constant time , so , in thi case , were go to pick arrai axis .
so , that's the first simplif .
and the second simplif is that we're go to ignor low order term in the formula that we deriv .
and there's an easi wai to do that .
it's call the tild notat and , and the idea is when n is larg in a formula like thi the n <num> term is much , much higher than the n term or sixteen .
in fact , so much so that we wouldn't even hardli notic these low order term .
so , all of these formula ar tild on sixth n <num> and that's a fine repres or approxim , approxim to these quantiti .
and it greatli simplifi their calcul to for a , through a wai to lower , lower to term like thi .
so , by focus on on oper and , throw awai the tild , the lower the term and thi is the technic definit of tild .
it's just , f n tild g n mean the limit as fn or gn equal on , and you can check that that's go to hold in these kind of situat .
so , that greatli simplifi the frequenc count .
and if we're onli pick on thing we're just talk about tild n <num> and mayb anoth tild n <num> for the increment for the two sum problem , okai .
so again , when n is larg , the term ar neglig and when n is realli small , thei're not neglig but we don't realli care becaus we're try to estim run time for larg n and run time for small n ar go to be small no matter what .
all right , so now , we're us both the cost model and the tild notat and then we can simpli sai , that thi program us tild n <num> squar arrai axis and have implicit the hypothesi that we think the run time is go to be tild , a constant , time n squar .
okai , we now what about three sum , let's do a , a real problem .
so now , we have the tripl loop .
and then , we have to do a more complic combinatori problem in is not that big a deal realli we ar look at the distinct number of wai you can chose three thing out of n and that 's binomi coeffici .
and again , do the math and us the tild , it's just tild on sixth n <num> three rai axis for each tripl so we can sai on half n <num> .
so we're not comput and sum the cost of all oper that's too much work .
we're pick the most expens in term of cost time frequenc and approxim that and try to get a good model for the run time .
so now most , we're not go to do of a full discret mathemat in thi cours but there's some basic thing that we'll want to us and ar , ar not that difficult to understand .
so , a lot of time we find out that we need to come up with an estim of a discret sum .
like we did for on two up to n .
or some of the squar or other thing like the three sum tripl loop .
and so actual if you've had basic calculu , on wai to think of it as to just replac the sum with an interv , integr .
that usual work or we can do the math and us the so call euler maclaurin summat formula to get a true approxim .
but if you think of it thi wai you'll believ us when we sai that , that thing is tild on half n <num> or sum of on on half on third up to on n .
that's like integr from x on to n1 x and that's natur log of n .
now even the three sum tripl loop kind of if you're us to multipl integr , i will quickli give you the on sixth n <num> .
there's mani more and other techniqu that we could us for thi .
and we're not go to teach all that , but we'll sometim refer to result of thi type .
all right , so in principl , knuth tell us that accur mathemat model ar avail in practic , we can get realli complic formula .
we also might need some advanc mathemat that the theoretician will revel in .
but that mayb peopl learn algorithm for the first time might not be expect to know .
so in the end care exact model ar best , best left for exit , expert .
there's realli a lot of thing that can go on .
on the other hand approxim model ar definit worthwhil .
and for all the algorithm that we consid we'll try to commun a reason approxim model that can be us to describ the run time .
sometim we'll give the mathemat proof and other time we'll have to just cite the work of some expert .
now , fortun when we analyz algorithm , actual not too mani differ function aris and actual that properti allow us to realli classifi algorithm accord to their perform as the problem size grow .
so that's what we'll talk about next .
so the good new is there's onli these few function turn up about the algorithm that we ar interest in .
we can craft thing that have other function and there ar counter exampl to thi .
but realli a great number of the algorithm that we consid ar describ by these few function and that ar plot here .
and the when we ar talk about the order of growth , we ar not talk about the lead constant .
normal we'll sai the run time of the algorithm is proport to n log n .
that mean we that we think that our hypothesi is that the run time is tild c lg n , n lg n , where c is some constant .
and in these plot , these ar lg , lg plot that not realli give a good idea of what's go on .
if a order of growth is logarithm or constant , doesn't matter how big the thing is .
it's go to be fast of the run time for is t for sai a thousand , and for half a million it will be pretti close to t .
if it's linear , if it's auto growth is proport to n then as the run time , as the size increas the run time increas correspondingli .
and the same is true , almost , if it's n log n .
so those ar the algorithm that we strive for .
thei scale with the input size .
as the input grow , so grow the run time .
and that's , a reason situat to be in .
as we talk about when we talk about union find .
if it's quadrat , the run time grow much faster than the input size .
and it's not feasibl to us such an algorithm for larg input .
and qubic is even wors .
so what we find is for mani algorithm our first task is realli , simpli , make sure it's not quadrat or qubit .
and these order of growth classif actual come from kind of simpl pattern in term of the code that we write .
so if our code ha no loop in it , then the order of growth is go to be constant .
if our code ha some kind of loop where the input's divid in half , and so binari search algorithm is an exampl of that .
then our order growth will be logarithm and we'll take a look at that analysi and but if you do the doubl test , it grow almost linearli , if you have a huge input and you doubl the size it's , it's still go to be i'm sorri , not linearli , constant just like if it's constant .
you'll hardli notic that lg n .
if you have a loop where you touch everyth in your input .
than the run time is linear , proport to end so a typic exampl of that would be find the maximum , or to count the number of zero .
our on some problem .
a veri interest categori is a so call n lg n algorithm or linear rhythmic algorithm .
and those ar the on that aris from a particular algorithm design techniqu call the divid and conquer .
and the mergesort algorithm , which we'll talk about in a coupl of week , is a prime exampl of that .
and then if you have doubl four loop like our two sum algorithm , that's go to be time proport to n <num> .
as we saw , that's quadrat , or tripl four loop like our <num> sum algorithm , that's go to be cubic or time proport to n <num> .
for a quadrat algorithm or a cubic algorithm , the doubl factor is four or eight as the input size doubl for cubic algorithm , the run time goe up by a factor of eight , and that's the kind of calcul that you can do in your head while wait for a program to finish .
there's also a categori of algorithm who's run time is exponenti and in those algorithm n doesn't get veri larg at and we'll talk about those at the end part two of the cours .
so these ar some practic implic of , of the order growth .
and we realli dwell on thi too much , except to come back to the point that the algorithm we ar realli interest in , that can solv huge problem , ar the linear and n lg n algorithm .
becaus even now a quadr atic algorithm on a typic fast comput could onli solv problem and sai that ten of thousand in a cubic algorithm onli in the size of thousand .
and nowadai those ar just not us becaus the amount of data that we have is more like the million or billion or trillion .
that fact is becom more and more evid as time wear on the ancient time would have some discuss about whether quadrat algorithm might be us but the situat get wors as the time goe on , so we need better algorithm .
to illustr the process of develop a mathemat model for describ a perform through an algorithm , we'll look at a familiar algorithm call binari search .
it's , the goal is that you have a sort arrai of integ , sai and you're given a kei .
and you want to know , is that kei in the arrai ?
and if it is , what , what's it index ?
and a fast algorithm for do thi is known as binari search , where we compar the kei against the middl entri .
in thi case , if we're look for <num> , we compar it against <num> .
if it smaller we know it in the left half of the arrai , if it's larger we know it's in the right half of the arrai , if it's equal , we found it .
and then we appli the same algorithm recurs .
so let's quickli look at a demo .
so we're look for <num> in thi arrai , compar it against the middl entri in the arrai .
<num> and it's less so we go left , so now we can concentr just on the left half of the arrai , now we look in the middl of thi half , that's <num> , <num> is bigger so we go right .
and now we concentr on the right half or the left half and we have a smaller sub arrai .
look at the middl , <num> is less so we go left and now we have onli the on element to look at and we found our kei <num> in the arrai and we return that index four .
if we're look for someth that's not in the arrai , we do the same process .
so , sai , we're look for <num> .
it's go to be the same .
look in the left half , look in the right half .
look to the left of the <num> .
now , there's onli on kei to look at .
a nd it's not <num> , so we sai , it's not there .
so that's binari search .
so here's the code for binari search .
actual , binari search although it's a simpl algorithm , it notori tricki to get everi detail right .
in fact on paper claim , that the first bug free binari search wasn't publish until <num> , and even in <num> , a bug wa found in java's implement of binari search , just an indic of the care that we have to take in develop algorithm especi for librari that ar go to be us by million of peopl .
so here's an implement .
it's not recurs although often we can implement thi recurs .
and it's just reflex code , what i describ in word , we have to find .
a kei , whether a kei's in an arrai .
and we us two pointer , low and high , to , indic the part of the arrai we ar interest in , as long as low is less and equal to high , we comput the middl .
and then we compar our kei against the middl , actual it a three wai compar , see it less or greater or if it equal , we , we return that mid index .
if it less we reset the high pointer , if it greater , we reset the low pointer , and we keep on go until the pointer ar equal .
if thei ar equal and we haven't found it then we return on .
and it's easi to persuad ourselv that thi program work as advertis by think about thi invari , if the kei in the arrai , then it's between low and high in the arrai .
all right , so that's a program that , you ar probabl familiar with .
let look at the mathemat analysi of that program .
and thi a , a theorem that we ar go to prove easili .
we want to a lot of proof but thi is on worth do .
so it sai that binari search us at most on lg base two event compar , to complet a search , in a sort arrai of size f .
so we do that , to setup the problem by defin , a variabl t n , which is the number of compar that binari search need for it arrai size and .
and then we write down a recurr relat that is reflex the code .
and what the code doe is , it divid the problem size in half so that .
if the event is less or equal to the event over two plu depend on how you count what the compar is think of it as a two wai compar so divid in half by do on compar and that's true as long as n is bigger than on .
if it's equal to on the solut is on .
so it's a recurr relat describ the comput .
and so we , we can go ahead and , solv thi recurr by appli the recurr itself , to the first term on the right .
now that's call telescop .
so if thi is true and we can appli the same thing to t n <num> .
and throw out anoth on and if that's , thi is true , appli the same thing to n over four , and throw out anoth on and so forth until we get down to just on .
in which case we have lg n on left .
now thi is a true sketch you might have notic that , that thi proof actual onli hold if n is a power of two .
becaus we nearli specifi in thi recurr what we mean if n is odd .
but it's possibl to go ahead and sorri , possibl to go ahead and take care of that detail as well and show that binari search run time is logarithm alwai .
all right , so given that fact we can develop a faster algorithm for a threesom .
it's a sort base algorithm .
and so what we're go to do is we're go to take the number that we have as input and sort them .
we'll talk about sort algorithm next week .
and we get that time in time proport to n lg n but that's not the main part of the comput .
the main part of the comput is to after the number ar sort , we'll go through and for each pair of number ai and aj .
we'll do a binari search for ai ij .
if we find it then we'll have three number that sum to zero .
so if we sort our number and then go through for each pair do a binari search to see if it's there , so <num> , zero .
minu that is <num> , we do a binari search that's in there so we have on solut to the <num> sum problem .
and do that for all pair of number .
then a quick analysi sai the order of growth of run time is go to be n <num> lg n .
then you need a good sort , well , you could us the elementari insert sort the first on we talk about but the run time of the binari search for each of the pair , each of the n <num> pair or n <num> <num> pair we're go to do the binari search , so we get a n <num> lg n run time .
so , a quick exampl of how we could improv the perform , we could find an imrov algorithm to solv a problem .
n <num> lg n is much less than n <num> for larg n .
and so , we're implicitli make the hypothesi that if we do thi , do the sort base thing and us binari search , we're go to have a faster program .
and , sure enough we can go ahead and run some experi and find that wherea it took us <num> second to solv the problem for <num> , <num> number befor .
it's take less than a second now .
in <num> second we can solv up to <num> , <num> .
so typic we expect that better order of growth mean .
faster in practic and but when it come to examin the algorithm in detail we can , we can go ahead and do the test and figur out which algorithm is faster .
and certainli go from n <num> to n <num> lg n we're go to expect that we're go to have a much better algorithm .
in fact the order of growth classif ar so import thei've led to enorm amount of research in recent year and just talk briefli about that now .
so there is , life is a littl bit more complic than point out in the last exampl and on problem is that the input can caus the perform of the algorithm to vari wide .
so often we have to think about differ wai of analyz the algorithm depend on the input .
so , the run time is go to be somewher between the best case and the worst case .
best case is the lower bound on cost it .
it provid someth that the run time is go to be bigger than that alwai or not less than that and then there's the worst case which is the most difficult input .
if we analyz that then we can guarante that the run time in the algorithm not go to be bigger than that .
and then in a lot of situat we might consid our input to be random .
well we need to , somewai to model , what we mean by random for the problem that we're solv but there is a lot of situat where we can do that and then we have a wai to predict perform even when the input might vari wide .
so for exampl for <num> sum , it's kind of alwai the same .
with the tild notat , the onli variabl in that algorithm is the number of time the counter is increment and that's in low order term so it doesn't need to chew up in our analysi .
for binari search it's , you might find the thing right awai in which case is constant time and we can show that the averag and the worst case ar both lg base two n .
there's other , in anoth exampl that be much more variabl even .
so , we have thi differ type of analysi depend on the input .
and but the question is , what about the actual problem that the client is try to solv ?
so we have to understand that two in order to be abl to understand perform of the algorithm .
and there's two approach that ar , or success in thi .
on is to design for the worst case .
just to make sure that your algorithm ar , alwai run quickli and that's definit ideal .
anoth is to , if you can't do that is to random and then depend on some kind of probabilist guarante and we'll see exampl of both of these as we go through the cours .
now , those kind of consider , you know the idea of order of growth lead to discuss of , what's call , what i call the theori of algorithm .
and here our goal ar , we have a problem to solv like solv the <num> sum problem and we want to know how difficult it is .
we want to find the best algorithm for solv that problem .
the approach that the comput scientist us for thi is to try to suppress as mani detail as possibl in the analysi .
and so just analyz the run time to or within a constant factor .
that's what order of growth is get at and also i want to , not worri about the input model at all .
and so we focus on worst case design and we can talk about perform of algorithm just in turn of the order of growth and it's actual possibl , it's actual possibl to do that in a veri rigor wai that it's taught us a lot about the difficulti of solv problem .
and our goal is to find an optim algorithm where we can guarante to within a constant factor certain perform for ani input cuz we discov the worst case but we also can have approv that didn't know algorithm could provid a better perform guarante .
i'll give a coupl of easi exampl of thi .
now in order to do thi thei're , these commonli us notat call the big theta , big o and big omega notat .
so the and those definit ar given here .
so big theta notat is just the wai to describ the order of growth .
theta n <num> is kind of short hand for anyth n <num> .
it's bound abov and below by constant time n <num> and that's what we realli us to classifi algorithm .
and then , there is big o notat which is upper bound on perform .
when we sai o n <num> , we mean that it's less than some constant time n <num> as n grow .
and big omega is us for lower bound mean greater than some constant time n <num> as n grow .
so those three notat were abl to us to classifi algorithm and i'll show them in the follow .
so , exampl from our <num> sum , <num> sum , and <num> sum ar easi to articul so our goal ar to establish the difficulti of the problem and to develop an optim algorithm .
so , the <num> sum problem is <num> in the arrai .
well , an upper bound on the difficulti of the problem is some specif algorithm .
so , for exampl , the brute forc algorithm that look , that look at everi arrai entri is a specif algorithm and it mean that and that take o n time .
we have to look at everi , it's less than a constant time n for some constant .
so , the run time of the optim algorithm ha to be o n that is that's specif algorithm provid an upper bound on the run time of the optim algorithm .
and but in thi case it's also easi to develop a lower bound , that's a proof that no algorithm can do better .
well , for <num> sum you have to examin all entri in the arrai .
if you miss on , then that on might be zero so that mean that the optim algorithm ha to have a run time at least some constant time n where we sai the run time is omega of n .
now in thi case , the upper bound and the lower bound match .
so , do the constant factor so , that's a proof that the brute forc algorithm for <num> sum is optim .
it's run time is theta n .
it's both omega and o n .
that's , for that simpl problem it wa okai to get the optim algorithm .
for a more complic problem it's go to be more difficult to get upper balanc and lower balanc and particularli upper balanc and lower balanc that match .
for exampl let's look at <num> sum .
so , upper bound for <num> sum , sai our first brute forc algorithm , sai that the proof , wa a proof that the run time of the optim algorithm is o n <num> but we found a better improv algorithm .
whose run time is o n <num> lg n .
so , that's a better upper bound .
lower bound well , we have to examin all entri cuz again , we might miss on that make <num> sum zero and that's a proof that the run time in the optim algorithm is omega n but nobodi know higher or lower bound for <num> sum .
so there's a gap between the upper bound and the lower bound and open problem .
is there an optim algorithm for <num> sum ?
we don't know what it is .
we don't even know if there's a algorithm whose run time is < o n <num> or we don't know higher lower bound and linear .
so that's an exampl of an open problem in the theori of algorithm we don't know how difficult it is to solv the <num> sum problem .
now , thi point of view ha been extrem success in recent decad .
we have a new problem , develop some algorithm , prove some lower bound .
if there's a gap , we look for new algorithm that will lower the upper bound or we try to find a wai to rais the lower bound .
usual it's veri difficult to prove non trivial or lower bound .
trivial or lower bound like look at everi input item is not so hard non trivial lower bound like for exampl , the proof that we're talk about for union find problem ar much more difficult .
and in the last sever decad peopl have learn about the comput difficulti of problem by examin steadili decreas upper bound so the algorithm were better worst case run time for lot and lot of import problem and plenti of optim algorithm and plenti of gap still remain .
it's a fascin field of research that mani peopl ar engag in .
now there is a coupl of caveat on thi on the context to thi cours .
and the first on is mayb it's overli pessimist to be focus on the worst case .
we've got data out there .
we've got problem to solv .
mayb it's not worst case data and lot of field of engin and scienc .
we don't focu on the worst case .
the worst case for thi cours would be lightn to strike and it would be over so we don't plan for that .
and sinc similar it's true for algorithm .
mayb we should be focus on understand prope rti of the input and find algorithm that ar effici for that input .
and the other thing is in order to realli predict perform and compar algorithm we need to do a closer analysi than to within a constant factor .
so we talk about the tild notat in the big theta , big o , and big omega , omega that ar us in the theori of algorithm .
and realli there's so much publish research in the theori of algorithm that a lot of peopl make the mistak of interpret the big o result that ar suppos to give improv upper bound on the difficulti of the problem as approxim model for the run time and that's realli a mistak .
so in thi cours , we're go to focu on approxim model by , you know make sure that we us the tild notat and we'll try to give specif result for certain quantiti of interest and the constant , ani unspecifi constant in the run time .
we'll have to do with properti in the machin and in the system so thei will be abl to us these result to predict perform and to compar algorithm .
so far , we've been talk about run time .
now we have to talk about the memori requir over our program as well .
well , the basic ar we want to know how mani bit the program us or byte , eight bit at a time .
and actual , we'll be talk in term of million of bit or billion of bit and actual surprisingli there is a controversi about even these basic definit .
comput scientist think of a million bit is two <num> and a billion is two <num> becaus that's a number of possibl thing that you can fit into <num> bit and everyth is consist with our calcul .
other scientist stick to on million or on billion for a lot of reason we'll usual us two <num> , i mean , a megabyt .
now an old comput we us to for mani year , we us a <num> bit machin so that pointer were four byte .
just in recent year we've mostli switch to a model where machin ar <num> bit and pointer ar eight byte .
that allow us to address much more memori but pointer us much more space and actual thi transit caus a lot of problem initi becaus program were us wai more space than peopl thought thei should .
you're not go to have to go through thi kind of transit the wai that we did becaus <num> bit is definit enough to address anyth that you might need to address , two <num> is realli a huge number .
so in term of byte we have to start out with typic memori usag .
now , again , thi is veri depend on machin and implement but these number ar reason and ar found on typic implement .
so a boolean , it will be nice of a boolean just took a bit cuz that's just true or fals but actual , usual we have to count for a byte for a boolean .
all byte is a byte .
charact nowadai is two byte , <num> bit charact .
not that a long ago we us eight bit for char .
integ regular int is four byte or <num> bit and a float is also four byte long int is eight and a doubl is eight .
usual , we us doubl for float point and int for integ in most applic .
so , that's for primit type .
and then for arrai there's a certain amount of overhead for make an arrai and then if there's n item , it's whatev the cost of the primit type time n so an arrai of doubl is sai 8n <num> .
and two dimension arrai then well , we can go ahead and comput the exact thing but now , now , it's time to us , the tild notat .
and then for arrai we could sai a doubl is tild 8n for on dimension .
for two dimension , two dimension arrai of doubl is tild 8mn .
and there's extra term for the over head but for larg m and n that's go to be pretti accur .
so , that's our basic usag for primit type and arrai in a typic java implement .
now , a lot of our program and object like link list and so forth .
so , we have to also factor in object overhead to crossov refer and also there's pad built in , in typic implement to make it so that each object ha us a multipl of eight byte .
so , for exampl if you have a date object that had three int instanc variabl then that object would take a total of <num> byte .
each int take four byte , object overhead is sixteen byte .
it need four byte for pad so it's a total of <num> byte .
so and the other on that often come up is a string and the string is a littl bit more complic than a than an arrai but the typic implement of a string in java ha a , a refer out to an arrai of charact and then , it got int valu for offset count in a hash valu and then some pad and ad it all togeth the cost of the string is about 2n <num> byte .
so , these ar the basic that we need to analyz the memori usag for a typic java program .
a h , so for primit , for data type valu , if it's a primit type it's four for an eight , and eight for a doubl , and so forth .
if it's a refer , it's go to be eight byte and that's for the pointer take arrai <num> byte plu the memori for each entri in an object sixteen byte plu the memori for the instanc variabl plu if there's an inner class , it's anoth eight byte as we talk about with node for link list .
and then there's the pad .
so then we have to , to think about who is respons for referenc object , you know , in , in some case .
and we'll take care of that when we get to these situat .
so , as an exampl , a simpl exampl of memori us analysi , let's take a look at how much memori ar rate quick union uf function from a , a few lectur ago , us as a function of n .
and there's onli a coupl of memori element and each on of them ar easili analyz us the basic that we just gave it's an object so the sixteen byte of object overhead there's two int arrai .
each on of them have arrai overhead of <num> plu and then 4n for the n entri .
each and vn entri take four byte and there's four byte for the count and there's four byte for the pad and if you add it altogeth it get 8n <num> which is tild 8n and again , all that's sai is when n is larg , all we ar go to care about in term of analyz the memori is that we've got 2n integ two arrai of size n each on of which take four byte for a grand total of 8n byte .
okai .
so , in summari we realli can figur out how mani time we have to turn the crank on modern comput .
we can do it with empir analysi where we actual execut the program , can do experi and us power law , formul hypothesi and make predict .
but we can do more , we can do mathemat analysi where we can identifi the most costli oper , analyz the frequenc of execut of those oper and us the tild notat to simplifi analysi .
we can actual explain the behavior , not just predict it .
and thi is a fine exampl of the us of the scientif method to understand the artifact that we're studi , the algorithm .
our mathemat model ar usual independ of a particular comput system and even impli to machin that ar not yet built .
but we alwai valid our mathemat model by run experi on real machin so that we can be confid where we're make predict and analyz algorithm .
welcom back .
todai we're go to talk about algorithm and data structur for implement some fundament data type call bag , queue and stack .
you mayb somewhat familiar with these , but todai we're go to take a care and close look at them .
the idea is that in mani applic , we have collect of object that we want to maintain .
and the oper ar veri simpl .
we want to add someth to the collect , mayb remov someth from the collect and iter through the object in the collect perform some oper on them , and of cours , test if it's empti .
now for most of these , the intent is veri clear .
the kei is when it come to remov an item , which item do we remov ?
the two fundament classic data structur for thi , the stack and the queue differ in the wai in which the item to be remov is chosen .
for the stack , we take out the item that wa most recent ad for , the terminolog that we us is push to insert an item and pop to remov the item most recent ad .
that's also call the lifo disciplin last in first out .
for queue , we examin the item least recent ad and those oper to distinguish them we call inqueu to insert an item and dequeu to remov an item and that's also call the fifo disciplin , first in , first out .
so now we're go to take a look todai on how to implement these thing .
our subtext todai is all about modular program .
and that's go to be a disciplin that we're go to follow up carefulli throughout thi cours .
the idea is to complet separ the interfac and the implement .
so , when we have these type of data structur and data type that ar precis defin like stack and queue and so forth , what we want to do is complet separ the detail of the implement from the client .
the client ha , can have mani differ implement from which to choos but the client code should onli perform the basic oper .
the implement on the other hand , can't know the detail of the client need , all it's suppos to do is implement those oper .
in that wai , mani client can reus the same implement .
so thi allow us to creat modular reusabl librari of algorithm and data structur that we can us to build more complic algorithm and data structur .
it also allow us to focu on perform when appropri .
again , thi is a modular program style that's enabl by object orient program languag such as java and we'll be veri disciplin in our us of thi style .
all right .
so to begin , we'll talk about the stack .
stack ar familiar , mani of you probabl implement stack in an introductori program cours but we'll do a thorough introduct to implement right now .
as a warm up , let's suppos that we have string , a collect of string .
thei might be short , thei might be long and what we want to have is the abil to save awai a collect of string and remov and return the most recent ad string period , and also test if it's empti .
so that's our api .
we have a constructor to creat an empti stack , we have for insert and we have a method call push that take a string as argument .
and for remov , we have a method pop that return to the string most recent ad .
and we have these empti test which return a boolean .
also in some applic , we would includ the size as well .
so again , as alwai , we'll first read a client and then look at implement and our client , simpl client is to take some string on standard input and some pop command which ar indic with hyphen .
and so , it'll thi client read string from standard input .
if the string is equal to the hyphen charact , it'll pop the string at the top of the stack and print it .
otherwis , if it's a string that's not equal to the hyphen charact , it'll just push it on to the stack .
so in the exampl down below here if we have thi file call tobe . txt then what we'll , what the client will do is push to be or not to all in the stack then when it come to thi hyphen it'll pop the most recent insert item which is two in thi case then it'll put b in the top of the stack and then pop the top item on the stack which is now b and then pop the item most recent ad , b is gone , two is gone so the next is not and so forth .
so , thi is a simpl test client that we can us to test our implement .
so now , let's look at the code for implement a stack .
now , the first implement that we'll look at , us link list .
if you're not familiar with the link list you'll need to review that in section <num> , <num> at the book or in our introduct to program java book .
even if you ar familiar with link list , it's worth take a look at thi code becaus it's the style of code that we'll us throughout the coars for much more complic data structur .
so the idea is to keep a link list where which is consist of node that have string in them and refer to the next item in the link list and to , to implement a stack when we do a , a push oper , we insert a new node at the begin of the link list and we do a pop oper where we move the first node from the begin of the link list , that's the most recent ad item .
so , let's look at what that code look like .
we us to implement link list in all link data structur through out the cours .
we us what's call an inner class in java and that's just a wai to describ that we're go to be manipul node object that consist , each consist of a string and a refer to anoth node .
so , the pop oper for link list is veri easi to implement .
first , we , we're go to need to return the first item on the list so we save that awai .
take first that item and save that in the variabl item .
a h , then , to get rid on the first node , we just advanc our pointer to the first item on the list to point two of the next item and then that first node is readi to be reclaim by the garbag collector .
and then , the last thing we need to do is just return the item that we save awai .
okai , so that's the pop oper .
what about the push oper ?
push oper , we want to add a new node at the begin of the link list .
so , first thing we do is save a wai the pointer to the begin of the list .
that's a littl first thing first .
then we'll creat a new node , that's go to be the new node that we put at the begin of the list , that's first equal new node .
and then we said it's instanc variabl .
it's item is the string that we want to put at the begin of the list , in thi case , not .
and it's next is the old first item of the list which is now the second item of the list .
so , after thi oper , we ar first point to the begin of the list and we have the item on the list in decreas order of when thei were put on to the stack .
so that also is a four liner to implement the stack push oper .
so thi is a complet link list implement of all the code to implement a link list for a stack of string in java .
it's , it's a class the constructor doesn't have to do anyth , there's no constructor .
we have thi inner class that we us to build the item in the link list and we make them an inner class so we can directli refer to those instanc variabl .
and then the onli instanc variabl of a stack is a refer to the first node on , on the list and that start out be null .
then it's empti is just test whether the first node on the list is null and then push is the four line of code that i gave on the previou slide and pop is the three line of code that i gave on the slide befor that .
tha t's a complet implement for the link list that'll work with as a fine push down stack implement for ani client .
so now we can analyz the perform of that so that we can provid client with inform and how well the algorithm data structur will perform .
in thi case , it's easi to see that everi oper take constant time in the worst case .
there is onli a few instruct for each on of the oper , there's no loop .
so that's obvious a veri desir characterist .
then how about space unit , usag ?
well , that depend veri much on the implement in machin so thi a typic java implement that we'll do the analysi for and contest thi out for differ type of environ easili in thi repres .
so , in java , an inter class there's for everi object there is sixteen byte of over head .
there ar some extra over head , eight byte becaus that's an inter class and then there is two refer that we built in our , in , in our class node .
on to string and anoth on to a node and those ar each eight byte .
so , we have <num> byte per stack node , if we have a stack of size n , we have about <num> n byte .
that's a littl extra first but that's about an overhead for the whole stack but when n is larg , 40n is a veri close estim to the amount of space need .
thi doe not includ the space for the string themselv which ar own by the client .
but with that , we can properli ass the research usag of thi implement for differ client program .
now it's constant time but there's faster implement of stack and sinc stack is us inner loop of some algorithm it's import to think about even faster implement .
and anoth , natur wai to implement a stack is to us an arrai to store the item on a stack so let's take a look at that .
thi altern of choos between length structur and arrai is fundament and it's go ing to come up again and again when we consid more complic data structur in algorithm .
so , we want to be sure to analyz it in the simpl case for stack to set the stage for more complic applic later on .
all right , so the us in arrai we just keep the n item on the stack in the arrai and the arrai locat within the n is the place the top of the stack where the next item is go to go .
so , to push we just add a new item at s n into pop we remov the item that's at s n on and decrement n .
now there is a fundament defect in us an arrai and that is that you have to declar the size of arrai ahead of time and so the stack ha a certain capac .
and if there is more item on the stack than the capac we have to deal with that problem and that's a fundament problem that we have to deal with in arrai implement in all sort of algorithm and data structur .
so again , consid it for the simpl case we'll pai off later on .
all right , so here's the full implement of stack for us an arrai to repres the stack .
so now we have an instanc variabl which is an arrai of string and or variabl n which is both the size of the stack and the index of the next posit , next open posit on the stack .
thi on ha a constructor and the constructor creat the arrai .
now , we ar cheat in thi implement to keep it simpl and we'll take care of thi cheat in a littl while by requir the client to provid the capac of a stack .
in a few applic thi might be fine but in mani , mani applic that's two owner ar requir and client realli can't know how big the stack is .
client might have a lot of stack that need to be maintain simultan and then mayb thei reach their maximum capac at differ time and variou other thing .
so , we need to remov thi cheat and will .
but the code is nearli trivial .
if we have the capac to check if it's empti we check if n is zero .
to push an item we us n to index into the arrai put the item there and then increment n , that's the short cut in mani program languag nowadai for us the index and then increment it .
and to pop we decrement the index and then us it to return the item in the arrai .
so each of the oper is a on liner and thi is a fine implement for some client .
that's arrai implement of stack but it break the api by requir the client to provid the capac .
so what ar we go to do about that ?
well , there ar a coupl of thing that we didn't consid .
we didn't put in a code to throw an except if the client pop from an empti stack .
probabl should do that and for overflow , what happen when the client doe too much well , we're go to talk about an approach call resiz that will allow us to avoid overflow for client .
there's anoth issu about whether client can insert null item into the data structur .
in thi case , we do allow the client to insert null item but we do have to worri about in java about a problem call loiter and that is the idea that we have refer to an object in our arrai implement and the stack arrai and we ar not realli us it .
so , when we decrement that valu in , there's still a pointer to the thing that we took off the stack in that arrai even though we know we're not us it .
the java system doesn't know that .
so to avoid that and realli allow most effici us of memori it's best to set that .
remov item entri to null so there's no refer to the old item left there and then the garbag collector can reclaim the memori sinc there's no outstand refer .
so that's a , a detail but an import on that we have to take care of and or implement to make sure that we're get most efficien t us of memori .
okai , our basic arrai implement of stack had the defect where we requir client to provid us the maximum capac of the stack ahead of time .
now , we're go to look at techniqu for resolv that problem .
how do we , we do not implement the api .
the api sai we should just be abl to creat a stack and it should be abl to grow and shrink to ani size .
so , how do we go to go and shrink the arrai ?
well , first thing you might think of is when the client push a new item onto the stack increas the size of the arrai by on and when pop , decreas the arrai by on .
that's easi to code up but not worth it becaus it's much too expens to do that .
the reason is that you have to creat a new arrai , size on bigger and copi all the item to that new arrai .
so insert the first n item would take time proport if the text , stack is size n on , it's go to take time n .
and when it's two time n on so the first n item will take the sum of the first n integ which we know is about n <num> two .
quadrat time to insert n item into a stack that kind of perform is unaccept for larg problem as we've seen , as we will see mani time .
so , the challeng is to do the resiz .
but somehow ensur that it happen and frequent .
so , the well end techniqu for do that call repeat doubl is to when the arrai fill up , creat a new arrai of twice the size and copi all the item over .
then we don't creat new arrai all that often so here's the implement of that .
we start with an arrai of size on .
if we have a full stack , which we know by test n which is the number of item in the stack versu the rail length , then we just re size the arrai into on of twice the length befor insert the item .
and how do we re size to a new capac ?
we creat a new arrai of that capac and just go ahead and copi our current stack into that , into the first half of that and then retu rn it .
and that will reset our instanc variabl which is our stack to thi new bigger arrai .
so , the idea and the consequ of thi is if you insert n item into an arrai , into a stack with thi arrai represent , the time will be proport to n not n <num> .
and the reason is that you onli creat a new arrai everi time it doubl but by the time that it doubl , you've insert that mani item into the stack so on averag , it's just like ad on oper to cost of on to each oper .
so , if we just , if we just calcul the cost and insert the first n item you're go to have , instead of the sum of the integ from on end , you're go to have the sum of the power of two from on to end and that will give a total cost of about 3n .
so , that's an arrai axis .
for the copi , there's two arrai axi .
so , to insert an item , it about three arrai axis .
thi plot is anoth wai of look at it which is the number of arrai axi it taken as you implement push oper .
everi time you hit a power of two , you take that mani arrai axis but in the sens you've alreadi paid for them by put those item on the stack .
so that's call amort analysi , where we consid the total cost averag overal oper and thi is a , a fine exampl and us exampl of amort analysi to get effici in a stack implement .
now we , we have , what about the pop ?
we have to think about how to shrink the arrai .
so , we might think , well , we doubl it when it wa full , when do we cut it in half when it get to be half full .
we don't want to get the arrai to get two empti .
well , that on , on doesn't exactli work becaus of a , a phenomenon call trash .
if you , if the client happen to do push , pop , push , pop altern when the arrai is full then , it's go to be doubl , halv , doubl , halv and creat new arrai on everi oper to take time proport to n for everi oper and therefor , quadrat time for everyth so i don't want to do that .
the effici solut is to wait until the arrai get on quarter full befor you have it .
and that's veri easi to implement .
we'll just test if the arrai on quarter full , if it is , we re size it to half full .
and so , then at that point , it's half full and you can either grow by ad stuff or shrink by subtract stuff but there won't be anoth resiz arrai oper until , i guess total full or half again full .
so the invari of that is the arrai alwai between <num> percent and a <num> percent full , number on and number two that everi time you re size , you've alreadi paid for it in the amort sens by insert push or pop .
so , here's just a what happen to the arrai for our small client exampl and you can see at the begin , it doubl from on to two to four but onc it get to four , it stai onc it get to eight , it stai to that size for a while even though there's some of the oper it doesn't shrink back to four until after there's onli two item in there and then it shrink and so forth .
so , arrai resiz doesn't happen that often but it's a veri effect a wai of implement the stack api with an arrai where the client doe not have to provid thi maximum capac of the stack but still were guarante that the amount of memori that we us is alwai onli a constant multipl of the number of item actual on the stack .
so the analysi now sai that the averag run time per oper for whatev the sequenc of oper is the averag run time is go to be proport to a constant .
now , there is a worst case that is at the point when the stack doubl , it take time proport to n so it's not quit as good perform as we might like but it's what we the advantag that we get is ve ry fast push and pop just access arrai and increment it and veri effici for most oper .
and for mani , mani client that's an effect trade off to make .
so what about memori usag ?
well , thi is the analysi of memori usag for stack and it's actual less memori than for string the amount us is between 8n and 32n depend on how full the arrai is and just a quick analysi of the amount of space that arrai take in java .
so , again thi analysi is just for the stack itself not for the string which the client want .
so , what ar the trade off between us a re size arrai versu a link list .
there's a two differ implement and the same api and the client can us them interchang , which on is better ?
in mani situat , we're go to have multipl implement of api and depend on properti of the client program you're go to have to choos which on is the better on to us .
so , for link list everi oper take constant time in the worst case that's a guarante but we have to us a littl extra time and space to deal with the link .
so , it's go to be slower .
resiz arrai implement we have a good amort time so total averag over the whole process is good .
we have less wast space and probabl faster implement of each oper .
and so , for some client , mayb that make a differ perhap , you wouldn't want to us a re size arrai implement at the moment that your plane is come in for a land and you wouldn't want to all of the sudden , not implement some oper quickli .
if you need that kind or mayb in an internet switch where packet ar come through at a great rate , you wouldn't want to be in the situat where you're miss some data becaus someth got slow all of the sudden .
so , that's a trade off that the client can make if i want that guarante , if i want to be sure that ev ry oper is go to be fast us a link list and if i don't need that guarante , if i just care about the total amount of time i'll probabl us the resiz arrai becaus the total will be much less becaus individu oper ar fast .
so , even with these simpl data structur , we have realli import trade off that actual make a differ in lot of practic situat .
okai , next , we'll briefli consid queue implement us the same basic underli data structur .
so , here is the correspond api for queue of string .
actual you know it's the same api for stack just the name ar differ .
instead of push we have enqueu instead of pop , we have dequeu .
and the semant is differ .
for enqueu we add an item sai at the end of the queue and for dequeu we remov an item from the begin .
it's as if you're wait in line to bui a ticket .
when you're enqueu you're at the end and when that's been in there the longest is the on that come off .
so let's look at how we implement those first us link list and then arrai .
so , now our represent of a queue with the link list , we need to maintain two pointer refer .
on to the first item in the list and the other to the last item in the list .
when we insert we're go to add the item at the end of the list instead of the begin and when we remov we'll do the same and we'll take it off the front .
so here's the implement of dequeu .
it's ident to the code for pop for a stack .
we save awai the item .
we delet the first note by advanc the refer and then we return the item , so ident .
to add a node or enqueu , add a new node to a link list , we want to put it at the end so that would be the last on return .
so we , to add it at the end so first thing we need to is save a link to the last node .
we're go to need that becaus we need to chang it refer from null to point to the new node .
then we'll creat a new note for the end of the list will popul it field and then that old link will chang that from null to a pointer to the new node .
so again just a few line of code .
that's basic link list process .
actual year ago when we taught cours in algorithm and data structur much of the cours would be about thi kind of pointer manipul but nowadai that's restrict to just a few implement like stack and queue and a few other fundament data structur .
so we don't need so much anymor gener program for manipul link list .
we encapsul them in basic data type like these .
all right , so let's go back to our full implement and thi is just take care of collect a curv from the previou slide but also take care of special case when the queue is empti to make sure that if the queue is empti after we remov an item , we're go to last at null and make sure that both first and last alwai ar what we want them to be .
so those ar detail that ar easi to check .
okai , what about arrai ?
well , we want to do the detail but it's not difficult to implement queue with resiz arrai as well and not difficult but definit a tricki program exercis that peopl ar welcom to try .
so we'll maintain two pointer .
the first item in the queue and the tail which is the posit for the next item to appear so for enqueu you add a new item at tail and for dequeu you remov an item for head .
and the trick is that onc you get past the capac , you have to reset back to zero and so that's a littl extra code and then you have to add the resiz capabl as well to implement data structur the same as for stack .
and we'll leav that as an exercis .
next we're go to consid address anoth fundament defect in the implement we've consid so far that those implement ar onli good for string .
what if we want to have queue and stack of other type of data ?
and that bring us to the topic of gener .
all right .
so , we implement stack of string but in applic we have all differ type of data that we might want to implement like stack of int sai or url or car or van or whatev data that we might be process .
so how ar we go to implement stack and queue for that type of data .
well , first thing that we might that we might consid and actual we're forc to consid thi on in lot of program environ , is to implement a separ stack class for each type of data that we're us .
that realli seem unsatisfactori .
we have our carefulli craft code that doe arrai resiz and so forth and we're go to copi that code and chang the data type string to the data type van or int to everywher .
and what if we have hundr of differ type of data that we're process .
we have hundr of differ implement .
unfortun that situat at the begin of java where we stuck with that and there ar plenti of program languag where basic we're stuck with that so what we want to look at is a modern approach to avoid have multipl implement for each type of data .
so the a quick hack that is wide us is to us cast to implement to reus the code for differ data type .
so , we make our implement with type object so everyth in java is a sub type of object and then the client , when the client come to us it , will simpli cast the result to the correspond type .
i don't want to spend a lot of time with thi cuz i think thi is a unsatisfactori solut .
so , in thi exampl we have two type with two stack on of appl and on of orang .
and then , it's up to the client when it pop someth off the appl stack to cast at the appl to keep the type check system happi .
the problem with thi is that the client code ha to do thi , thi cast and it's kind of an insidi bug if it doesn't quit get it .
so , the third attempt that we're go to talk about us gener .
and that wai the client code doesn't do cast .
we can discov mistak in type mismatch at compil time instead of at run time .
so , in thi case , we put , with gener , we can have a type paramet on our class and that includ , that's insid angl bracket in thi code and then , we can if we have a stack of appl and we tri to push an orang unto a stack of appl then we're go to get a compil time error becaus that's stack wa declar to onli consist of , of appl .
and just the guid princip in good modular program is that we should welcom compil time error and avoid run time error becaus if we can detect an error at compil time , then we can ship our product or deploi our implement our implement of an api and have some confid that it's go to work for ani client wherea , the error is not go to get discov until run time it might occur with some client develop .
now , year after , we have to deploi our softwar and be extrem difficult on everyon .
okai .
so actual with a good gener implement it's not difficult to simpli , take everi place that we us string and replac it with a gener type name as in thi code here .
on the left is our implement of a stack of string us link list .
on the right is a gener implement .
so , everi place that we us string type on the left we us the word item on the right .
and at the top , the class declar we declar an angl bracket that item is the gener type that we're go to us .
the implement could hardli be more straightforward and it's an excel wai to solv the problem of handl multipl type of data with on implement .
with arrai , it doesn't quit work and again all program languag and , you know , mani program languag nowadai have difficulti with thi and java's got a particular difficulti .
so , what we would like to do is just declar a new arrai us our gener name item as in the highlight line here .
otherwis it's the same .
unfortun , java doe not allow gener arrai creation .
so there's variou technic reason for that and you can read , read extens debat about thi on the web that's go to go beyond our scope .
for now , what we need to do is put a cast in to make thi work .
so , we creat an arrai of object and then we cast it down to an arrai of item .
now in my view , a good code ha zero cast .
so , we want to avoid cast as much as possibl becaus it , it , it realli is declar some kind of weak in what we're do .
but in thi case we have to put in thi on cast and so what we've heard about that is the ugli cast it doesn't , it doesn't make you feel good about the code .
it's not someth that you will come up with on your own and that's , and that's an undesir featur , i think for code so simpl as thi .
but fortun , we can get through pretti much everyth that we're go to do in thi cours just know about thi on of lai cast .
so now , when we compil thi program we get a , a warn messag from java .
it sai that we're us uncheck or unsaf oper and we should recompil with a minu xlint equal uncheck for detail .
so , we can go ahead and do that and it sai that you have put in , in your code an uncheck cast and we're warn you about that cuz you shouldn't be put in uncheck cast .
and okai , that's fine and you're go to see that when you do compil us code like these .
i , i think mayb thei might have ad to thi warn statement we apolog for make you do thi .
it's not our fault that we had to do that , we had to do that cuz of your requir about not allow us to declar gener arrai .
so with that note pleas don't think there's someth wrong with your code if you follow our prescript and , and get thi warn messag .
okai then , it's on of the detail that java take care of and that's what about primit type so the gener type that we're us is for object and you know , we're cast down from arrai of object .
so in order to handl gener type we have to us java's wrapper object type .
so integ with the capit rapid type for int and so forth and mani of you were probabl familiar with that .
and there's a process call auto box which automat cast between primit type and wrapper so all of that handl of the , the problem of deal with primit type , kind of behind the scene .
and the bottom line is that we can articul an api for gener stack that work for ani type of data and we've got two implement , link list and arrai that , that perform veri well for ani type of data us the , the resiz or link list as we've describ .
okai .
there's anoth facil that java provid that lead to veri eleg compact client code that's definit worthwhil to add to our basic data type and that's iter , that's what we're go to talk about now .
so , what we want to do is to allow the client to iter through the item in the collect .
but we don't have the client to know whether we're us an arrai or link list or whatev intern represent we might have in mind .
it's not relev to the client .
and a lot of client onli want to do is just iter through the stuff in the collect .
but java doe provid a nice a solut to thi call iter .
so what we're go to do is look at how to make our stack , and queue , and other data structur that we consid later on implement the so call iter interfac and it will work for client code no matter which implement we us so let's take a look at the detail of that .
so what's an iter ?
well , in java lingo what an iter is , it's , it's a class that ha a method that return an iter .
and so what's an iter ?
well an iter is someth , a class that ha method hasnext and next .
the java also allow remov .
we think that on is bad new , we don't us it can lead to insidi debug , bug debug problem .
so , it's hasnext and next and so to make the data structur iter , we're go to implement those thing .
it seem like a lot of baggag to carri around and the reason that we do it , why do we go to the troubl do it is that we can , if we have a data structur that's iter we can us a veri compact and eleg client code in java , the so call for each statement .
so if we have a stack we can sai for string s stack .
it mean for each string in the stack print it out .
and if we didn't have that we would now , if we're us iter , we could go ahead and write thi longhand code but nobodi would ever do that cuz it's equival to the shorthand or we might have to write client code that doe a lot of unnecessari push and pop just to do thi iter .
so that's the kei is to be abl to have client code that is so compact for iter through item in the data structur so we're go to provid iter for all our basic data structur and it's not too hard to do definit worthwhil the effort .
so here's what it look like for link list .
so it's got to implement iter so what doe that mean implement iter ?
it's got to have a , a method iter that return an iter .
so what's an iter ?
so , we're go to us an inner class .
in thi case , we'll call it listiter that implement iter and it's gener .
and basic what thi thing ha to do is implement these method hasnext and next .
and the semant just clear from the name .
hasnext is suppos to if , if we're done is suppos to return fals .
if we're not done we're suppos to return true and the next is suppos to give the next item in the iter .
so if the thing is a link list we're go to start out at first .
we have that's the , our first item in the list and we're go to maintain an instanc variabl current insid thi iter which is the current thing that we're iter .
so , get the next on just like if we want to remov the first .
we pull out the current item and then advanc the current refer and return item .
move current to the next place .
the client is alwai go to be test hasnext as i show as i show and that stub code befor and so when it get to null it will return fals in the iter stop .
but for our iter , we just have to worri about implement next and hasnext and perhap us a local instanc variabl to get it done .
we have to probabl to make bullet proof code throw except if a client tri to call next with no item there and tri to call remov at all , we're not go to support remov .
for , and for arrai , it's even simpler .
so now with the iter we have control over which order we go through the item and so that's go to go along with the semant and the data structur so probabl in a stack you want to get the thing in stack order like the order that come out of the stack so that's revers order in the arrai so in thi case then next is just decrement and return the next on and our instanc variabl is an index in the arrai .
and then hasnext is okai as long as that thing is posit .
so a littl java code to provid thi iter facil but actual within thi framework not too much to do and you can see how to implement thi for your own data type and we'll us thi paradigm for everi basic data type that we , that involv collect of object that we'll encount .
all right , and in fact , it lead us to actual for a lot of client it doesn't realli matter what order we get the item .
realli often what we're do is just insert item into a collect and then , later on , iter through the item that we have .
that data structur is call a bag and so let's look at what that api look like .
order doesn't matter so all we want to do is add an item mayb you want to know the size and we want to iter through all the item in the bag .
so thi is a simpler , narrow api but still it express an import littl collect of oper and , and we'll us thi on and we've alreadi seen the implement .
you just take stack and remov the pop , or queue and remov the dequeu and you have fine implement of a us data structur .
okai .
those ar some basic data structur and implement and it seem quit elementari and simpl but actual right awai we can get to some veri sophist applic of these basic concept and that's what we're go to consid next .
now , first thing to mention is that often the kind of data type and data structur that we implement or found in a java librari .
so , that's true in mani program environ .
so , for exampl stack and queue you can find those word mention in the java librari so there's a java collect librari and the so call list interfac which is displai here .
so java ha gener api for sequenc of item and it got thing like a , append at the end , remov from the begin , and so forth .
ani us of the resiz arrai , so mani of the principl that we consid doe also a , a link list interfac .
so , why not just us those ?
why us our own implement ?
well , the problem is often in such librari code is kind of design by committe phenomenon that more and more oper get ad and the api becom too broad or bloat .
it's not a good idea to have lot and lot of , you know , oper in the same api .
and we'll see exampl in a second .
the problem , the real problem is that when you do that you can't know much about the perform or you can't assum much about the perform .
and so you can kind of immedi arriv at that perform even for simpl client .
so our best practic that we recommend is so few that these basic data structur that we us and there's so simpl is to go ahead and us the implement that we've just discuss for these fundament data structur .
mayb later , later on , after an experienc programm who know what he or she is do could us some of these librari collect effect .
but inexperienc programm often have troubl with it .
here's a war stori from student program assign not that long ago .
so , we have an assign where you need to gener a random open site in a percol system .
we have on student who wa pai attent to what we're sai and us an arrai and can pick the indic into that arrai at random check whether thei're open and , and repeat .
and so the arrai is n by n , it's n <num> thing and it take about n <num> time , which is actual a linear time for thi applic .
but then we have anoth student who had some java befor come to us and consid himself an expert and said , well , i'm go to us link list becaus i could us java's librari and i don't have to worri about download your stupid code .
and so , i'll just us that on and pick an index at random and delet and that program took quadrat time and poor kenni , when try to run hi program for the huge instanc that we ask found out that it wasn't finish .
and the reason is that the java link list implement take a linear time to find an item with a given index .
not constant time like an arrai .
and that's difficult for kenni to think about and difficult to drive that inform from the implement so program is just too slow .
and with the swiss knife implement with so mani oper it's hard to know whether or not the particular set of oper that your client need is effici implement .
so our insist in thi cours is that student should not us the librari until we've implement it in class .
at least that some indic that you understand the perform characterist .
so now , let's look at some applic then of , of stack .
there's the stack ar realli actual fundament underli comput becaus thei implement , recurs and so , you us stack often everydai when you wrote , us the back button in the web browser , the place that you've been ar save on a stack .
right now we will look at two exampl .
on , have to deal with compil from a program languag or interpret into an actual comput and then the other on is the postscript languag which is wide us for , for print and publish .
so , so the wai the compil implement function is us stack .
when there's a function call the whole local environ is push and then along with the return address and then the function return is pop the return address in the local environ .
so there is the stack there that contain all that inform and whether the function call itself or not is not relev .
the stack contain the recurs .
in fact , you can alwai us an explicit stack to make a recurs program non recurs .
so , thi is so when we have the gcd function , comput the greatest common denomin , greatest common denomin p and q is greatest common denomin of q and p mod q and it just call itself until q get to be zero .
and as thi graphic integr , it just doe it by save the inform on a stack .
now a specif exampl that realli show thi off and also will illustr the util of be abl to process multipl type of data with the same code is thi exampl is dijkstra's two stack algorithm for arithmet express evalu .
so the goal is , you got an arithmet express thi is just actual like a simpl stand in for a program and we'll talk about that in a second but let's sai , arithmet express .
we have operand and oper and you want to evalu it .
and dijkstra's algorithm is veri simpl to express .
you process through the express from left to right .
if you see a valu , you put it , you maintain two stack and if you see a valu , you put it on the valu stack and if you see an oper , you put on the oper stack .
left parenthesi you ignor .
right parenthesi , you pop the oper and two valu and push the result .
now that's a lot of word let's look at a demo .
so we start out with the empti valu stack and oper stack and we're go to move from left to right .
so , and those ar the a top is summar the four type of thing that we could wind up with and what to do so the left parenthesi we've ignor , a valu we put on to the valu stack .
so , that on goe right in to the valu stack .
oper , we put on to the oper stack .
and plu it goe on the oper stack .
left parenthesi you ignor .
it seem strang to be ignor parenthesi and we'll get back to that in a second .
valu , put in the valu stack .
oper , put on the oper stack .
doesn't seem like we're do much except put stuff on stack and now , when we come to our right parenthesi and that's when it get interest .
what it sai is to you have the top oper and the top two valu and that's what you want to do .
suppli that oper to those valu and put the result valu that you get back on to the oper stack .
so , we take off the top two thing , we do the oper and then we put the thing that we get onto the valu stack .
and that's right parenthesi .
so now continu along we put a star on .
left parenthesi , we ignor .
four on , star .
the right goe to the valu stack and now we got a lot of stuff on the stack and we got through right parenthesi and that's go to finish up the comput , take the top two item off the stack and the top oper off the oper stack , perform the oper , put the result back on the valu stack .
anoth right parenthesi , take the top two valu off .
perform the oper .
put the valu on to the valu stack and final , the last right parenthesi , take the two oper of the valu stack , oper of the valu stack , and oper of the oper stack , perform the oper , put the result back on the valu stack .
and we're at the end of the comput and that's the result .
the valu that arithmet express is <num> .
okai ?
yup .
here's the code that implement dijkstra's two stack algorithm .
we have two differ stack .
the operand stack the oper stack is string , it could be charact which is just our oper .
then our valu stack is doubl so that's the same stack code but with gener , we're us , us two differ type of data .
and then simpli perform dijkstra's algorithm .
if we have a left parenthesi . . .
read a new string .
if we have a left parenthesi , do noth .
if we have plu or time , push it .
if we have a right parenthesi , then go ahead and pop the oper .
and if it's plu , add the result of the two valu at the top of the valu stack and if it's a star , multipli the two valu on the top of the stack and , and then push the result .
so and then when you're done then simpli print out the valu on the stack and that's a fine and eleg implement us stack for ani arithmet express .
and it's easi to extend that to handl other type of thing and so , why doe thi work ?
well , when the algorithm encount an oper , sai , in the insid , we got the parenthesi , operand , oper , operand , parenthesi it easi to see that what it go to do insid there is put the at the top of the stack whatev it is , is to put the two and three on the top of the valu stack and plu on the top of the oper stack and when it hit that right parenthesi , it's go to perform the oper and it's go to proce then exactli as if the origin input where that , where the valu replac .
so , just go in from the insid out for everi oper enclos within parenthesi like that it's just repeat the argument that's exactli as if the origin express were on five twenti and then again , replac that on , on <num> , <num> .
that's , that's why dijkstra's algorithm work .
actual fairli easi to understand why it work .
and you can go ahead and extend thi algorithm to add function like log and sine or other oper and have preced among oper , have them associ and multipl oper , and so forth .
and actual that's on the road to develop a compil or a wai to translat a , a program from a program languag to a comput , so dijkstra's algorithm that us stack is on wai for enter and understand of the basi of comput .
okai , what ar the rule that we're go to follow ?
well , let's start with look at a typic basic sort problem .
sai , univers ha student record and for everi student there is a certain amount of inform .
mayb there's a class number , there is a grade , there's a phone number mayb an address so we refer to an item and it ha a record or the inform that we're go to sort .
but in particular , there's a piec of a record call a kei and what we want to do is put the record into order accord to the kei .
that's the sort problem .
re arrang an arrai of n item into ascend order accord to a defin kei which is part of the item .
now , our goal is to be abl to sort ani type of data so let's look at a coupl of client program .
first exampl is to just sort some random real number into ascend order .
so , here's a client that call our insert sort method and all it doe is read number from standard input than into an arrai a then call insert sort and then print them out .
and you can see on the right that the number ar print out in sort order .
thi seem like an artifici kind of input but actual we'll look at an applic even in thi lectur .
and then there ar mani applic where random input ar fine model .
here's mayb a more familiar sort client that sort string .
and in thi case it read the string from a file us our readstr method in our in class that which take a file as argument .
so we take the file name as the first command line argument , read in arrai of string from that file separ by blank , call an insert . sort method again .
so , insert . sort is a method that take an arrai a as it paramet and it , it's the first argument and it rearrang the string in that arrai to be in sort order .
so in thi case word , word three . text ha the certain number of three letter word and thi client program will result in those three letter word be rearrang into alphabet order .
here's anoth client that we could us our sort program for , if we achiev the goal of sort ani type of data .
in thi on , we're go to sort file , file's name in a given directori .
so again we us the file class from java and we us , we go and us the listfil method from that class to get an arrai that contain all the file name in the given directori .
that's an arrai with file name in it and insert . sort take that arrai as it first argument and again sort them and then we go ahead and us as , go through them on by on and print them and thei come out in order of file name .
so that's three differ client , three complet differ type of data .
and the first rule of the game that we have to think about is , how can we make it so that we can implement on sort program that can be us by these three differ client to implement three differ type of data .
in the wai that , that happen is a mechan known as a callback .
so , that's our basic question , how can sort , now , how to compar data of all those differ type without be given ani inform about the type of an item's kei ?
and the answer is that what is we set up a mechan known as a callback or refer to execut code where the client , by pass an arrai of object to the sort function .
in java , there's an implicit mechan that sai that ani such arrai of object is go to have the compareto method , then the sort function call back the compareto method associ with the object in the arrai when it ever need , whenev it need to compar two item .
there's a lot of differ wai to implement callback and that's program languag specif .
differ languag have differ mechan .
it's all about the idea of pass function as argument to other function which is the pair and get into function program and think all the wai back to ture and church .
for java , becaus of the desir to check type at compil time , the us of specif method call an interfac and then , we'll look at the detail of how to implement callback with the java interfac now .
it's a littl bit of program languag detail but it's , it's realli worthwhil becaus it allow us to us the sort that we develop for ani type of data in a type safe manner .
so we alreadi look at some client .
thi is the exampl of the client program that sort the file in a given directori by file name .
so it just call our sort method with a , an arrai some type of object as first argument .
now , built in to java is the so call the compar interfac and all the compar interfac is the specif that a type , data type that implement compar will have a compareto method .
and it's gener and will be compar to against a certain type of item .
now when we implement object that ar to be sort we'll implement the compar method .
that's up in the top class file , implement compar file .
and sinc sort is an oper that's us in so mani situat , mani of the standard java type that you would expect to involv sort will implement compar .
and all that mean is that , that data type ha an instanc method that will implement the compareto method .
it'll compar thi object against the object given as argument and depend on some complic test , it'll return <num> , mean less , <num> , mean greater or <num> , mean equal .
now , that compareto method is realli all that the sort implement need .
first it sai that , that it's go to take as argument an arrai of type compar .
so that mean , the object in the arrai ar go to implement the compar interfac or that it will have a compareto method .
and then the sort code can just us that compareto method , invok in a sens of the object like an entri in the arrai and as argument and anoth instanc in the object like anoth entri in the arrai to test whether the first is less than the second as in thi exampl .
the kei point is that the sort implement ha no depend on the type of data that's handl by the compar interfac and a differ compar arrai will be sort in the same wai though eventu , becaus of the interfac mechan , thei call back to the actual compareto code that goe with a type of object be sort .
now there's a few rule and there's natur rule but thei're worth talk about and pai attent to that the compareto method ha to implement in the so call a total order .
in all that sai is realli that it must be possibl to put item in order in a sort .
so there's three properti .
first on sai that if v is less than or equal to w and w is less than or equal to v then the onli wai for that to be true is if thei're equal and then there's transit .
if v less than w , w is less than x , then v must be less than or equal to x .
in total , is that either v is less than or equal to w or w is less than equal to v or both thei ar equal .
and there's plenti of natur total order in the type of data that we normal want to consid for sort kei .
like the integ or natur number or real number or alphabet order for string , chronolog order for date or time and so forth .
the cartoon on the right show that not all order ar necessarili total order .
so , rock , paper , scissor is intransit .
if you know that v is less that w , w is less than v , you don't know that v is less than or equal to v .
i'm sorri , v is less than w , w less than equal to x that you don't necessarili know that v is less than or equal to x .
all right .
so the compar api then , by convent in java we alwai need to implement compareto such that v that compar to w is a total order .
and also by convent , it return a neg integ for it less zero if it's equal posit it greater .
if thi object is greater than the object given as argument .
if the type ar incompat or if either on is null compareto should throw an except .
now , again , mani of java's standard type for number and date and file and so forth implement compareto by convent .
now if we're go to implement our own type then we have to go ahead and implement the compar interfac accord to these rule .
and usual that's fairli straightforward .
so here's an exampl .
it's a simplifi version of the date class that's implement within java just to show the idea of implement compar .
so , after the class declar , we write implement compar and then we fill in the gener with the same type becaus we're onli go to compar date to other date .
in thi implement , the date class ha three instanc variabl .
the month , the dai and the year and the constructor fill those from the argument as you can see .
so now , if you want to compar two differ date then the first thing to do is to check if thi year is less than that year , over that is the year given , the date given in the argument .
if that's true then it's less return <num> and if it's , the year is greater , return <num> .
otherwis , the year , year must be equal so we have to look at the month to do the compar and so forth down to do the dai .
onli if thei're all equal that we return zero .
so , that's an exampl of an implement of compar by implement the compareto method to put date in order as you might expect .
so the java languag help us with thi compar mechan so that we can sort data of ani type .
when we continu to implement sort algorithm , we're actual even in a hide that beneath our own implement .
so , that ar sort algorithm actual their actual code can be us to implement sort in mani other languag .
the wai we do that is to take the two primari oper , compar and exchang that were that were , were us to refer the data and encapsul them just the static method .
so , we're go to us a method less that take two compar object as argument and it just return , v . compareto w less than zero .
and then the other thing that we do when we sort item that ar in an arrai is to , to swap or exchang of the item at a given index i with the on at a given index j .
and that's everi programm's first introduct to assign statement .
we save a in a variabl swap , put a in a , and then put swap back in a so now our sort method to refer the data will just us thi two static method .
and there's a good reason for that .
here's an exampl .
suppos we want to test if an arrai is sort .
so thi is a static method that is suppos to return true if the arrai is sort and fals if it's not .
and all it doe is just go through the arrai from the on to the length of the arrai and test if each item is less than the on befor .
if you have an item that's less than on befor then it's not sort you return fals .
if you get all the wai through the arrai without that happen , then you sai the arrai is true .
that's pretti simpl code , the question is , if you have a sort algorithm that pass that test , ar you sure that it correctli sort the arrai ?
well the answer to that question is , ye if , ye if you us onli the less and exchang method to implement , to refer the data becaus then you know becaus you us the exchang method that the data in the arrai after the sort is the same data as wa in the arrai befor the sort , sort .
if you have a sort method that can store ani valu in an arrai , it could , for exampl , store zero in everi arrai entri that method would pass thi test , but it didn't realli correctli sort the arrai becaus overwrot all the valu .
so , we us less and exchang to be sure that we can test that our , our method work with the method like thi .
the first elementari sort method that we're go to take a look at is an easi method known as select sort .
the idea of select sort , is start out with a unsort arrai and we'll us these plai card as an exampl .
and in the ith iter , we go through the arrai to try to find the smallest remain entri , in thi case , the <num> is the smallest from ani entri .
and then we'll swap that with the first entri in the arrai and then we know we've got on step done .
select sort is base on iter that idea .
okai .
so , the basic select sort method is to , in the ith iter , find the smallest remain entri and to the right of i or bigger index than i and then swap that with i .
so , we start out i is at the left end and then the remain , all the remain entri to the right .
we scan through and the smallest on is the two , three entri from the right so we swap that .
so that's the first step .
now , that part of the arrai to the left of i is in it's final order and we simpli continu .
so now , the smallest is the three .
swap that with i , increment i .
so now , we have the two and three in order , continu that wai .
find the smallest , the four .
swap that on with i , increment i .
find the smallest , it's five , swap that with i , increment i .
find the smallest , swap that with i , increment i .
each time we have to scan through all the remain entri in order to find the smallest .
but then , onc we found it , we onli have to swap two card those ar both kei properti of select sort .
now the eight is the smallest and we swap .
and now , we know thei're in order but the program doesn't so we have to look and decid that i and n ar the same and then it swap it with itself and doe the same thing for the last .
and so , after that process , then we know that the entir arrai is in it final order , all sort .
all right .
so let's , on wai to understand the wai that an algorithm work is to think about invari .
so , for the select sort , we have a pointer that wa our variabl i , that scan from left to right .
now , it's indic by a littl red arrow in thi represent .
the invari ar that the entri on onto the left of the arrow ar never chang and thei're in ascend order .
no entri to the right of the arrow is smaller than ani entri to the left of it .
that's the wai that we set it up .
and the algorithm maintain those invari by find the smallest entri to the right and exchang it with the next on .
so the code implement the invari .
so , to move the pointer to the right , we increment i .
so , now the invari might be violat so we have to fix it .
it might be violat becaus you might have an element to the right of the pointer that is smaller than some , the element on the pointer .
so , what we have to do is identifi the index or that minimum entri and exchang it .
then onc we've exchang it , again , we preserv our invari .
after that point , no element to the left of the pointer is go to chang and all the element , there's no smaller element to the right .
and that give us immedi our code for the select sort implement .
we identifi the , the length of the arrai that's n .
then we have a for loop that goe through everi element in the arrai , we keep a variabl min in that is the index of the go to be the index of the smallest element to the right of pointer i .
we have an inter for loop that for j , if it find a smaller on , reset min and then onc we've look at all the element to the right of i we exchang the smallest on with i .
that's a complet implement of select sort .
now it's easi to develop on mathemat model for the cost of select sort and here's the proposit that describ that .
select or us about n <num> <num> compar and exactli n exchang .
and just look at thi trace of select sort and oper realli is a proof , visual proof of thi proposit .
in thi diagram , the entri in black , ar the on that ar examin in order to find the minimum each time with the minimum in red .
entri in grai ar not touch , thei're in their final posit .
well , you can see that thi isn't go to be in gener an n by n squar and about half of the element in the squar ar black or about n <num> <num> and you can see also the exact formula n <num> n <num> and so forth is the total number of compar us .
and then on each of the ns valu of the variabl i there's an exchang so that's the cost in term of the number of exchang .
now , what's interest about thi proposit about select sort is that , it doesn't matter what order the input is .
select sort is go to us quadrat time becaus it alwai ha to go through the whole thing to look for the minimum .
and anoth properti is that you can't sort move less data becaus select sort doe just a linear number of exchang .
everi item is put in to it's final posit with just on exchang .
let's look at an anim of select sort in oper .
you can see our pointer move from right to left everi time it find the smallest element to the right , it exchang it into posit .
now , if the arrai is partial sort , it doesn't matter to select sort .
still ha to go through , even if it's total sort , still ha to go through to the side where that minimum element is .
that select sort , our first elementari sort method .
now , we look at insert sort which is anoth elementari method and interestingli ha quit differ perform , characterist than select sort .
let's look at a demo of insert sort .
for insert sort , what we're go to do is we'll move an index i from left to right as befor .
but now , in the ith iter we're go to move a i into posit among the element to it left .
let's look at how that work on our exampl with card .
so now we start by initi i to first card and we take the idea that everyth from i to it left is go to be sort and everyth from the right , we're not go to look at , at all .
so , everyth to the left of i is in ascend order everyth to the right we haven't seen at all yet .
so now , when we increment i , well , in thi case it's alreadi an order , we don't have anyth els to do .
in the third case now , when i at the third entri in the arrai .
now , we start a index j and we move that start at i to the left and what we need to do is just exchang the five with everi element to it left that's greater .
so , first we exchang it with the ten .
it's still not in place so we exchang it with the seven .
now , we get to the begin arrai , of the arrai and onc we've done that or we've hit a smaller element then we have everybodi to the left of i in order .
so now we increment i again and we come to the three .
again , we exchang as long as the card immedi to the left is greater .
and onc we've done that , then we have everyth to the left of i in ascend order .
now , in thi case , we have the eight and we onli have to exchang on and now , it's got the seven to it left and everyth is in order .
so , we've achiev put it in order with less work in thi case .
we don't alwai have to go all the wai back to the begin .
for exchang it with everybodi to it left that's greater , until we find a smaller element done in it ascend order .
two ha to go all the wai back to the begin ning but then the veri next on , the nine , ha to onli go back on posit .
and the sixth ha to go about halfwai back .
and then , we have the entir arrai sort .
again , we can look at insert sort in term of invari .
our pointer still scan from left to right but now , the element of the left of the pointer , includ it , ar in order .
but the element to the right have not yet been seen at all .
so , we have to look at the code that's go to maintain that invari as the pointer increment .
move the pointer to the right , it's increment again .
now , the invari is broken becaus the element the element on the pointer is not in sort order to put it in sort order , we have to move from right to left exchang it with everi larger element to it left .
and that's with the code at the bottom doe start j at i and decrement j exchang j with the element to it left .
a j with the element to it left , a j on as long as a j is less than a j on or j is bigger than zero .
and that immedi give the , thi code for insert sort which is similar to our code for select sort and just as simpl it get two nest for loop .
select sort head to nest four loop a test to comparison and an exchang insid the four loop .
and that's a fine implement of an elementari sort method .
what about the analysi of insert sort ?
it's more complic .
our proposit sai that insert sort to sort randomli order arrai with distinct kei , it'll us about on fourth n <num> compar and about the same number when on fourth n <num> exchang on the averag .
thi is more complic to prove .
it depend on the arrai be randomli order .
and again , you can get a feel for where the proposit come from by look at thi n by n trace .
again , the black element ar the on that we compar and actual , there ar also the exchang .
and the red on is the on that's final put in to place .
and you can see t hat for a larg arrai that's randomli order , the element that we put into place is go to go about half wai back on the averag .
so , that mean about half the element below the diagon ar go to black on the averag cuz n <num> two below the diagon , half of that is n <num> four .
the analysi , exact analysi is not much more detail than that .
thi is a bigger trace that show again , about half the element below the diagon or involv in the sort .
let's look at in the anim .
sinc n <num> four versu n <num> two , insert sort is go to be about twice as fast as select sort .
so , we can do about twice as mani item in the trace in the same amount of time .
it grab an element , bring it back into posit , everi time .
so , it's an anim for randomli order item .
now insert sort doe depend on the initi order of the data .
let's look at the best case and the worst case which ar certainli outlier .
if the arrai happen to be alreadi sort all insert sort doe is realli to valid that each element that's got a smaller element to it left so it doe no exchang and it get the sort job done with just n on compar .
on the other hand , if the arrai is in descend order n is no duplic , then everi element goe all the wai back .
it make n <num> two compar and n <num> two exchang .
so in the first case is much , much faster than select sort linear instead of quadrat .
in the second case , it's slower than an select sort cuz it us about the same number of compar but it us mani more exchang .
so , let's see that in the anim .
so , thi is when the item come in , in revers order .
now , everi time it , it get a new item , that's to exchang it all the wai back to the begin .
same kind of dynam characterist is select sort except for everi step , iit's not just compar , it's also exchang which make it even slower in practic .
so , thi is the bad case that we wouldn't like to see in th e practic applic but there's also a good case that actual we take advantag of in plenti of practic applic .
and that ha to do with when the arrai is partial sort .
to talk about thi in a quantit wai , we defin what's call an invers .
an invers is just a pair of kei that ar out of order in the arrai .
so thi arrai ha six invers , t and r ar out of order cuz r should go befor t .
t and p ar out of order and so forth .
thi arrai ha six invers .
and we defin arrai to be partial sort if it number of invers is linear , if it's less than some constant time n .
and partial , sort arrai appear often in practic .
for exampl , if you have a larg arrai with just a few that's sort except for just a few unsort element append at the end it's go to be partial sort .
or anoth case is if you onli have a few entri out of place , the arrai is go to be partial sort .
these type of thing rise often in practic applic and what's interest about insert sort is that it run in linear time for partial sort arrai .
and the proof is the number of comparison and the number of exchang is equal to the number of , number of exchang is equal to the number of invers and then there's an extra compar for everi element except the first .
so , let's look at how that look in the anim .
here's a partial sort arrai and you can see that insert sort quickli get the job done .
we're go to take advantag of thi in a littl bit later in thi lectur .
now , we'll look at shellsort which is a bit elementari on the face of it but it's not at all elementari as you'll see .
the idea of shellsort is that insert sort is ineffici becaus element realli move onli on posit at the time even when we're kind of know that thei have a long wai to go .
the idea behind shellsort is that we'll move entri sever posit at a time and the wai we're go to do it , it's call h sort the arrai .
so , an h sort arrai is h differ inter leav sort sub sequenc so in thi case with h <num> if we start at l and look at everi fourth element m , p , t then it's sort .
if we start in the second place at e and look at everi fourth element , it's sort .
so thi is <num> interleav sequenc , that's a <num> sort arrai .
and what we're go to do is implement a sort method that h sort for decreas sequenc of valu of h .
thi is on of the oldest sort method invent by shell in <num> .
so , in thi case , it start out with the input exampl shown and then the <num> sort a few item ar move , <num> sort a few more ar move , and then final , a <num> sort .
and the idea is that each of the sort can be implement with onli a few exchang given that the previou on happen .
so first thing is how do we get an arrai h sort ?
that's actual pretti easi .
we just us insert sort but instead of go on back everi time we come with a new item , we go h back .
so for exampl when we come to thi a in the insert sort , then it's , we look at the arrai befor that and then there wa m and e in the posit three back so we exchang the a with the larger on to it left , that's m and then the other larger on to it left , that's e and then put it into posit .
so the code is the same as insert , as for insert sort , except that when we go backward through the arrai we skip by h instead of just by on .
that's how we h sort an arrai .
and the idea is we're go to us insert sort becaus of two reason base on our understand of how insert sort work .
while the first thing is if the increment ar big then the size of the sub arrai that we're sort ar pretti small so ani sort method includ insert sort is go to work well .
but the other thing is if the increment ar small becaus we've done previou h sort for bigger valu of h , the arrai is partial sort and so insert sort is go to be fast .
you wouldn't work to us shellsort as the basi for h sort becaus that alwai take quadrat time no matter what order there is in the arrai .
so let's look at exampl of shellsort with increment <num> , <num> , and <num> .
so , we start with thi sort exampl and then <num> sort it just involv do insert sort but just reach back <num> each time .
in thi case , the <num> subfil stretch out at seven each onli have two element in them .
and then we <num> sort .
now , becaus it's <num> sort and a <num> sort element ar either alreadi in place or on a go back a few stride .
on thi case , it's onli the a that goe back two .
and then we <num> sort and again becaus of the fact that it's been <num> sort and <num> sort , the arrai ar almost in order when it come time to do the <num> sort and most of the item onli go back on or two posit .
so we have to do a few extra pass to do the higher sort but the each element move onli a littl bit on each path and that's how shellsort gain it effici .
so actual onc you <num> sort , that's insert sort so you're go to alwai get a sort result .
the onli differ is how effici is that .
now the intuit behind shellsort and actual the mathemat fact is that if you've got an arrai that's h sort and then you k sort it for anoth valu k differ from h , it's still h sort .
thi is on of those mathemat fact that seem obviou but then if you try to prove that mayb it's a littl more subtl than you think .
so , if you think of all thi is , is , is trivial and easi , go ahead and try to write down a proof that a g sort arrai remain g sort even after it's h sort .
but most peopl will accept that and it's a fact and that's how shellsort gain effici .
now there's anoth problem is what increment sequenc should we us for shellsort .
on of the first thing you might think of is let's try power of two .
actual that on doesn't work at all , veri well at all becaus it wind up not compar element in even posit with element in the odd posit until the <num> sort which mean perform can be bad .
shell's origin idea is to try power to two minu on and that work okai .
knuth when he wrote hi book in the 60s propos the increment sequenc 3x <num> .
we'll start with the <num> , <num> , <num> , <num> , <num> , <num> like that and that's good becaus it's easi to comput .
when we're us in shellsort of cours , we find the largest increment less than our file size and then do the sort for decreas valu of that increment .
but find the best increment sequenc is a research problem that ha confound peopl for quit a long time .
here's an increment sequenc that i found after mayb a year's work and it work well but nobodi know if that's the best on .
so here's the implement in java of shellsort for knuth's 3x <num> increment sequenc .
we'll just go ahead and comput the increment that ar less than n , n <num> and then start at that increment whatev it is and sai , we start <num> then next time we need an increment , we'll just divid it by <num> , <num> integ divid by <num> , <num> integ <num> it get <num> , <num> and so forth .
so , thi h h <num> get us to the next increment .
and then , the implement is just insert sort .
we just go through start at h for i and when we do the insert , the j loop , we decrement j by h each time , otherwis the code is exactli like insert sort .
so , just ad thi extra loop for h sort and thi extra loop to comput the increment to insert sort , we get a slightli more complic piec of code but it much , much more effici .
here's what it look like for a bigger arrai .
we start with the randomli order input and you can see that it get more and more in order on each time that we h sort for the decreas valu of h .
here's an anim .
thi anim doe the whole h sort for each subarrai .
it's a littl better feel for what's go on .
and now to do the high on pretti quickli and now it's do the <num> sort and again it step through the arrai pretti quickli .
if it's partial sort it doesn't make much differ doe the higher sort a littl bit faster .
but that's simpl to implement and veri effici sort algorithm .
now , the analysi of shellsort is still open .
now , there's a few thing that we can sai .
for exampl we can sai that the number of comparison and the worst case is o n3 <num> for the 3x <num> increment .
but actual in practic it's much less than that .
the problem is nobodi know an accur model for describ the number of compar taken by shellsort for ani interest increment sequenc .
thi seem to be with a small valu , multipl of n time the number of increment us which is some multipl mayb of n log n but nobodi is been abl to find an accur model that prove that for ani interest increment sequenc for shellsort .
so , why we ar interest in thi algorithm ?
well , it's a simpl idea that lead to substanti perform gain .
it's veri us in practic becaus it's pretti fast except for veri huge arrai .
it's go to beat even the classic sophist method for medium size arrai .
and it doesn't take much code .
it's often us in embed system or in hardwar sort type system becaus there's so littl code involv to implement it .
and it just lead to a lot of interest question .
thi get to the intellectu challeng of develop algorithm .
if you think what we've been studi so far is trivial , go ahead and find a better increment sequenc .
try some techniqu to discov on and try to sai someth about the averag case perform of shellsort .
peopl have been try to do that for <num> year without a whole lot of success .
so , the lesson is that we can develop good algorithm or good implement without much code but there ar some out there that ar still wait discoveri .
it could be that there ar some increment sequenc out there that make shellsort more effici than ani other method , ani of the sort method that we know for pratic file size , no on can deni that .
that's shellsort or first non trivial sort method .
next we're go to look at an easi applic of sort to relat problem call shuffl .
so , suppos you have a deck of card .
on of the thing that you might want to try to do is to simpli rearrang those card into random order , that's call shuffl .
here's a wai to get shuffl done us a sort and seem like the opposit .
the idea is , just gener a random real number for everi arrai entri and then sort us those random number as the kei .
that's an effect wai to get thing shuffl .
and it's possibl to prove that , that produc a uniformli random permut of the input if there's no duplic valu , assum that you have a real number that ar gener uniformli at random .
and that's just mean that it's well shuffl that everi possibl wai of shuffl the deck appear with the equal probabl .
that's fine but it requir a sort and a sort seem like a lot of work for thi problem and the question is , can we do better ?
can we have a faster wai to shuffl ?
do we realli need to pai the cost of a full sort ?
the answer to that question is , no .
there's actual a veri easi wai to rearrang an arrai so that the result is a uniformli random permut .
it onli requir a linear time to get the job done .
let's look at the demo .
the idea thi to pass through the arrai from left to right with an index i as we've been do but now we start with the arrai in order .
and actual , it doesn't matter how we start the arrai and everi time we pick an integ between <num> and i uniformli at random and , and swap a with that integ .
so , let's look at the begin , we don't do anyth just swap it with itself .
now , with i <num> or i point to the second card we gener a random integ in between <num> and i , in thi case it's the on to the left and we swap those .
increment i , gener a random integ , thi time it's go to be the first on again , swap them .
increment i , gener a random integ , swap them .
increment i , gener a random integ , swap them .
and continu in that wai .
swap .
so for everi i , we do exactli on swap .
now , card could be involv in more than on swap but that's not an issu .
the point is that the card to the left of i ar shuffl there uniform , randomli shuffl .
on thi case , i and r ar the same .
there's no swap .
increment i , gener a random r , swap them .
and at the end we have the deck shuffl .
that's a linear time shuffl algorithm make us of random .
it wa prove through actual a long time ago even befor comput implement that if you do that , you get a uniformli random permut and it onli take linear time .
so , that's definit a wai to get a deck shuffl quit easili .
easi to implement .
now it's kei that the uniform random number will be between <num> and i <num> .
you'll often see programm think that thei're implement a shuffl and thei just choos for everi entri , thei just choos random place in the arrai to exchang it with and that doesn't realli work .
you could do the item between i and n <num> , the on that you haven't seen yet and that would also work but do a whole arrai doesn't give you a uniformli random result .
so , with that on caveat , thi code is almost trivial .
and it's a method in our standard random class .
now if you're go to be us random method that depend on random in real applic , you do have to be care .
so thi is just an exampl about softwar secur .
there's a lot of difficult and deep issu to worri about and so for our secur and we're not go to worri about all of them .
but on thing that we can do is make sure that our algorithm work as advertis .
so , here's an exampl of an implement for onlin poker .
here's the code that you can find on the web for how to shuffl a deck of card and that's pretti similar to our code but it's actual got a few bug , more than a few bug .
so first on is the wai that random work it's actual never get to <num> which mean that the last card just stai it can end up in the last place .
so , it's definit not shuffl becaus of that .
mayb that on's minor but it also is pick a random card from the whole deck as we just point out that's not uniform .
should be between <num> and i or between i <num> and <num> .
anoth problem is in thi implement that the random us just a <num> bit seed that if you do that , there's not enough possibl shuffl .
the number of possibl shuffl is , is , is much more , if n , if n is <num> , it's <num> factori which is a lot bigger than two to the 32nd .
so , it's not close to a random or uniform .
and the other thing is that , the seed is just a number of millisecond sinc midnight and that cut down the number of shuffl even more .
and in fact , it didn't take that much hack for someon to realiz that after see five card and figur out what the server clock wa do , you could get all the futur card in a real time in a program .
and that's a pretti tough thing to have happen if you're implement onlin poker .
you might want to make sure that if you're advertis that you're do a random shuffl , that you go ahead and do so .
and the famou quot in thi mani similar quot , the gener of random number is too import to be left to chanc .
so , if your busi doe depend on shuffl peopl have look at all sort of option includ us hardwar random number gener and these variou test avail to make sure that it's random and you'd better us good shuffl code that's our topic but the bottom line is don't think that it's easi to shuffl a deck of card .
so that's shuffl our first non trivial sort applic .
now we'll look at an applic of sort from the field of comput geometri for an interest comput .
if you have a set of n point in a plane .
there's a geometr object call the convex hull which is the smallest polygon that enclos all the point .
there's the convex hull for that set of point .
there's a lot of equival definit of thi .
some of them veri mathemat , that extend the higher dimens .
it's the smallest convex set that contain all the point , the smallest area of convex polygon enclos the point .
it's a convex polygon that enclos the point whose vertic point in the set and those ar all equival definit .
and what we want to do is given the set of point , we're go to have a program that can give us the convex hull .
now , which should the output of such a program , such a method be ?
well , in order to be abl to work with the result , it should be a sequenc of vertic that give us that polygon if we follow it .
if we've got some point that ar on the boundari but aren't realli vertic thei shouldn't be includ .
thi point out exampl of how difficult comput geometri can sometim be becaus degener case like these ar difficult to deal with in code .
we're not go to spend a lot of time on thi , in thi lectur .
but it's someth alwai to be awar of when try to appli simpl algorithm in situat like these that turn out to be mayb more sophist than we might think .
the larg screen .
oh yeah , got you .
mm hm .
well , there's actual a wai to comput the convex hull just mechan if you put the nail around the point and put a rubber band around it , that give you the convex hull .
now , we're not go to be abl to realli implement that in a comput program but it's surpris how well we can do .
here's an applic where peopl want to comput the convex hull .
suppos you have a robot that want to get from s to t and there's an obstacl that's defin by some polygon .
you want be abl to go around the obstacl and it turn out that the shortest path , either it's a straight line from s to t or it's part of the convex hull and is not hard to see why that might be true .
and there's plenti of other applic where peopl want to be abl to comput the convex hull .
here's anoth applic .
if you want to find the pair of point that ar the farthest apart in the set of point in the plane , thi is sometim import in statist calcul or other applic .
thei're on the convex hull .
if you have the convex hull , thi comput is easi .
thei're , thei're go to be extrem point on the convex hull .
so , there's a lot of geometr properti of the convex hull that we can take advantag of to develop an algorithm .
in here two properti .
now , these ar the thing that have to be proven and we're not go to get into the detail of geometr proof but thei're intuit and certainli have no troubl accept that these thing ar true .
on thing is , that you can travers the convex hull by make onli counter clockwis turn or left turn if you're look at the screen here .
and the other thing is that , so if we travel from p to point <num> then we make a left turn to go to point <num> or counterclockwis turn and then from there , we go to point <num> and <num> and then we eventu get back to the start point .
the other thing is , if you take the point with the lowest y coordin .
and then if you look at the polar angl with respect for everi other point with the respect to that on , so the angl you get from of the x axi through p up to the point , then the vertic appear in increas order of that angl .
and again , that's not , not difficult to see that that's a fact .
and the algorithm that we're go to look at , call the graham scan is base on those two fact .
it's , the idea is to start with point p , the on with the smallest y coordin .
sort the point by polar angl with p where that is we're just go to consid in that order .
and then we'll just throw awai the on that do not creat a counterclockwis turn and you'll see how that work when we look at the demo .
so we start at point p .
sort the point by polar angl with p so that is if we take a , a vertic line and sweep it in a counterclockwis direct , what order that we hit the point ?
the first thing we hit is <num> , <num> , and then we sweep counterclockwis , we get the <num> and then <num> and <num> and so forth .
so , that's the order of those point .
and so now we'll just consid those point in order and then take them for the convex hull .
at the begin , <num> ><num> is a line that's on the convex hull .
so , the point with the lowest y coordin on the convex hull and show the on that is the smallest polar angl that creat with the x axi .
so now what about thi on <num> ?
is that on the convex hull ?
well , as far as we know at thi point , it could be , it could be that the thing is a triangl and <num> is the last point in which case it would be .
but in same with <num> .
as far as we know , that on could be on the convex hull .
but as soon as we go out to <num> that's not a counterclockwis turn .
it's go the wrong wai and essenti what thi mean is a point <num> is evid that point , there is no wai the point <num> can be on the convex hull .
you can convinc yourself with that quit easili .
so we just throw a point <num> out .
it's not on the convex hull so , and what about the angl from <num> to <num> to <num> ?
that's not counterclockwis either .
it's turn the wrong wai and it's turn to the right .
so point <num> can't be on the convex hull either .
and inde if you just draw the line from <num> to <num> , you can see the <num> insid so there is no wai it could be in the convex hull .
now that's essenti the proof that you have to have a counterclockwis turn .
so now , we go on to <num> turn the wrong wai .
so , point <num> can't be on the convex hull .
so now we go to <num> .
as far as we know , it could be , but as soon as we hit <num> , we know that it can't be cuz that's a right turn .
so <num> is not there .
go to <num> , nope .
<num> can't be on the convex hull .
go to <num> .
<num> can't be on the convex hull .
now we go to <num> and <num> .
as far as we know thei could be .
if <num> weren't there , thei would be .
as soon as we hit <num> we see that <num> can't be on the convex hull and <num> can't be on the convex hull and that complet the comput of the convex hull with the graham scan .
okai .
so , there ar number of implement challeng for the graham scan and we're not go to go into detail on thi becaus thi is a lectur on sort algorithm not comput geometri but it is indic of how , even if we have a good sort , we might have to do some extra work to actual solv our problem in an applic .
so , how do we find the point with the smallest y coordin ?
well you could , you could sort , you could defin an order and compar the point by y coordin so essenti sort is the answer to that question .
and we'll look at the next lectur of what it mean the divin order among object , littl more gener than what we do for sort .
how to sort the point by polar angl ?
well again we need to defin what we mean when we're compar point .
and then the next lectur again we'll look at wai to defin differ order among point and graham scan is a perfect exampl .
we don't want to just be abl to sort thing , we don't want to just be abl to sort them by defin and compar to .
we're go to be abl to sort the same thing in differ wai sometim and thi exampl is a fine motiv of that .
figur out whether what we have is a counter clockwis turn that's a littl exercis in geometri and we'll just talk about that briefli in the next coupl of slide .
and then wow , what ar we get the sort effici , done effici ?
well , we could us shellsort but actual in the next coupl of lectur and we'll look at classic sort mergesort and quicksort that we could us .
the idea though is that thi exampl illustr that good sort algorithm give us a good convex hull algorithm .
that's an extrem import principl in design good algorithm .
onc we have a good algorithm , if we have anoth problem we can sai to ourselv , well , we've got a good solut to thi algorithm , can we us that solut to solv our new problem ?
convex hull , when we have a good sort algorithm , it give us a good convex hull algorithm .
becaus the main , the most work in convex hull is the sort .
and then again there's all , all kind of difficulti in implement convex hull in real world situat becaus of variou degeneraci .
and these thing ar cover on the book site .
so the main part of comput that we haven't realli talk about and we'll cover briefli is if we have three point , a , b and c , and you go from a to b to c , ar you make a counterclockwis turn or not ?
so , in the exampl at the left , a to b to c is counterclockwis .
exampl at the right , a to b to c is not counter clockwis .
go from a to b you turn left to get to c in the first case and you go right to get to c in the second case and we want to do a comput that distinguish thi .
now , thi comput will be pretti easi except for the degeneraci .
what do you want to count if thei're all on the same line .
or if the slope is infin .
so , you have to just be awar that these situat have to be dealt with .
so , the code isn't quit as simpl as you might come up within the first instanc that you try .
so , there's degeneraci to deal with and float point precis but peopl , research in comput geometri have work thi out and actual there's not that much code at all in the end involv .
the and thi is the slide that , that give the math and i won't talk through thi math .
if you're interest in implement thi , you can come back to the slide .
and it's essenti base on the idea of comput the slope of the line between a and b , between a and c and compar them to decid whether you're turn counter clockwis or clockwis .
and thi is the specif math that get that implement .
so thi is if we implement a point data type for comput geometri , you can have a method ccw that just with thi littl math calcul b . x a . x c . y a . y minu b . y a . y c . x a . x and we see that calcul here give you immedi whether it's counter clockwis , clockwis or co linear .
not much code at all .
and that method is the basi for the graham scan .
the graham scan us a sort where we give two differ wai to sort the point .
and that us a push down stack for the hull , it put the point on the hull in it goe ahead and for everi point consid i'm in the order of the polar sort it'll compar whether the top two point on the hull and the new point implement a ccw turn or not .
and if it's not a ccw turn , it pop and then continu go .
veri littl code to implement the convex hull given that you have a sort and that's our main point for thi lectur there is mani natur applic of sort but also will be abl to develop new algorithm that us sort that gain effici becaus of the effici of sort .
welcom back .
todai we're go to look at mergesort , which is on of two classic sort algorithm that ar critic compon in the world's comput infrastructur .
we have a full scientif understand of the properti of these algorithm , and thei've been develop as practic system sort and applic sort that have been heavili us over the past <num> year .
in fact quicksort , which we'll consid next time , wa honor as on of the top <num> algorithm of the 20th centuri in scienc and engin .
on thi lectur we're go to look in mergesort , which is the basic sort in plenti of differ program system includ java .
next time we'll look at quicksort which is also us in java for differ applic .
all right , so basic mergesort algorithm .
what's it go to look like ?
the idea is veri simpl .
what we're go to do is divid an arrai into two halv .
recurs , recurs sort each of the halv .
and then merg the result .
that's the over view of mergesort .
it wa actual on of the first non trivial algorithm i implement on a comput .
john von norman realiz that the develop of the edvac , hi edvac comput , on of the first gener purpos comput that is go to need a sort method and he came up with mergesort .
he's wide accredit as be the inventor of mergesort .
so the idea of mergesort is , is base on the idea of merg .
and so to understand how merg work we'll think about the idea of an abstract in place merg .
so , we've got an arrai a and it first half is sort and it second half is sort and the comput we need to perform is to replac that with the sort arrai where those two sub halv ar merg togeth .
let's look at a demo .
the method that we're go to us is base on take an auxiliari arrai to hold the data .
thi is a , on of the easiest wai to implement the merg .
so the first thing we do is copi everyth over to the auxiliari arrai .
now , onc that's done , what we'll want to do is copi back to the origin arrai to get it in sort order .
in order to do that , we're go to maintain three indic .
i , the current entri in the left half , j , the current entri on the right half and k , the current entri in the sort result .
so the first thing we do is , take the smaller of the two entri point to by i and j , and compar those , and take the smallest on , and move that on to be the next item output .
and whichev on is taken , we increment it pointer .
now we compar the minimum again , again , the on point group by j is smaller , so we move that on to k .
increment that pointer j and also increment k .
now there's two e's , equal we alwai take the first .
so the on on the left arrai goe to k's posit .
and now we increment i and k .
and again , it's an e and thei're equal .
we'll take the first on so we move that on up increment i and k .
and now j's e is smaller than g .
it's the next thing that ha to go in the output .
so we move that on up and increment j and k .
now the on point to my i , the g is smallest so move that and increment i and k .
move the m up and increment i and k .
now the last element in the left sub arrai is the on that's go to get move next .
and now that first subarrai is exhaust so realli all we need to do is take the rest of the element from the right part and move them back in .
actual sinc we copi , we could optim by avoid these move .
that's an abstract in place merg for take the two sort sub halv of an arrai us an auxiliari arrai , move them out , and then put them back in in sort order .
all right , so here's the code for merg , which is quit straightforward from the demo .
we first in order to sort an arrai of compar in thi implement we pass a link to the auxiliari arrai , in as well .
and we have three argument lo , mid , and hi .
so lo is the first part of the arrai to be sort .
mid's the midpoint that divid the first part from the second , so our condit ar that from lo to mid is sort , and from mid plu <num> to hi is sort .
so the merg implement then , the first thing it doe is copi everyth over to the auxiliari arrai .
and then that set up for thi four loop that accomplish the merg .
we start our i pointer at the left heart on the left half .
the j pointer on the left part of the right half .
that's mid plu on .
and we start the k pointer at the begin lo .
and for everi valu of k what we're most often do is compar whether aux of j is less than aux of i .
and if it is , we move the element of j over in increment j .
if it's greater we move the element i over in increment i .
and then in both case , we increment a , not impl , increment k , and that implement the merg .
if the i pointer is exhaust , then we just move over the j , next jth element .
if the j pointer is exhaust we move over the next ith element .
so everi time we're move a new element into k and that's the code that impel the abstract in place merg .
now with thi code , we're also introduc the idea of make assert just to make it easier to debug our code and to have confid that it's correct .
in thi case , thi insert just sai we want to be sure that a of lo to mid assort and that mid plu on to high is sort befor our code and then we want to check that , the whole thing is sort after our code .
and gener programm , java programm know that it's a good idea to try to do these assert .
not onli doe it help detect bug , but it also document what the code is suppos to do .
and that merg code is a good exampl of thi .
if you put at the begin of the code what you expect in the , in the form of an assert , which is code itself .
and you put at the end of the code what you think it's go to do , again in the form of an assert .
you're both test that these condit hold , and also tell someon read the code , what you're try to do with it .
so java is just an assert statement .
it take it , boolean condit .
in thi case , we're us that method is sort that we were befor .
that return true if the port is sort and fals if it's not .
and what assert will do is it will throw an except unless that condit is true .
now the thing about assert in java is that you can enabl or disabl them at runtim .
and that's realli import , becaus it mean you can put them into your code to check while develop .
but it doesn't incur ani extra cost at all in product code .
so by default , insert ar disabl .
someth goe wrong somebodi analyz the situat can enabl insert and thei often will help find out where , what the problem is .
so , the best practic is to us insert just as we did in that exampl with merg and to assum that thei're not go to be there in product code .
you shouldn't us them for the thing like check if the input is the wai you like it .
all right , so with that merg implement , then the sort implement is a quit simpl , recurs procedur shown here .
so we us the merg procedur we just show , and then our sort procedur .
it's recurs so , check that we have someth to do first .
then it comput the valu of the midpoint same wai as we did for a binari search .
sort the first half .
sort the second half , and then merg them togeth .
and then the actual sort is take just the on argument of the arrai creat the auxiliari arrai and then us that .
now , it's import to not creat the auxiliari arrai in the re in the recurs routin becaus that could lead to extens cost of extra arrai creation .
and you'll sometim see mergesort perform poorli becaus of that bug .
otherwis thi is a veri straight forward implement .
and it's actual a prototyp for algorithm design that we'll see come up again and again .
it's call divid and conquer .
solv a problem by divid it into two halv , solv the two halv , and then put the solut togeth to get the appropri answer .
here's a trace of what mergesort doe and if you haven't studi a recurs program befor it's worthwhil studi thi thing in , in some detail .
thi give exactli what happen dure each of the call to merg .
we start out with a big problem to solv but we divid it in half , then we divid that on in half , and then we divid that on in half .
and the veri first thing that we actual do is just compar and exchang if necessari the first two element .
and then we do the same thing for the next two element .
then merg those two togeth to get the first four done .
and then we do the same thing for the next four in the arrai .
so now we have two sort sub arrai at size four .
and we merg those togeth to get on of size eight .
and then we do the same thing on the right , and eventu we have two eight that we merg togeth to get the final result .
veri instruct to studi thi trace to realli understand what thi recurs algorithm is do .
so now we can anim and again mergesort's more effici , so we can do more and more item .
you can see it's got the first half sort , now it's work on the second half .
and then onc it get the second half sort , then it's go to go ahead and merg them right togeth to get the sort result .
it's got a littl extra dynam in the anim becaus of the auxiliari arrai .
let's look at it when it's in revers order again it get the first half done now it's work on the second half onc it get the second half done then it goe ahead and merg togeth the whole thing it's just as fast in revers order as as in auditori order .
so you can run a mergesort on huge problem .
it's a veri effici algorithm .
and so , for exampl , what thi tabl show , if you were to try to us a insert sort for a huge file , sai a file with a billion element , on your pc it'd take a few centuri to finish .
even on a super comput , if you're us insert sort nowadai it'd mayb take a week or more .
but if you have a good algorithm like mergesort , and you're try to do a billion item , you can do it in just less than half an hour on your pc .
and a supercomput can do it in an instant .
and smaller problem onli take an instant even on your pc .
so you can spend a lot of monei or a lot of time , or you can us a good algorithm .
and that's on of our main theme in thi cours .
a good algorithm is much more effect than spend monei or time wast monei or time us a bad on .
so let's look at the analysi of mergesort , that's a bit of math but veri instruct becaus thi realli show the power of the divid and conquer method .
and allow us to take a problem that wa take us quadrat time with method like insert and select sort , and get it done in , in log n time with mergesort .
so that's the proposit mergesort us at most n lg n compar and <num> n lg n arrai access to sort ani arrai of size n .
and the wai to prove thi proposit is to from examin the code , to write down what's call a recurr relat .
and all that is , it's a mathemat reflect of what's go on in the code .
if we're sort n item then let c of n denot the number of compar that we need to sort the n item .
in order to get that done , we're sort the left half and the right half and thi notat ceil of n over <num> and floor of n over <num> that's the n over <num> round up and n over <num> round down , that's the size of the two sub arrai , and we're go to call the same routin for that size , so the number of compar you need to .
for that is c of n over <num> , ceil of n over <num> for the left and ceil of , floor of n over <num> for the right .
and then for the merg , we need at least , at most n compar .
if neither on exhaust , we need exactli n compar .
and so and that's true as long as n is bigger than <num> .
if there's onli on thing , we're not do ani compar at all .
so thi is a mathemat formula that we deriv by examin the code but it complet describ mathemat what we an upper bound on the number of compar that ar go to be need .
and similarli for the number of arrai access , if you count up the number of time you're access an arrai for a merg you could be at most six in .
so these ar mathemat formula and there's techniqu for solv them and we won't go into that .
thi is not a cours on discret mathemat .
but what we then do is show how to solv the recurr when n is a power of <num> .
and then it turn out that it hold for all n , which we can prove by induct from the recurr .
so if you have thi recurr which is similar to the on that we're talk about .
it's exactli the same when n is a power of <num> let's , let's look at thi on .
if d of n is <num>d of n over <num> plu n with d of <num> equal <num> , then d of n equal n log n .
we'll look at three proof of that , just assum that n is a power of <num> .
if n is a power of <num> , then n over <num> is also a power of two , so the recurr make sens .
so thi is just a graphic represent if we want to comput d of n we want to comput d of n over <num> twice .
so that's <num> and then the extra cost for the merg is n , but if we're go to do thi twice then we have <num>n over <num> .
so let's , we have 2n over 2s and then for each on of these we have divid into n over 4s and each on of those 4n over 4s ha an extra cross for the merg of n over <num> .
well <num>n over <num> is n , <num>n over <num> is n and we keep go down , do that til we get down to d of <num> and we alwai for the extra cross for the merg , we have n .
and how mani stage do we have here ?
well , it's the number of time you divid n by <num> to get down to <num> .
that's exactli log base <num> of n , so the grand total of all the cost for the merg , which is where the compar ar , is log n time n , n log n .
it's kind of a graphic proof or a proof by pictur that that recurr ha that solut .
here's a littl bit more mathemat on we write the recurr down , and then we divid both side by n .
so then thi is d of n over n equal d of n over <num> over n over <num> plu <num> .
so it's divid by n .
so now , thi is a recurr that telescop .
the first term on the right hand side is exactli the same as the left hand side so we can appli the same formula .
and all it doe is divid by <num> again and then throw out anoth <num> .
and we keep do that until we get down to d of <num> which is <num> .
and when we've done that , we've thrown out lg n 1s .
so we get d of n over n equal log n , or d of n equal n log n .
that's anoth proof by expans .
or us either on of those techniqu you could just get the idea that d of n is close to log n or you can write a program to expand the recurr and find that .
and then onc we have the idea that d of n equal n lg n , we can plug back into the origin formula .
with the induct hypothesi that d of n equal n lg n , we want to show that d of 2n equal 2n lg 2n , us the recurr d of 2n equal 2d of n plu throw out the 2n .
plug in n log n we get the desir result .
we us thi same idea on our initi recurr for comparison arrai access to show that the run , the number of comparison arrai access is proport to n log n for mergesort .
so that's the run time mergesort is fast other thing that we usual want to know is memori .
and on of mergesort's characterist is that in practic applic , it us extra space proport to n .
that is , we need that extra auxiliari arrai for the last merg .
we took two sort subarrai and we talk about an abstract in place merg but we didn't have an actual in place merg .
we were us an extra subarrai .
so n place is import .
a lot of time , we're sort everyth we have .
we want to fill up the memori with stuff to sort and then sort it .
and search and select in shellsort ar in place , thei don't us ani extra memori .
but mergesort you can onli sort realli half of what you can fit in memori , becaus you need that auxiliari arrai for the other half .
if you want , again , if you think that the thing we're studi ar easi , think about the idea of actual do an in place merg .
peopl have come up with method for get thi done .
so it's theoret possibl , but the method ar gener too complex to be us in practic and their not us .
but there could be out there some easi wai to do in place merg .
that's anoth great algorithm wait to be discov .
now there's a , a number of practic improv that we can us to make mergesort even more effici than the simpl on that we've look at and we'll take a look of those becaus thei're exampl of techniqu that we can us for other algorithm .
first thing is that mergesort is too complic to us for tini arrai .
so sai the subarrai ar onli of two , or three , or four there's too much overhead with the recurs call and so forth to get that done effici .
and what's wors is , the recurs natur of the sort definit mean that there's go to be lot of subarrai to be sort .
so , on improv that we can make is to us insert sort , and just cut off and us insert sort which is simpl and effici for small subarrai .
so that's ad thi on line of code to mergesort will make it quit a bit faster .
mayb <num> faster .
the second improv that we can make that'll improv the perform for case when the arrai is partli sort , is to just stop if it's alreadi sort .
and that's go to happen in the case where the biggest element in the first half is less or equal to the smallest item in the second half .
that mean it's done .
so that's easi .
we just put a test in the recurs mergesort for that , through thi on line of code , to check whether we're done .
that wai , for exampl , if you were to call mergesort for an arrai that's alreadi in order it would just do thi test everi time and it would be done in linear time .
that's pretti help although not , not total help but there's a lot of situat where that's help .
the other thing that's possibl to do and it's a littl mind bend so recommend onli for expert .
is to save a littl bit of time you don't realli have to copi over into the auxiliari arrai .
you can kind of switch the role of the input and the auxiliari arrai everi time you make a recurs call .
you still need that arrai but you can set up the code in thi wai which sort , to sort an arrai , put the result in the other on .
to merg an arrai , put the result back in the first on .
so it's recurs argument switcheri to get the job done .
and it's effect , it mean you don't have to actual move item , and that save a littl bit of time .
so here's a visual of what the practic mergesort might look like , and thi is with big cutoff to small subfil .
so you got a visual feel of how thi sort get the job done .
so it's the first littl chunck and then the next littl chunk and then merg those togeth , and so forth and so on .
it's a good visual represent of how mergesort get it job done .
that's the basic mergesort algorithm that we're go to look at differ version of in the next .
next , we're go to look at a bottom up version of mergesort .
well , mergesort is easi to understand as a recurs program .
thi bottom up version that ha no recurs , it's also quit simpl to understand and to code up .
the basic idea is to think of the arrai as be a littl at the begin a set of littl sort sub arrai of size on .
and then what thi method will do is go through and merg those littl subarrai of size on togeth in pair to get subarrai of size two .
then , the whole arrai consist of sort subarrai to size two , and then we make anoth pass through to get size four , and then size eight , and so forth .
so , as you can see in thi exampl we start out by merg the first two sub arrai of size on to make a arrai of size two e , m that's sort , and then do the same thing for the next two element and the next two and so forth until eventu instead of sixteen individu element we have eight sort subarrai of size two .
then on anoth pass through , we can take the e , m and the g , r and merg them togeth to make egmr , and the e , s and the o , r merg those togeth to make eor , and so forth .
and we have four subarrai of size four .
on more pass make two subarrai of size eight , and the last pass is just a sort arrai .
the bottom line in thi is sequenc of pass through the whole arrai and there's no recurs need at all .
it's extrem easi to code up as you can see from thi code .
we us the same merg code as befor and we take a nest for loop .
the first on is the size of the subarrai and thi loop get execut on a log n time becaus each time we doubl the size of the subarrai until we get to n .
and then we pass through pick out from low to low size <num> , and then the next part is low size size <num> until we run to the end of the arrai where we might not have a full subarrai of size sz .
that is a fulli complet industri strength code for sort .
the onli downsiz as would regular mergesort is that it us extra space proport to the size of the arrai .
but otherwis , that's a fine method for merg .
that's a bottom up mergesort .
if you look at thi visual trace you can see how it work .
the thing is total unsort , then it get sort until subarrai to size four , then eight , sixteen , and <num> .
now in thi case the second subarrai to be sort is smaller but the merg routin doesn't realli care about that so much .
you can merg thing that ar not equal in size .
and then we get a final sort arrai .
whatev the size , bottom of mergesort get the job done in log n pass .
each pass us about n compar for a total cost of about n log n .
with mergesort is a good opportun to take a look at the intrins difficulti in the sort problem , now that is call complexit and we'll look at that next .
the idea of complex is it's a frame work for studi the effici of all the algorithm for solv a particular problem .
that's call comput complex .
and in order to do thi sensibl , we need what's call a model of comput .
the oper that the algorithm ar allow to perform .
for sort that's kind of straight forward , what we're go to do is have a cost model where we count the comparison .
now in frame of the difficulti of problem were onli two thing .
on is an , what's call an upper bound which is a cost guarante that's provid by some algorithm for solv the problem .
that's an upper bound and how difficult it is to solv the problem .
we have an algorithm that can solv it it's the least that easi .
and then we also look for a lower bound which is a limit on the cost guarante of all algorithm .
no algorithm can do better .
now , what we seek ideal is what's call an optim algorithm where we prove that the upper bound and the lower bound ar the same .
that's an algorithm that's , that we know that ha the best possibl cost guarante .
that's the idea for solv ani problem .
so , for sort , let's look at what each of these ar .
the model of comput is what's call a decis tree , tree .
and what that man is that all we can us is compar , that's the onli wai we can access the data .
so , our cost model is the number compar .
mergesort provid , provid an upper bound , that's an algorithm that's guarante to get the sort done in time proport to n log n .
and what we'll look at now is the lower bound .
there's a trivial lower bound which sai you have to look at all the data , that's n and we'll look at a better lower bound and see that mergesort is optim .
so , here's the basic idea for prove a lower bound for sort .
let's sai , we ha ve three differ item , a , b and c .
whatev algorithm we have is go to , first , do a comparison between two of the item .
let's sai , there a and b .
and then there's two case .
either it's ye or it's not ye , let's , let's sai , thei're distinct .
and there will be some code between the compar but either wai then there is go to be a differ compar .
if it's less than b , mayb the next compar is b against c .
and if you find that b is less than c and a is less than b , then you know that thei're in the , ani algorithm that doe that know that the item ar in the order a , b , c .
if b less than c goe the other wai , then it take anoth comparison to determin the order .
in thi case , if c is less than b and a is less than c then those three compar show that the order ha to be a , c , b and if c is less than a , then it's go to be c , a , b , those three compar that c is less than a , c less than b and a is less than b .
the onli possibl is c , a , b .
in continu on the right perhap the next compar is a less than c and mayb if c is less than a , then anoth compar , b less than c .
so , in thi case , if you go from top to bottom in the tree with three compar at most you can determin the order of the three differ item .
the idea of the lower bound gener thi argument to figur out a number of compar that you need for a minimum to determin the order among n item .
now , the height of the tree , as i just mention , is the worst case number of compar .
out of all the order the on that's further stand in the tree that's the worst case and so the algorithm , no matter what the input is , the tree tell us a bound , the number of compar taken by the algorithm .
and there's got to be at least on leaf for each possibl order .
if there's some order that is not appear in a tree correspond the particular algorithm then that algorithm hasn't can't sort , can't , can't tell the differ between two differ order .
so , the lower bound as a proposit , that us the decis tree like that to prove that ani compar base sort algorithm ha to us at least log base two n factori compar in the worst case .
and by stirl's approxim , we know that log base two n factori is proport to n log base 2n .
and then the proof is gener what i talk about on the decis tree on the last side , slide .
we assum that the arrai consist of n distinct valu there's a posit creat that describ the perform of ani algorithm to compar sequenc done by ani algorithm to determin the n factori differ order .
so , thi three ha to have at least n factori leav and if the three of height h , it ha utmost two h leav .
the onli , the , the tree that ha the most leav of height h is total complet and that on ha two h leav .
and those observ give us the lower bound .
two h ha to be greater than or equal to the number of leav .
and the number of leav ha to be greater or equal to n factori so that impli the height of the tree ha to be greater than or equal to log base two n factori which is proport to n log n by stirl's formula .
that's a lower bound on the complex of sort .
so , we knew that the upper bound wa n log , proport to n log n and we just prove that the lower bound is proport to n log n and that mean that mergesort is an optim algorithm .
that's the first goal of algorithm design is to try and find optim algorithm for the problem that we need to solv .
now , you have to take these result in context .
realli what we prove is that mergesort is optim with respect to number of compar but we alreadi know that it's not optim with respect to space usag .
mergesort us twice as extra space proport to the size of the arrai it ha to sort .
and simpl algorithm like insert or dump , thei've thei don't us ani extra space at all .
so , what we want to take from these theoret result is , is a guid when we're look at implement and try to solv practic problem .
in thi exampl what it tell us , what theori tell us is don't try to design a sort algorithm that guarante to us substanti for your compar than merg sort .
sai , on half n log n compar .
is there a method that us on half n log n compar ?
the lower bound sai , no .
and that's a veri us thing becaus otherwis , we might try to defin such an algorithm .
on the other hand , mayb there is an algorithm that us n log n compar and also us optim space .
it's optim with respect to both space and time .
and that's what we're go to look at soon .
the other thing is that the lower bound is for the particular model of comput be studi .
in thi case , compar .
it might not hold if the algorithm ha more inform about the kei , for exampl , if it's known that the input is almost order , we saw that insert sort can be linear time for file that ar almost order .
or it's someth about the distribut of kei valu if there ar a lot of equal kei we can get sort , get it sort faster than , n log n .
and mayb the wai the kei ar repres .
we'll look at differ method that take advantag of such properti .
so , partial order arrai we mai not need n log n compar .
duplic kei , we mai not need n log n compar , we're go to look at the method that i guess that down in linear time and a lot of situat .
and later on , we'll look at digit properti of kei where we can us digit charact compar instead of whole kei compar and got a faster sort for certain practic applic .
comput complex is veri us wai to help us understand properti of algorithm and help guid our design decis .
next we'll take a look at compar which is a java mechan that help us sort .
the same data on differ sort kei , differ order .
and you're familiar with thi .
your music librari mayb i , at on point , you sort it by the artist's name .
in thi case we're look at the b's .
but in anoth situat , you might want to sort it by song name to look through it by song name .
that's the same data us differ sort kei .
how do we arrang to do someth is natur as thi in our java sort ?
now , we us the fourth in order to be abl to implement sort that can sort ani type of data , we us java's compar interfac .
and that concept is that there's some natur order of the data that you'll want to us most of the time , that's what the compar interfac is all about .
but there's a differ interfac call the compar interfac which is a wai to help a sort , us some altern order or mani differ order on the same data .
and the compar interfac again just sai that it's go to implement a method compar that compar two differ kei of the given type , of the gener type .
again it ha to be a total order and thi is veri familiar for exampl with string .
there's mani differ wai that we might want to sort string .
we might want to us the natur alphabet order or we might want to make it case insensit or mayb there is just differ languag that have differ rule of the order .
we're sort string but we're implement a differ order , variou differ order on that same data .
that's what the compar interfac is for .
so the java system sort will have a differ .
method to implement compar .
the idea is that you creat a compar object and then pass that as a second argument to java's sort routin and we can do the same thing for our sort .
the idea is when a decoupl , the definit of the data type from the definit of what it mean to compar to item of that type .
with the natur order , we had to put the definit compar to within the data type .
with compar , we can do that outsid of the data type even at some later time .
string were defin and as part of the java system but we can defin our own order on string with the compar .
so in our sort implement we can chang them as shown in thi exampl to support compar .
to support compar in our sort implement we'll pass an arrai of object and instead of an arrai of compar and then , there's a second argument pass a compar .
then , the less method will take that compar as an argument and thi is the on that actual invok the method compar two differ kei .
thi is a straightforward modif to our sort .
and then exchang of cours rather do compar ha to us object .
so with these straightforward chang at the compar as argument to the sort and to less and make arrai to be sort arrai of object , it's easi to convert ani of our implement to support compar .
to implement a compar you can us thi code as a model .
i won't go through it all in detail just to point out that thi implement two differ compar as nest class .
sai , for thi fiction class student , that's got two instanc variabl name and section .
and the first on call by name implement a compar for student and when you compar two student by name , it's go to us the string compar method .
if you're go to implement it compar to student by section , then it'll return just the differ of the section which is my minu if less zero if equal then plu if greater .
and thi code is straight forward wai to implement compar that you can us as a model .
if you need to be abl to sort data on two differ kei .
so here is just an exampl of what happen if would those implement compar for that class student us the java system sort , if you call arrai that sort with your a rrai of student and you give it thi by name compar , it will put them in order alphabet order by the name field .
and if you give it to by section compar , it will them in order by the second field veri conveni for all kind of data process applic .
and we came up with that befor when we're talk about us a sort for the graham scan .
we need to have a comparison for point that order them by the polar angl thei make , make with the given point p .
that's what we need for the graham scan algorithm for the convex hull .
point ar defin data type for geometr object and so what we need is code that will comput the polar angl and us that as the basi for comparison .
there's an easi wai to do thi base on ccw that is describ here in thi text .
most of the time all you need to do is do the ccw of the two point .
you either have to check whether the , on of the point is abov p and the other on is below .
but otherwis , usual it's a ccw call in thi code which again i won't go through in detail as an implement of a compar for two d point .
it implement the compar method that take two point as argument and with just a littl bit of calcul is abl to do the compar .
so thi code is the basi for appli the sort , system sort method or ani sort method for the graham scan for the convex hull that we did at the end of the last lectur .
so that's the basi for the graham scan method for the convex hull that we us at the last , at the end of the last lectur .
final , we talk about stabil .
thi is realli on of the rule of the game but it's much easier to talk about in the context of the real algorithm that we've seen so far .
and realli it doesn't make sens if you don't know about compar which we just introduc .
so , the typic applic that i just us as an exampl is sai the set of student record .
so we have them sort by name and thi is sai , someth that we do just befor assign final grade .
mayb the third line there is the final grade .
so it's all fine sort by name and but then in order to distribut it out to the peopl lead it to the section , what we want to do is sort by the second field , sort by section .
the problem is that when we do that , it mess up the sort by name and that's annoi .
you might assum that onc you have it sort by name , then when you sort by the second field then it should maintain the sort of by name for all that have equal kei in that second field .
actual not all sort preserv that properti that is call stabil .
and clearli , it's worthwhil to think about for your applic whether you want or need a stabl sort .
and so , it's an annoi surpris for mani peopl and mani applic .
so a stabl sort is a sort that preserv the rel order of item with equal kei .
whichev sort ar stabl ?
that's an interest question that we'll take a look at now .
the quick bottom line is that insert sort and mergesort ar stabl but not select sort or shellsort .
and even within that bottom line , there's implement that mayb ar not stabl .
you have to carefulli check the code to be sure .
alwai , in thi class , we have an exercis or exam question is thi version of thi sort stabl or not ?
so , student learn to recogn whether the code is stabl .
so thi is just anoth typic exampl where we've got thing sort by time , and then what we want to do is mayb these ar import event .
peopl bui ticket to a rock concert and i'm go to sort by locat what we'd hope is that it would keep the sort by time but thi is a non stabl sort that doesn't do bad so then out in the locat thei're go to have to resort it if thei us on of these .
but if thei us a stabl sort , then it stai sort by time and lot of applic you want stabil .
all right , so let's just look at each of the algorithm that we've consid so far .
insert sort .
insert sort is stabl .
why is it stabl ?
well , we never move equal item pass on anoth .
in thi exampl here , when we get a1 , well that's so in thi case , the index is just on that appear in the arrai , it's just a's and b's .
when we get our second a , we stop the sort as long as we're not less .
we're equal , we're not less , we stop it so we never move an equal item pass anoth on .
if thi less or less than or equal , then it wouldn't work .
or if we did the other wai around and proceed accordingli .
so , equal item never move past each other in thi code so therefor insert sort is stabl .
but select sort is not stabl .
usual wai , the wai to show that a sort is not stabl and it's just to see if it ha a long distanc exchang that might move an item pass some equal item .
so , in thi case , for exampl , for select sort , when we do that first exchang oop , where we found the minimum a and b is in posit zero .
we did a long distanc exchang and that catapult that first item past ani item that it might be equal put them out of order .
and that's mai not get fix so that sort is not stabl .
it might move item past some equal item and leav a result where item that ar equal or in differ order than thei were origin in the file .
select sort is not stabl .
shellsort also ha long distanc exchang and so it's not stabl .
it move kei past other kei that could be equal and so it easi to construct exampl show that select sort is not stabl .
and what about mergesort ?
mergesort is stabl well , it's stabl as long as the merg oper is stabl and that oper is go to be stabl depend on how we code it .
and , and in our code , if the two kei ar equal , it take from the left subarrai so that mean that , it will alwai take the , if there's a two set of equal kei , it will preserv the rel order and that's enough to show that the merg oper is stabl and then therefor mergesort is stabl .
stabil is an import properti in sort algorithm .
welcom back .
todai we're go to look at quicksort .
it wa name as on of the most import algorithm of the twentieth centuri and it's wide us for system sort and mani other applic .
last lectur , we look at mergesort , anoth classic sort algorithm , that's us in mani system , and todai we ar look at quicksort which is us in mani other .
you can even get a quicksort t shirt nowadai .
so what is the quicksort method ?
it's also a recurs method , but the basic idea behind quicksort is that it doe the recurs after it doe the work , wherea mergesort did it befor it did the work .
so , the idea is first randomli shuffl the arrai .
that's an import step that we'll talk about later , and then partit the arrai , so that's to divid it so that for sum valu j the entri a of j is in place in the arrai .
there's no larger entri to the left of j and no smaller entri to the right of j .
onc we have the arrai partit in that wai , shown here in the middl .
right here , we have k in it posit .
and we have everybodi to the left .
there's nobodi greater than k .
and everybodi to the right , there's nobodi less .
onc we have it arrang in that wai , then we recurs sort the two part .
sort the left part , sort the right part .
and then after those two thing ar done , the whole thing is sort .
thi method wa invent in <num> by toni hore , who won the ture award in <num> for thi and other work .
so let's look at a demo of how quicksort partit work .
the idea is to arbitrarili choos the first element to be the partit element .
sinc we shuffl the arrai , that's our random element from the arrai .
and then we're go to maintain an i pointer that move from left to right , and a j pointer that move from right to left .
let's look how it work in the demo .
so we start again by pick k as the partit element .
and then our method is to move the i pointer from left to right .
as long as what we have is less than the partit element .
and move the j pointer from right to left as long as it point to an item that's greater than the partit element .
so , in thi exampl the i pointer stop right awai becaus it's point to an r which is bigger than the partit element .
the j pointer decrement until it get to the c which it stop there which is less than the partit element .
and so now what's go to happen is those two element ar out of place .
the partit element in between them and thei're in the wrong order .
so what we want to do is exchang those .
and then move on .
now we increment i , as long as it's point to an element that's less than the partit element .
stop here at t cuz that's bigger .
and now we decrement j , as long as it's point to someth that's bigger than the partit element .
stop her at i becaus that's less .
again , t and i ar in the wrong place .
if we exchang them , we'll maintain the invari that everyth to the left of i is less than the partit element , or noth to the left of i is greater than the partit element , and noth to the right of j is less than the partit element .
so exchang increment i as long as it's less .
stop at l increment j decrement j as long as it's greater .
stop at e those two element ar out of posit so exchang them .
now increment i , stop at the l which is greater than k decrement j stop at the e which is less than k and now at thi point the partit process is complet , coomplet caus the pointer have cross and we have look at everyth in the arrai .
in fact .
j point to the , rightmost element in the left subfil , everyth that's not greater than k .
so we can just exchang j with our partit element .
and now we've achiev the goal of partit the arrai .
so that a of j is in it posit .
nobodi to the left is greater .
nobodi to the right is less .
now , the code for partit is straight forward to implement .
down below .
show the state of the arrai befor partit .
dure and after partit .
so in the end , the j pointer is point to the partit element v , which wa in posit v in the first place .
in the , all dure the partit process , the code is maintain thi invari .
where everyth to the left of i is less than or equal to v .
everyth to the right of j is greater than or equal to v .
and we haven't look at thing in between .
so , find , increment i , as long as it's less is a simpl while loop .
and then we put a test to make sure we don't run off the right end of the arrai .
and decrement j .
as long as it's point to a bigger element that's similarli just a wide loop we put in to test to make sure we don't run off the left end of the arrai .
then there's a test to see if the pointer cross .
swap the element of i and j .
when we get to the pointer cross we break out of the loop and exchang the partit element into posit .
so that's a quick implement of the quicksort partit method .
now , quicksort itself then is go to be a recurs program that us that partit method .
first thing we do is the public sort method that take the arrai of compar item as it argument .
it's gonna to do a shuffl .
and that shuffl is need to make sure that we can guarante that the perform is gonna be good .
and then it call the recurs method that take as argument the limit of the subarrai that's gonna be sort .
so then partit .
simpli doe the partit .
tell us where , which element is in posit , and then recurs sort the last part that's load , j on .
and then the right part , that's j on to high .
that's a complet implement of quicksort .
again , as with mergesort , studi a recurs trace is instruct .
and thi on is kind of upsid down as compar to mergesort .
the first line show the partit where k is put into posit .
then the method call the sort for the left subfil first , and then that's gonna be partit on thi e , and so forth .
and eventu we get down to small subfil , actual our code doesn't do anyth at all for subarrai of size on , so we just leav those in grai , and then it doe the right subfil , and so forth .
again , studi thi , a , a trace like thi , give a , a good feel for exactli what's go on in the recurs program .
let's look at an anim of quicksort in oper .
there's the partit .
now it's work on the left .
now it's partit the right .
now it's work on the left part of the right .
now it's partit what's left .
do the left part of that .
and work from left to right , by divid each sub arrai in half as it goe .
so let's look .
consid some of the detail in implement of partit with quick sort .
so first thing is the partit is in place .
you could us an extra arrai and the partit code would be a littl bit easier .
but on of the big advantag of quicksort over mergesort is that it doesn't take ani extra space .
it get the sort done in place .
now you have to be a littl bit care with termin the loop .
when we give you work code it's not hard to see why it work .
and you might go trough the exercis of try to implement quicksort without look at our code , and you'll find that test when the pointer cross can be a littl bit tricki , particulari in the presenc of duplic kei .
also stai in bound .
and i , actual , in our implement the test of the j pointer run off the left end is redund .
why is it redund ?
well , the partit element is sit there and it'll stop when it hit the partit element .
but the other test is not in our implement .
and the kei thing , on kei thing is that the wai that these implement work .
if the in , the file is , the arrai is randomli order , then the two sub arrai after partit will also be randomli order .
actual , some implement of quick sort out in the wild don't have thi properti , and thei suffer a littl bit in perform .
that random shuffl at the begin is import and need for guarante perform .
and the other thing i have refer to but not talk about in detail is the presenc of equal kei .
you might think it would be better to handl equal kei in some special wai .
we'll talk about that in a second .
but thi gener purpos implement stop the pointer on kei equal to the partit item kei and we'll take a look at why that's import in a minut .
so now let's look at the run time estim about why we care about quicksort vs mergesort .
thi is extend the tabl we look at last time , and you can see over in the right column here , quicksort is quit a bit faster than mergesort .
and again , a good algorithm is much better than have a super comput .
even on your pc you can sort huge arrai of a million item in less then a second and a million item in onli a few minut .
so again thi time , sort of time is why quicksort is so wide us .
cuz it's simpli just faster than mergesort .
well in the best case quick sort will divid everyth exactli in half .
and that make it kind of like merg sort .
it's about analog in .
and in the worst case if the random shuffl wind up put the item exactli in order , then partit doesn't , doesn't realli do anyth except find the smallest , peel off the smallest item .
kind of discov that everyth to the right is greater .
that's a bad case .
but if we shuffl randomli , it's extrem unlik to happen .
most interest thing about the studi of quicksort is the averag case analysi .
thi is a somewhat detail mathemat deriv , but it is worthwhil go through the step , to realli get a feel for why it is that , quicksort is quick .
so what we do is , as we did for merg sort , is write down a mathemat recurr relat that correspond to what the program doe .
in the case of quick sort , the number of comparison taken to sort n item is n <num> for the partit .
plu what happen next depend on what the partit element wa .
if the partit element is k .
ani particular valu happen with probabl on over n , and if it's k , then the left subfil ha k on item in it , and the right subfil ha n k item in it .
so , for everi valu of k , if you add those up the probabl that the partit element is k , plu the cost for the two subfil , we get thi equat .
thi look like a fairli daunt equat , but actual it's not too difficult to solv .
first thing we do is just multipli by n and collect term .
so ncn n time n on .
and then these term , everi size appear twice .
so it's twice the sum of from c0 to cn on .
it's a simpler equat alreadi .
now what we can do is get rid of that sum by subtract the same equat for n minu on .
so ncn n on , cn on then the n , n on n on n is just 2n .
and then the sum collaps just leav the last term .
thi sum , minu the same sum for n on , just leav the 2cn on .
now that's look like a much simpler equat .
rearrang the term , so we get n <num> cn <num> and then divid by n , n <num> .
that's a kind of a magic step , but we will see that it make possibl to solv the equat easili .
becaus that equat , with c over n plu on equal cn minu on over n , is an equat that telescop the first term at the right .
it's the same as the term on the left .
so we can appli the same equat so it two over n on .
we appli for n on we get on less here and we can throw out a lot two over n .
and continu that wai throw out two over decreas number all the wai down until we get down to two element , c1 which is zero .
substitut the previou equat telescop .
and then that give us an easi sum that we can approxim by an integr .
it's on over x from three to n <num> .
and that's a pretti close approxim , in thi case .
and that approxim give us , it's about two m <num> natur log n comparison for quicksort .
about <num> . <num> n log n .
that's the averag number of comparison taken by quicksort , and actual thei for a random permut of the element which is what we do with the shuffl .
thei the expect number of comparison is concentr around thi valu .
it's veri like to be veri near thi valu is then as larg .
so the worst case quick sort is quadrat .
so complex's go to tell us that it's a quadrat algorithm if that's what it worst case is .
but with random , the random shuffl it's more like that thi lectur will end , becaus of a lightn strike .
or your comput will be struck by a lightn bolt .
so we can discount that .
the averag case , which is extrem like for ani practic applic , is go to be about <num> . <num> n log n .
so that's more compar than mergesort us .
but quicksort is much faster , becaus it doesn't do much correspond to each compar .
it just doe the compar and increment a pointer .
wherea , mergesort ha to move the item into and out of the auxiliari arrai , which is more expens .
so the random shuffl is a kei for good perform in quicksort .
it give us the guarante that the worst case is not gonna happen .
and also , it allow us to develop a math model that we can go ahead and valid with experiment .
you run quick sort and you count compar .
if you did the random shuffl , it'll be about <num> . <num> n log n compar .
and it run time will be proport to n log n , and it'll be a fast sort .
and that's what peopl do , and that's why peopl us it .
now there ar some thing that you have to watch out for with quicksort becaus the implement is a bit fragil and it's easi to make mistak .
and you'll find textbook implement or implement out on the web that wind up run in quadrat time in certain situat .
you have to be a littl bit care of that and even if everyth is random if there's lot of duplic and the implement is not done quit right the quick sort might take quadrat time .
so , let's summar the properti of quicksort .
it's in place .
it doesn't us ani extra space .
the depth of recurs .
so tha , that's .
again , depend on the random shuffl , is go to be logarithm .
you can , limit the depth of recurs by alwai do the smaller sub arrai befor the larger sub arrai .
but that's not realli necessari nowadai , as long as you've done the , random shuffl oh , and by the wai , quicksort is not stabl cuz partit doe on of those long rang exchang that might put a , a kei with equal valu over a kei anoth kei with the same valu .
so it's a littl more work to make quicksort stabl , mayb us extra space .
un , so what about in actual in practic ?
thi is our fastest sort algorithm , and there's a few wai to make it even faster .
and these , we look at some similar thing with for the word , mergesort .
and it's definit worthwhil take implement for a quicksort .
first thing is small sub arrai .
even quicksort ha more overhead than you want for a tini arrai , like on of size two or three or four .
so can implement it to cut off to insert sort for small arrai .
and the exact number thei us is not too , critic .
okai .
anywher between ten and twenti will improv the run time by mayb twenti .
also you could just not do anyth for small arrai , and then do the insert sort in on pass at the end .
so , that's a first improv .
a second improv is to , try to estim the partit element to be near the middl .
rather than just arbitrarili us the first element .
which on averag will be at the middl .
so on thing that we can do is sampl the item , and then take a median of the sampl .
and that's actual not worth the cost for enlarg sampl , not usual .
but for three it's worthwhil .
slightli reduc the number of compar .
increas the number of exchang paradox , cuz more exchang ar requir when the partit is right in the middl .
so that'll also improv the run time by mayb ten .
so thi is a summari of the optim quicksort with cut off the small subfil in median of three partit .
so partit usual happen pretti close to the middl when you do that sampl median of three and then small subfil can just be left unsort to be pick up with insert sort right at the end .
so thi give a feel for the .
number of item that have to be touch dure quick sort .
and kind of an explan for how it get the sort done so quickli .
that's a summari of quicksort , our best sort algorithm that we've seen to date .
now we'll look at the problem that's relat to sort call select that's also well solv by quicksort partit .
thi is a simpler problem .
we're given an arrai of n item that ar order and our task is to find the k th largest .
there's lot of import applic for thi .
so like if we want to find the minimum item that's k zero or the maximum item that's k n on or the medium that's k n <num> .
and there's mani kind of applic from peopl process data .
i want to find the top k or the medium or other order statist so that's what select is all about .
now , here's an exampl where we want to us theori as a guid .
what kind of effici might we expect in a select algorithm .
well , first of all , it's easi to see that we can solv select and in law at end time .
how would we do that ?
well , we just sort the arrai and then if we want to find the smallest , we'll look at the first posit or the largest , we'll look in the last posit or the medium , we'll look in the middl .
in fact , if k is small , the run time is go to be proport to n .
becaus if you're look for the smallest , you can just go through the arrai and find the small or the smallest in on pass through or if you're two , you'll find it and two pass through .
so , you can imagin try to look for a select algorithm that take time proport to n and also the lower bound is n becaus you have to look at everyth .
if you don't look at everyth , you might miss the on item that you're look for .
so , from these observ it's clear that what we , what we'd like is a select algorithm that take linear time .
but at thi point , the question is , is there a linear time algorithm that work for everi k ?
or possibl select is as hard as sort .
thi kind of question plagu a lot of peopl in thi late <num>'s or earli <num>'s as these type of problem emerg for comput applic .
so , it's an interest question to think about for sure .
well in hi origin paper in <num> hoar gave a solut to the select problem base on partit .
and the idea is just a version of quicksort in a wai .
we're go to do our partit so that we get entri a j in place of the arrai .
nobodi to the left is larger , nobodi to the right is bigger .
but then , when we're do select , what we'll do is just go in on sub arrai or the other depend on where j is .
if j k , we're done , we've found the k is the largest .
if k is to the left of j , then , we just do the left sub file which is set high to j on .
and if k is to the right of j , we just do the right subfil that load the j on and that's all thi code doe is that it , we could do a recurs , a recurs call but thi just doe it by reset the valu of the paramet .
do on partit then check whether you to your k th element is go to be on the left part or the right part and reset lower high accordingli .
if it's equal , then you found it and you return it and you keep go until you get to a point where you have onli on element .
that's the a quicksort like implement solv the select problem .
notic again that it depend on the random shuffl at the begin that's go to be import for perform .
all right .
so there need to be a mathemat analysi to , to character the run time of thi program in the fact is that quick select thi method take linear time on the averag .
we won't give the full proof .
it's actual quit a bit more complic than the on just on for quick sort .
but intuit , we can see kind of what happen each partit that mayb split the arrai approxim in half .
so that , that mean you'd have , if you did exactli and n <num> n <num> and so forth which add up to about two n compar so linear cross .
if you do the , actual it doesn't cut it in half at exactli each time onli on averag so you need a fuller analysi like the on we did for quicksort and the bottom line of that analysi give the number of comparison requir as a function of n and of k in term of thi formula here and if you plug in k n <num> , you get the result that the number of compar requir to fine the median that's the highest valu thi formula can take is two two natur log of two .
so , linear time to find the k th largest for ani valu of k .
now again it's go to us , thi is a method that's linear time on the averag .
it's actual go to be quadrat in the worst case but again , the chanc of that it will happen with a random shuffl is less than the chanc that we'll be struck by lightn .
it a probabilist guarante fast algorithm .
now , from a theoret standpoint that's a littl unsatisfi and in , in <num> , there's a famou paper that found a compar base select algorithm that guarante to solv the problem in linear time .
thi is areal landmark in the theori of algorithm becaus for a long time , it's not known , we knew we could have the averag case , the linear time but could we find a worst case ?
and thi paper found such a construct .
now in practic , thi construct is , is rather high .
so , the method is not realli us in practic .
and so , there is still the goal of a , of a fast guarante linear time select algorithm mayb somebodi in thi class will invent somedai .
thi is anoth exampl where we us theori as a guid .
it's still worth while to look for a practic linear time worst case algorithm .
well then , mayb somebodi in thi class will invent that but until someth like that is discov us the quick select base on quicksort partit you can get linear time select when you don't need a full sort .
that select of simpl problem like sort that is well sound with quicksort partit .
now we're go to take a look at what happen when we have signific number of duplic kei which is not at all unusu in practic applic .
so , in , in fact , often , the purpos of a sort is to bring item with equal kei togeth for like the exampl that i gave where we had citi and time .
there's a lot of detail data and the time and mayb the whole goal of the sort is to group them by citi so we can ship out the data for each citi , to each citi and there's plenti of other exampl like that in data process where we find mayb remov duplic from a mail list or all the job applic that we get , we might want to sort them by the colleg attend .
so the sort doe huge file with huge number of duplic kei .
so , a sort , it's worthwhil to take a care look at what the implic of that is .
so again , typic characterist we have a huge file but small number of differ kei valu .
so let's look at our algorithm in that situat .
so mergesort , it doesn't matter that much what the kei valu ar like and it's actual , we can show that mergesort alwai us between on half , n log n and n log n compar .
quicksort actual , thei're up until the 1990s the most wide us implement took quadrat time .
for file with larg number of equal kei and that wa actual found by applic user and , and that's the standard quicksort that wa in all the textbook almost all the textbook if you did not stop the partit on equal kei it would run in quadrat time .
so we want to do better than thi .
so the mistak happen if we put all the item equal to the partit item on on side which is a natur wai to implement it and the consequ is if you have all the kei equal , then partit doesn't realli do anyth .
you just peel off on kei to do file size n then you get a sub file size n on and then n two and so forth and the result is a quadrat tim e algorithm .
our implement , we stop the partit scan on item equal to the partit item and then in that case , when all the kei ar equal , it's go to divid it exactli in the middl .
and then in that case , when all the kei ar equal , it's go to divid at exactli in the middl .
and then in that case you get an n log n compar .
but actual when you think about it , why don't we just put all the item equal to the partit item in place .
that's , that's realli a desir wai to look at it and let's take a look at that option .
so the goal is so call three wai partit .
so what we want to do is get the arrai into three part so then now we have two pointer into the middl .
on that is the boundari between the kei that ar less than the partit element and those that ar equal of the partit element .
anoth on that's the boundari between the kei that ar equal of partit element and the on that is greater .
and then in the middl ar all the equal kei and that's what we'd like to arrang .
now until the 1990s , convent wisdom among peopl implement system wa , wasn't worth do thi .
but , but actual it's a problem that edsger dijkstra had propos in the 70s as an exampl of , of program problem .
he wa realli interest in analyz correct of program and show that thi how you could convinc yourself that thi program wa oper as expect .
but in the 1990s we figur out that realli thi wa go to be an effect wai to sort .
and thi wa take a look at the qsort that a user found wa broken and , and now , thi method is incorpor into some plenti of system sort .
so let's take a look at how it work with the demo it more complic than standard quicksort partit .
a bit more complic becaus there's more to do .
so now we have our i pointer which is right to the left of stuff we haven't seen ye t and then , we have two other pointer that maintain , maintain these boundari everyth to the right of gt is known to be greater than partit element .
everyth to the left of lt is known to be less and between lt and i is known to be equal .
and all the method doe is maintain thi in variant so let's do an exampl or two and see how that work .
so we increment i and then figur out what to do .
so , now it's less than the partit element .
so , what we want to do is increment lt's .
so now we have on that's definit less than the partit element and lt is , is point at the partit element .
and so now in , increment both lt and i so that's the first case there .
so now we have a second item b .
that's less than the partit element so exchang with lt and increment them both .
so , we're move the smaller on than the partit element to the left of lt and keep lt point on a partit element .
now , what about when we get on that's greater than the partit element ?
so , in that case , we exchang greater the on over at the right with i and decrement gt .
so now , we have on over to the right that we know is greater than the partit element .
notic that we didn't increment i becaus that element z that is over in the right , realli hasn't been compar to the partit element yet .
but we did decrement gt so we made progress .
so now what happen here , now i is point to a bigger on so we're go to exchang it with the on at gt and decrement gt again .
and again , y is bigger , so exchang it , decrement gt .
now we have the c , that on smaller so that's the first case .
so we'll move it to the left of lt and increment both lt and i .
w is a bigger on , let us to go over to the right .
now we have i point to an element that's equal to the partit element .
and what ar we suppos to do then ?
well , to maintain the variant there we just need to increment i .
and again it 's point to on that's equal of partit element increment i .
and now on more time and now it's point to on that's greater so we exchang that with gt and decrement gt and i is point to the on that wa there and that on smaller .
so we exchang it will lt and increment both i and lt and now where the point , where the pointer have cross i and gt across there's noth that we haven't examin yet .
so , our partit is complet .
here's a trace of dijkstra <num> wai partit for hi problem which is when there's just three differ valu in the file .
our problem we were treat partit , equal of partit element as on valu less than as anoth and greater than as anoth .
and so thi , thi trace illustr how we alwai make some progress and eventu we get the file sort .
the implement is amazingli simpl .
the whole partit process for three wai partit and the modern program languag like java simpli maintain the invari describ in the demo .
if we find on that's less we exchang i and lt and increment them both .
if it's greater we exchang i and gt and decrement that .
otherwis , we increment i .
could , could hardli be simpler .
in fact , is simpler in mani wai than these standard implement of quicksort .
in fact , there's an argument for just us thi implement of quicksort and forget about hors becaus it perform so well in so mani practic situat .
here's a visual trace of <num> wai quicksort for situat with plenti of equal kei .
and again , when there's a lot of equal kei then there's go to be place where on of those is chosen , it's partit element then a big chunk of the arrai get handl just in a partit process .
now , there's actual some deeper reason why thi method is import and on thing to do is to realiz that the lower bound that we talk about befor depend on the kei be distinct .
so , worst case for lower bound is when the kei ar all distinct .
but if we have a situat where there ar a lot of equal kei , that model is wrong .
it's not too difficult to get a similar lower bound for the model when we know that there ar some equal kei .
so , for exampl thi is a rather complic formula but not too bad but in a sens that if you know that the i th kei , it occur xi time you can write down a lower bound for the number of comparison that ar go to be requir in the worst case .
and , what's interest about three wai partit is that the number of compar that it us is equal to thi lower bound within a constant factor .
so that's entropi optim and what that mean is whatev the distribut of equal kei in there , thi thing is go to us a number of compar that's proport to the best that you could possibl do .
the proof for thi fact is quit beyond the scope of thi cours but it's still an import fact .
and the , the bottom line is that if you random the order and us three wai partit then there's lot of applic where your sort routin is go to be linear not n log n so it will be much more faster than mergesort and you know , the method for realli a broad class of applic .
now , we'll take a look at how the sort algorithm that we talk about or express in the system that we us everydai .
now , the kei point is that sort algorithm rhythm ar essenti in a veri broad varieti of applic and , and all of us us sort algorithm pretti much everi dai .
mani obviou out applic like or , organ your music librari or displai your search result or listen feed in your in your web browser .
there's some other applic that ar not so obviou where we us sort as a to make a problem easi onc you know that thei're sort .
and so , for exampl , find the median and if it's alreadi sort , it's much easi to find the median .
and now , the statist problem ar like that or find duplic .
probabl find duplic by itself is not quit obviou what to do but the easi wai to solv it is to just go ahead and sort .
and then there ar plenti of applic that we'll see later in thi cours like data compress or comput graphic like find the convex hull , applic in scienc such as comput biologi or , or in system develop .
we're have a effici sort as absolut crucial .
so , becaus there's all these applic most program system have a fast sort as an import part of their infrastructur and java is no exempt .
so , java ha a method call arrai . sort and it's intend to be a gener purpos sort method for us by java programm .
and now , that you have some understand of the classic method you can have a better idea of why arrai . sort is the wai that it is .
so it ha the infrastructur that allow us to be us for all type of data type and all type of order so it's got a method that implement compar then it got method easi compar order .
so that you can us the natur order or you can provid a compar order and provid your own order for ani type of data .
it us actual both quicksort and mergesort .
it us two quick sort for primit type of data and a two mergesort for object .
why two differ well it's just the design's assess of the idea that if a programm is us object mayb space , not a , a critic import consider .
and so , the extra space us by merg sort mayb is not a problem .
and if the program is us primit type , mayb perform is the most import thing .
and so , then we'll us the quicksort .
to invok arrai that sort , you have to import the name space from java . util . arrai and then all you need to do is invok arrai . sort .
so i just answer thi question , why do we us differ algorithm for the two type ?
and thi is , is mayb arguabl .
now ar refer to thi idea of a good system sort , there wa a good system sort that a lot of peopl us for mani year .
and in <num> , there were some scientist that , that bell lab that were us qsort for a scientif problem and thei were us to take just a few minut and then thei realiz that it wa take hour of cpu time .
and the fact wa that all the qsort implement at that time in unix had thi flaw well , there ar two flaw and on of them is a littl complic about the wai thei ar rais order and the other on wa for a rais that had lot of equal kei and thi is wilk and becker problem and have lot of equal kei , it wa quadrat time .
so , the system design , jon bentlei wa on of the design to take a look at these problem and that lead ultim to the develop of the <num> wai quick sort that were us todai .
he work with doug mcilroi and thei wrote a , a , a paper that outlin thi problem and talk about some of these thing and thei had a three wai partit method that wa somewhat like the dijkstra method that we show but a bit more complic .
anoth er thing thei did wa rather than shuffl the arrai .
thei us what's call a method for choos partit element call tukei's ninther .
tukei is a statistician and he had thi particular method for order statist that ha some interest properti and us that for the partit element .
thi paper wa veri influenti and , and that basic method is wide us .
and tukei's ninther is just pick nine item out of the arrai and take the median of the medium and that's the ninther .
so veri inexpens and thei had macro to do thi so and us not too much cost to find a partit element that's much closer to the middl than , and if you us a , a random on .
so the , the reason thei us that is thei thought thei got them closer to the middl and thei also don't like the , some system design don't like the idea of us random choic in a system method becaus of wai that it chang the state of the system .
so thei felt that thei got better partit than a random shuffl and it wa also less costli and then gener random number includ thi chang of state problem .
but there's a problem so you would think that the system sort would be complet solid with all thi resourc with all these research and all of the develop that's go into it .
in fact there's a file out there in your book site and get it that will actual break the java system sort .
there wa a killer input that will make the thing run in quadrat time .
actual it usual crash becaus it's recurs and it crash the system stack .
and it can caus all sort of problem .
there's a killer input for the system sort and , and it can be disastr in variou system and the reason is , thei didn't do the random shuffl .
mcilroi , himself , actual found thi problem that you could while the sort is run figur out an inp ut that would make it crash .
and so , you can just run that program and if the sort doesn't us random then it's vulner to thi attack .
so which algorithm should we us to sort that's , that's realli a kei question .
we've look at lot of sort algorithm and actual , there's hundr of sort algorithm out there and we have chosen the most import and the most interest for you but you could liter spend a year read all the paper on sort and then you still continu to be invent new algorithm ar develop and that ar found to have good characterist all the time .
and realli , the kei idea is realli import to think about cuz it appli to all sort of algorithm problem .
on our wai , we've been talk about rule of the game .
what is it that we care about in a sort ?
it's a littl bit more complic than just put stuff in order .
there's a lot of attribut , the differ applic have .
like stabil , that's a fairli sophist attribut that you realli have to think about , you mayb not be awar of .
mayb your comput is parallel and the sort ha to be parallel and we found that equal kei make a huge differ .
and i didn't realli think about that at the begin but it can make a huge differ .
mayb the wai your comput's memori is organ make a differ .
mayb the kei ar small and the item ar larg or mayb the kei ar realli huge .
do we need guarante perform ?
ar we happi with random perform ?
do we know , is the arrai randomli order ?
you can think of a matrix shown in the right here where we list out all the possibl attribut and then there's algorithm that work well for differ combin of attribut .
but the thing is , there is wai more possibl combin of attribut than there ar algorithm .
so there is go to be situat that ar go to requir an understand of what it take to engin a , a sort method that's appropri for your applic .
there can't be a system sort out there that's go to cover all possibl combin of attribut .
now , usual it's go to be good enough but it's definit worth while to understand what's go on with differ sort algorithm in order to even find improv perform over the system sort .
so , here's the summari of some of the thing that we've talk about .
we've talk about six differ sort algorithm .
then , we've talk about a bunch of attribut .
for exampl , the top line , select sort is in place it alwai take about n <num> two comparison .
and on of the thing to remark about it is that it onli us n exchang and so forth .
insert sort best case linear , quadrat , and place unstabl .
and it'll work well if the file is small or partial order .
shellsort , we don't know it's a run time , it's not stabl but it's a fast method for intermedi size file and not much code .
mergesort and log n guarante unstabl but not in place , need that auxiliari arrai .
quicksort not stabl .
quadrat time worst case but that's unlik to occur if you do the random shuffl .
and it the fastest and most us in practic particularli if you make improv to deal with duplic kei .
and it's interest to note we've look at import and classic algorithm that ar wide deploi but we don't have a , a us , practic algorithm that ar wide us that's got all of these characterist that's in place and stabl worst case n log n .
there's version of merg sort that come close but thei ar too complex for practition to have adopt them .
those ar some of the situat that we encount when develop a system sort .
and , quicksort certainli plai a role in most system sort .
welcom back .
todai , we're go to look at prioriti queue which is a variant of sort that gener the idea to provid more flexibl data structur that we can us for all sort of applic .
to get start , we'll look at the api and some elementari implement .
so at a week or so ago , we look at collect in java and the idea of elementari data structur where we insert and delet item .
and then , the data structur differ on the basi of which item we choos to delet .
we look to the push down stack where we remov the item that wa most recent ad , and the queue where we remov the item that wa least recent ad .
and then , we talk about random queue or bag where we might remov a random or an arbitrari item .
todai , what we're go to talk about is call the prioriti queue and for that , we insert item , but when it's time to remov , we consid the item to have a total order and we want to remov the largest or the smallest item .
so thi littl exampl if we insert p , q , and e then when we do remov max , we want to get the q out and for later , we insert x , a , and m and then we remov max .
the largest on in there is x .
we'll insert p , l , and e and then , after a while , we remov max p .
so , that's our basic setup .
that's our definit of what a prioriti queue is .
so , the api will look veri similar to our stack or queue api with a differ that we want to have gener item that ar compar .
so the java languag for that is in the class header .
we sai that our gener type kei extend compar of kei .
and that just mean that our kei must be compar and we must have a compareto method that will compar it to anoth kei .
otherwis we have a constructor and actual for some applic , it's conveni to have a constructor that take an arrai of kei as argument .
then , an insert that put someth in like push in a stack or enqueu in a queue .
then delet the maximum .
i refer to delet the minimum just to avoid confus , we have the implement separ implement usual minpq , where we delet the minimum .
then test isempti and we also sometim have extra method that just give us the valu of the largest kei and also size which is us sometim in collect .
you might also want it to be iter but we'll skip that for now .
there ar lot and lot of applic of prioriti queue .
even though it emerg as a data structur rel late in the game now that we see that there ar mani algorithm that ar much easier to implement when we think about the prioriti kei abstract .
we have data that we ar process we can't process it all at onc .
we have to save it some of wai .
and then , what the prioriti queue tell us is let's organ it in some wai that we ar alwai take the best on to process next .
and it turn out to be veri close to a gener algorithm design techniqu that we will be look at in mani , mani differ applic .
todai , we're go to talk about event driven simul which is an interest idea that is base on prioriti queue but it's also us in numer comput and we'll see in algorithm for data compress and graph search that it's us .
and in mani other applic in comput scienc and in scientif comput .
it gener the stack and the queue and give us a data structur that we can us to effect design algorithm of all sort .
so here's just a particular client that will help explain the idea .
so our , our challeng is let's sai thi is on the web we have billion of transact , you know , and thei ar stream through our data warehous or processor in some wai .
and just a veri , veri huge number of transact .
in fact , we couldn't possibl hope to even store them all .
there's trillion of them there come through as fast as possibl .
but we're interest in the biggest on and so mayb it's the biggest amount of dollar , or the biggest cost , or whatev it might happen to be .
and so we can pick some number that we can store .
i would like to , to store the , the thousand biggest on .
so , you can imagin a credit card compani look for fraud it's go to care about keep track of the largest transact .
so , mayb we can store million or thousand of them .
so that's our paramet m that's the number we can afford to store but the total number of item we couldn't possibl afford to store them .
so and thi is just some test data where we've got all , all these transact and so we ar go to be abl to take in data like thi and again an unbound stream of data .
but let's sai , we want to keep track of the top five valu us the third column as the valu .
so we're go to look at a client program call topm that take the command line argument , how mani and thi case , it's go to sai five and then it's go to take from standard input the transact and it will print out the top five .
so , that's a canon exampl of a , a prioriti queue client that we need to design a program that can do that .
so , with the prioriti queue abstract that's not too difficult to do .
so we ar go to us a min orient prioriti queue so that's go to keep , it'll it'll be on where we can delet the minimum and , and it'll be gener so we'll have a transact type that hold thi inform includ natur order where it's order by dollar that last column .
so , we'll build a new prioriti queue , min prioriti queue or we'll have the capabl to delet the minimum .
and then we read from standard input .
we read the line , build the transact from the inform on that line .
and that will fill in the field and then , we put that transact on the prioriti queue .
now , if the prioriti queue ha more than m item becaus we insert that on , then we want to delet the smallest on there and that wai , we're keep track of the largest m .
whenev we get a new on , then we throw awai the smallest on that's there .
so , even with thi huge stream of item come through , we're onli keep track of the m largest item and that's a fine canon client for prioriti queue .
now how we ar go implement or solv thi problem or you can think of lot of wai to go ahead and solv thi problem of find the largest m item in the stream of n item .
so , for exampl , you could sort them .
and then just look at the m at the end but by send up the problem , i alreadi kind of rule that on out becaus we don't have the space to sort them all , to store them all .
so sort is out of the question .
we'll look at coupl of elementari prioriti queue implement that ar straightforward .
you know , keep the item like we would in the stack and then when we need to find the smallest or the largest look at , look at them all .
but that's go to be too slow .
m is larg and n is huge , and m<i>n is go to be too slow .
what would what we we'll look at is< i> veri simpl and practic implement us a data structur call the binari heap that get the job done in time proport to n log m and onli m space .
and that's pretti close to the best that we could do in theori and is veri import and us , practic implement and data structur .
all right .
so here's just an overview of two elementari implement for prioriti queue us the exampl oper that i gave befor .
so you can imagin keep the item , sai , in a link list or in a doubl arrai and just keep just an order just as we would in the , in the stack just keep in the wai that thei come in .
and we'll put a new item at the end of the arrai and remov it from the end of the arrai .
or you could do it in a link list , and then when it's time to find the , remov the maximum , you have to scan through everyth to find the maximum .
so , so , that's a on wai you could implement thi with , with a link list or with the resiz arrai .
or you might to sai well let's try to keep thing in order .
and then that might involv some work with the , it's like insert sort , you find a place to put the new item and then put it in the right place .
and again , you could do thi with a link list or with the resiz arrai but then , with arrai , you'd have to move all the larger on over on posit to fit the new item in .
when we insert e and that's suppos to keep them in order , we have to move over l , m , p , and p to get the e and then so forth .
but the advantag of that might be that remov the maximum is easi .
we just take awai the on at the end .
to remov the q we know it's at the end to remov the max .
at thi point , that's x it's right at the end , and p is right at the end .
so you can imagin the implement of prioriti queue us these two basic strategi .
not much code involv .
thi is a an order arrai implement of prioriti queue and it's quit straight forward .
we didn't put in the thi is the cheat version where we requir the client to provid a capac but we could easili chang thi to a resiz arrai .
so insert just put it at the end , and sinc it unord delet maximum ha to go through the entir arrai to try to find the maximum when it refin it and the chang that we're the on at the end and then remov it the same wai that we do within the stack .
it'll us less and exchang just like we would in sort method .
so that's a fine implement if the prioriti queue wa go to be tini all the time .
so if you , without even implement it , you can understand thi tabl that if we us an unord arrai implement we can get insert done in constant time but we have to look at everyth to delet the maximum or even find the maximum .
if we keep it in order , we can find the maximum or delet it at constant time but it take us linear time to insert .
and sinc as with stack and queue oper , these insert and delet might be intermix in arbitrari wai and there might be huge number of them either on of these is veri attract becaus thei're go to take n time the number of oper .
wherea what we can hope for and what we actual will achiev is to get log n time for all oper , time proport to log n for all oper .
with the clever data structur and interest implement we can actual achiev that goal .
that's the basic api and some elementari implement for prioriti queue .
now we're go to look at binari heap which is an ingeni and veri simpl data structur that's go to help us implement all the prioriti queue oper quickli .
so , the idea of a binari heap is base on the idea of a complet binari tree .
so , a complet binari tree , well first of all , a binari tree is either empti or it's a node with link to left and right binari tree so that's an exampl of a binari tree .
a complet binari tree is on that's perfectli balanc , except possibl for the bottom level .
so there might be a few node on the , on the bottom level and on level lower than the bottom level .
but otherwis , all the level ar full .
we'll see how that look in just a second .
the properti of complet tree is that the height of a complet tree with n node is the biggest integ less than log base two of n , and that's realli easi to convinc yourself that that's true becaus the height , if you add node on at a time go from left to right on the bottom level sai , the height onli increas when n is a power of two .
complet binari tree actual happen in natur .
here's an exampl of on that goe on , two , three , four level at least , so sixteen push at the end there .
all right .
now , the wai we're go to us complet binari tree to implement prioriti queue is to first of all , associ inform with each node .
we'll put our kei in the node , and also we're go to repres it with an arrai .
so , when we start put the kei in the node we're go to impos on more condit that's call heap order .
and the idea is that the parent's kei is go to be no smaller than it children's kei for , and that's true for everi node in the tree .
the arrai represent , all we do is , we put we start with indic at on , it's a littl less calcul .
that wai we leav a <num> empti and then we just take the node in level order .
so first , we put the root .
then , we put the two node on the fi rst level go left from right .
and then , all the node on the third level , go from left to right and so forth .
thi is interest becaus we can draw the tree to get more intuit about what's happen .
but in the actual data structur represent , we don't need ani link at all .
it's just an arrai .
the wai that we move around the tree is by do arithmet on the indic .
so let's look at a few properti of binari heap .
so that's complet binari tree repres in arrai with kei in the node satisfi the heap order properti .
well , first thing is that a <num> is the largest kei .
it's larger than the kei and it two children and thei're larger than their and so forth so it's the largest kei in the data structur .
the other thing is , as i just mention , you can us the arrai in the seed to move through the tree .
for exampl , if the node is at posit k , index k in the arrai , then it's parent is a k over two and that's integ divid .
so the parent of sai h and g ar both n .
h is ten , g is at eleven , n's at five so both of those ar ten over two , eleven over two , integ divid is five .
and go the other wai it's easi to see that the children of the node at k ar 2k and 2k on .
so we don't need explicit length at all to repres these data structur .
we can just us arrai indic .
so that's the basic setup or the invari that we're go to maintain in thi data structur .
and now , what we're go to do is take a look at just a coupl of differ scenario that where we violat that invari temporarili and then fix it .
and that's go to give us the flexibl that we need to implement prioriti queue oper .
so on scenario shown here , is if for whatev reason a child's kei becom larger than it parent's kei .
so in thi case , we have an exampl where t , the node t here , it valu chang and it becom larger than it parent kei p .
so , the heap order condit is satisfi everywher , except at thi node .
well , it's easi to fix thi on .
all we do is exchang the kei in the child with the kei in the parent .
after that exchang , then , that would have t up here and p down here then the heap order condit is satisfi at that node becaus the parent wa smaller , so that on's smaller .
and so that on is still smaller so t is after it exchang up here will be bigger than both it children .
but the heap condit will be violat cuz t is still smaller than s .
so we have do it again , exchang it with s .
so we move up the tree , exchang the larger kei with it smaller parent , until we get to a point where it larger than both it children .
that's restor the heap order along the path from the place where it's violat to the root .
you can think of that as kind of like the well known peter principl where a node get promot to a level where it final can't be better than , than it's boss .
it's a level of it's maximum incompet .
and implement that in code is realli easi .
we call that the swim oper , it swim up to the top .
and if we have a node at index k and we know the heap condit is violat there , as long as we're not at the root and k's parent , k over two is less than a of k .
then , we just exchang it with it parent , and move up .
that's the swim oper to elimin a violat when a kei valu increas .
so for exampl , thi give us a wai to insert a new element into a heap .
what we do is , we add a new node at the end of the heap , so thi on posit over .
the thing is , rememb repres in arrai , on , two , three and so forth .
so the next empti posit in the arrai there's a place to put a new node .
and then we just declar that , that's part of the heap and that node , well if it's less than it parent , we're fine .
but in gener , we have to check whether the heap condit is violat and exchang it with it par ent as long as it's smaller and that's just perform the swim oper .
so if n is the number of item in the heap , defin to be in the heap we're go to increment it , store a new kei there , there and then perform the swim oper .
so that's a quick implement of the insert oper .
and notic sinc it's just go from bottom to top in the heap it take at most on plu log base two of n compar .
now there's anoth scenario where a kei becom smaller .
for whatev reason , a parent becom kei decreas , it might becom smaller than on or both of it children .
in thi case , the valu at posit two ha chang to h for whatev reason and that's smaller , in thi case , than both it children .
so how do we fix that violat ?
well , that on's also easi .
we figur out which of the children is larger .
in thi case , it's the s , and we exchang our exchang that on with the on that's violat the condit .
so that's move the smaller kei down .
after that exchang , then s is in posit two , and it's bigger than both p and h .
and the heap condit is onli violat again where h is sit .
and again , we keep go until get to the bottom , or get to a place where both children ar smaller .
and that's mayb a littl bit what happen when a , a new boss is hire from the outsid and then the two subordin struggl to take over that posit and then the bro , boss would get demot to it's level of compet .
and again , that level of flexibl .
here's the implement of it .
and again , it's quit straightforward us the index arithmet to move around in the heap .
if we're , and that's call the sink oper , cuz we're go down the heap .
if were at posit k , then what we need to worri about it is the node at 2k and 2k on .
and the first thing to check is find out which on's bigger .
it's either 2k or 2k on and so set j accordingli .
so that's j now , is , after thi st atement is the larger of the two children .
and don't forget to check that we're go off the end of the heap .
and then if , the k is not less than either on of those , then we're done .
if it is , then we exchang with the larger of the two children and move down the heap .
again , just a few line of code to elimin the violat when a kei valu in a heap decreas .
and that on we're go to us to implement delet the maximum in a heap .
so delet the maximum , we have to do two thing , on thing is the size of the heap ha got to go down by on .
the other thing is return the maximum .
well , we know that on that we want to return is the on at the root .
so we'll save that valu awai to return to the client .
and then , sinc it ha to go down by on the place to get the to remov the element from the heap is at the end of the arrai cuz it's now go to have to not occupi that posit , so we take that element and replac the root with it .
so i move the h up and actual , put the root valu there just exchang them but it's not longer in the heap .
now , that element which went from the bottom to the top is most like go to violat the heap order .
it's go to be smaller than on of it , both of it children .
so , we do a sink .
now in thi case to implement the lead max we save awai that valu at the root in max and we elimin loiter by null out that vacat posit then return the max valu .
so that's an implement , implement of the delet max oper for heap us sink where a kei valu that decreas , go down , goe down in the heap .
so let's just take a look at what happen with a , a real heap with the demo when we do these thing .
and you'll have a good feel for how thi data structur work .
so , we're start at some point where we have these ten kei in heap and it's heap order .
so we've drawn the data structur with the link , so we have an intuit for what's go on .
but all the program see is the arrai and grei at the bottom where t's in posit on , p and r ar posit two and three , and so forth .
so now , suppos that we're suppos to add s .
so to add it to the heap , that's go to go in the posit at the end .
then now we've ad it to the heap just by increment n , put it in there but now we have to bring the heap order back into condit .
and so that's go to , now that kei is larger than it parent so we're go to swim it up exchang it with it parent as long as it's smaller than it parent .
so , first thing it goe up exchang with the s , it's still bigger than p .
so we exchang it with the t and now we're done becaus s in not bigger than t and the heap order condit is now satisfi everywher in the heap .
so , with just two exchang we insert that new element in the heap in thi case .
i now suppos the next oper is remov the maximum .
so , we're go to take t and exchang it with the last element and then declar that to be no longer part of the heap .
so now we have to bring the heap order back becaus it might be violat at the root so now we invok the sink where we exchang that node with the larger of it two children until we find a place where it larger than both it children .
so s is the larger of the two children r and s and now h is still smaller than both it's children so we promot the larger , which is p .
now h ha no right child , just a left child and it's larger than that on , so we're finish with that oper .
we've remov the maximum and we still have our data structur heap order and our n kei store in first n posit in the arrai .
let's remov the maximum again .
again we take it out by exchang thi time g with the root and then decreas the size of the heap by on .
just take that out .
now , t he node of the root violat the heap border so we have to exchang it with the largest of it's two children , in thi case that's r .
again , g is not larger than it's two children so we have to exchang it with the larger of the two , that's o and now we ar done , we've remov the largest again .
now suppos we insert s back into the heap .
so that's ad it at the end , violat the heap order exchang it with the parent smaller and keep do until we get to a place where it's larger than it two children .
in thi case , s goe all the wai up to the root .
and it's all heap order again .
so that's a littl survei of some oper on a heap and you can see how everi oper is done with just a few exchang along the path from the bottom to the top or the top to the bottom .
okai , here's the complet java implement of a prioriti queue us the binari heap data structur .
it's actual not so differ from the elementari implement that we look at in the last section .
our represent is an arrai of kei and a size , that's the number of item in the heap .
for simplic , we'll show the code where the client give the capac of the heap .
we can us resiz arrai , in industri strength implement , the same that , we did for stack and other data structur where we us arrai .
so we'll build a new arrai of kei and we have to us an ugli , ugli cast becaus we can't have gener arrai in java .
and that , so it's compar and , and we need on more than the capac to handl thi thing where , we don't us posit zero .
so the prioriti queue oper , is the insert and del max that we show in the previou slide , is empti , is just check whether n is equal to zero .
we have the swim and sink function that we show earlier .
and then we have helper function less and exchang , that access the arrai directli so that the co de doesn't have to access directli .
that's a complet implement of prioriti queue in java .
and thi is , thi implement by itself is extrem signific becaus , it's realli veri simpl , optim represent of the data .
and onli a littl arithmet with arrai indic .
but as you can see by look at thi tabl , it give us a wai to implement prioriti queue where , both oper ar guarante to happen in log n time .
now , expert have work to come up with improv on thi and there ar slight improv possibl .
we can make the heap d wai rather than just two wai and depend on the frequenc of execut of the uncertain del max oper that might work out better .
there's an advanc data structur call a fibonacci heap , where insert ar done in constant time and delet max done in log n time on an averag over all the oper .
that on gener too complic to us in practic .
but still again , us theori as a guid mayb there's a wai to , to decreas cost a littl bit from binari heap .
and of cours , we cannot get down to have constant time for all oper .
why ?
well , we can sort with a heap by insert all the element and then delet the maximum of get a sort done and that would be in linear time if we had thi kind of variat .
if , if we have constant time oper for both insert and del max .
but for certain applic , we can get close to constant time for on or the other oper and that'll be us in differ implement .
now , there's an import consider , that , in , that we have to bring up relat to the program languag and thi is , a more gener consider than usual we bring into focu in algorithm but it's worthwhil mention .
we're assum that the client doesn't get to chang the kei while thei're on the prioriti queue .
and it's better not to ass um that it's better to arrang for that in our implement by us kei that ar immut , who's valu don't chang .
there's mani reason that immu , immut kei ar that program languag provid the capabl to build immut kei and , and thi is a fine exampl of on .
so and we'll talk more about that in a minut .
the other thing that , that , we didn't talk about in the implement should throw in , except .
if the client tri to delet from an empti prioriti queue and we should have a no argument constructor , and us a resiz arrai , to , account for gradual growth and shrinkag in an industri strength implement .
usual we provid two implement , on that's max orient , on t hat's min orient so that nobodi get's confus and thei're the same except the less and greater switch .
and we'll see later on , there's time when we want to add , expand the api and provid other oper like remov an arbitrari item from the prioriti queue , or give the client in the api the capabl of chang the prioriti of an item .
our sink and swim method ar good for make thi happen , but we'll , delai these implement until we need them in a more complic algorithm .
so what about mutabl ?
so in everi thing in java is implement as a data type , a set of valu and oper on those valu and the idea of immut data type , is you can't chang the valu onc it's creat .
so that's kind of like , when you when you , when you creat a liter valu to be assign to an integ , it ha that valu .
so here , here's an exampl sai us the data type for vector might be a wai to implement vector .
so we put the word final to mean that instanc method can't be overridden .
and not onli that , instanc variabl ar privat , thei can't be seen from the outsid and thei don't chang .
and so a constructor for an immut vector data type , it might take an arrai as it's argument , and that arrai ha got valu store in it , sai doubl , and those ar , those can chang but what immut implement would do would be to copi those valu into the local data arrai instanc variabl and then those valu ar not go to chang .
and the instanc method won't chang them and the client can't chang them .
so that valu stai the same .
lot of , implement , data type implement in java ar immut , like string is immut .
when you creat a string that valu doesn't chang .
if you want a new string , you have to creat a new string , us concaten or some other oper .
and the same with the wrapper type , like integ and doubl , or color , and , what lot of thing .
wherea on the other hand , sometim , the whole purpos , of a data type is to maintain a chang valu like a good exampl is like a counter , or a stack .
so you wouldn't put those thing on a prioriti queue cuz the valu is chang but the other on you would .
so the advantag of immut and again , mayb thi isn't the place to realli sell those advantag more for a program languag cours is that it , it realli simplifi debug .
we can be have more confid that our prioriti queue oper ar go to work correctli if we know that the type of data that's on the prioriti queue is immut .
if the client could chang the valu , how do we know that the heap border oper is preserv ?
if we want the client to be abl to chang valu , we're go to provid method for that purpos as i just mention .
and there's mani other reason that peopl us immut data type .
there is a disadvantag that you have to creat a new object for everi data type valu but for a lot of applic that disadvan tage is not view to be signific compar to the advantag .
here's a quot from a on of java's architect , josh black .
class should be immut unless there's a veri good reason to make them mutabl .
if a class cannot be made immut , you should still limit it immut as much as possibl .
and mani programm live by that kind of precept .
next we're go to look at the us of the binari heap data structur to implement a clever sort algorithm known as heapsort .
so here's the basic plan .
what we're go to do is we have our end kei and we'll have them in an arrai .
we'll view that arrai as eventu be a max heap .
so what we have to do first is to rearrang the kei in the arrai to heap order it .
so just make it so that everi kei is larger than it's two children .
and for exampl , the largest of all the kei is at the root .
and then , the next phase would be to take that heap order arrai and get , get it to be a sort result in , in place .
and again , the , heap is store in the arrai , with the first kei posit on , next to posit two and three and like that .
so the end result would be like that , with , no kei in the heap , but all the kei in the arrai in sort order .
so it's a littl exercis in abstract .
part of the arrai is the heap .
part of the arrai is the sort sub arrai .
and eventu we bring it down to the whole thing be sort .
it's veri littl code beyond the basic heap code that we've look at can get thi implement .
and that's call heapsort .
let's take a demo of how heapsort work in our exampl .
so the idea is we're go to us a bottom up method .
so all that mean is we start with an arrai in arbitrari order and then we're go to work from the bottom up to make sure that it's heap order .
well all the node with no children ar heap order , thei ar onli a size on , the first on we have to worri about is thi on here the root , the root .
we haven't examin yet , it's children ar heap order so it's a small heap of size three that mai not be heap order .
in thi case it's not becaus on of the children is larger , so that's where thing ar go to start .
we have a lot of on node heap and then we're go to have to perform the sync oper on thi on , that node five , that's , in thi case just to chang it with it's parent .
and then proceed in that wai , move bottom up or move from right to left , the next thing we do is but then worri about a three node heap that's heap order and we're fine .
now we'll move over to the t and again , that's the root of a three node heap that's heap order except at the root .
we mai need to fix it with the sync oper .
in thi case noth is requir becaus it's larger than it children , so we have a three node heap .
and then we move on more to the left , now we're look at the r .
again root of a three node heap mai or mai not be heap order , we do have to do the sync oper .
in thi case that bring the x up .
a three node heap .
now we go to two .
now that's the root of a seven node heap .
we know the two three node heap that ar the children ar heap order but we mai have to correct the heap order at the root so we do a sync on two .
and that's go to involv , exchang with the t , becaus t is larger than o .
and exchang with the p becaus p is larger than o .
now that heap is a seven node heap that's all heap order , and then the last thing is to do the root of the whole thing and again , now the two sub tree ar heap order , that's what we mean by bottom up , we took care of the heep order from the bottom up .
and so we'll do a sync on the s and bring it into a heap order , so that's with just a few exchang we got that whole arrai heap order , and now what we want to do is take advantag of the heap order in the arrai to do a sort .
and the concept is veri simpl .
right awai we have the maximum element in the arrai right at the root , we want that to be at the end so that's what we're go to do and that's what we're go to do is just put it at the end .
we exchang the element at the root with the last element .
pull it off the heap and then that's our exampl .
we might have violat the heap order condtion at the heap right now .
so now we have to do a sync oper on , on the e .
and so , it's larger than , it's both children , and the larger of the two children is t , so we promot the t .
and the p is larger , the two children promot that and then final , the e come down to the bottom .
so now that's on step in the sort , we got the largest element off .
now the next largest element in the arrai is now at the root of the heap .
we're go to do the same thing , exchang it with the last element in the heap .
then now that t is in it final posit in the sort arrai , we take it off the heap .
so now , we've got a heap with nine element and two of the element in the arrai ar alreadi in their final posit .
and now thi on's not heap order , so we have to exchang over the largest of it two children .
in thi case that involv regard the s and the r .
now it's heap order .
so that's the end of the two step in heapsort .
and then we just keep go .
pull off the largest element from the heap .
exchang it with the .
element in the heap in the largest posit in the arrai which bring that element into it final posit in the sort arrai .
and then adjust the heap order with the sync oper .
so that e again is go to come down and now it onli goe down on step in thi case .
so now r exchang with m .
it's in it's final posit and you can see down at the bottom , the larg element in the arrai fill in , in their final posit , in the , the left part of the arrai is repres the heap .
the r goe off the heap , do the sync oper on the m , and now we have a heap order arrai .
so now do the p , exchang that with the a .
take it off the heap .
do the sync oper on the a .
now we're go to do the o .
exchang that with the e .
take it off the heap .
do the sync oper on e which involv promot the larger of it two children , until it get to the bottom , or a place where it's larger than both it children .
so now we have , just five element left .
we'll , get the m .
do heap order on the , heap of four and that onli involv on exchang .
now we get the l .
a exchang for the larger of it two children .
while , thei're both the same , so i t goe with the left on .
that's the heap of size three .
pull off the first e , it's alreadi heap order .
pull off that e .
and , now we ar left with onli on element in the heap in thi in the first posit , so there is noth to do .
so with a seri of in exchang and then sync oper , we pull the sort arrai out of the heap .
okai .
thi , slide summar the code for , heap construct .
and as you can see , it's a on liner .
we go backward through the heap .
start at n over two becaus the , n over , half of the , right most half of the arrai is just littl heap of size on .
we just go backward do a sync start at k .
so that's the first piec of code for heap order an arrai with arbitrari valu and then these diagram summar the sync call that , that we just went through in the demo start at five , four , three , two , on .
as you can see , onli on , two , three , four , five exchang ar need to bring thi into heap order .
then the second pass again that's onli a two liner , we exchang the first element with the on at the end and then decrement the size of the heap and then do a sync oper .
and these diagram summar the sync oper that we show in the demo .
on everi smaller heap , now we continu just perform sync oper at the root until we get a complet sort arrai .
so given the sink implement , we had done a on liner for the first pass and a three liner for the second pass so that give a complet implement of heap sort with the code that we have given so for , so far .
there's is on littl detail when you ar sort an arrai of cours posit zero come into account and we've been build our heap from posit on .
so , but we can take care of that in the less and exchang method by just decrement the indic in those method to have it work as if the arrai were zero through n .
that's a littl implement detail , but otherwis thi is a fine sword implement , that actual is veri littl code , and it got a place in , in the theori of algorithm , that i will talk about in a second .
thi is just anoth trace without the data structur shown , to just show in our standard wai , the element in black and red ar the on that ar touch and the element in grei ar the on that ar not touch at all .
and to just show that thi thing get the sort done with touch rel few element .
that's a trace .
let's look at an anim , an anim with heapsort is interest to watch so the construct of the heap happen in a blink and now it's pull off the largest element , move from right to left .
so again , a veri effici wai to get a sort job done .
so what about the mathemat analysi ?
well the mathemat analysi , for the heapsort part is pretti easi .
n time , we're do a sink oper , and the size of the heap is at most lg n so it's n lg n .
the construct , actual , it turn out although it's a littl more complic to prove , that it alwai us just a linear number of comparison exchang .
and that's an interest result in itself .
you can build a heap from n valu in linear time .
and then , and then lg n more time .
you can sort from that heap and that's signific be , signific becaus it's the first sort algorithm that we've seen that is both in place .
and manag to get the sort job done with guarante analog and compar .
mergesort doesn't do that .
it take linear extra space .
quicksort doesn't do that .
it take quadrat time in a wors case even though we make that unlik by random shuffl .
it still take quadrat time in the wors case but heapsort doe both .
now there is more complic version of mergesort and quicksort that can do thi in theori but heapsort is pretti simpl algorithm that get both done , so in a job interview somebodi ask you what's an in place sort algorithm that's guarante n lg n ?
your answer's go to be heapsort .
now in practic heapsort is actual not us that much for a coupl of reason .
and thei might ask you these on your job interview too .
first thing is the inner loop is longer than quicksort .
like mergesort there is more thing to do in the inner loop .
there is that compar ar the two children bigger , then compar .
so there ar two compar that get done at n lg n time .
and then there is some that arrai index arithmet .
the other thing that is probabl more signific on modern machin is .
that the refer to memori ar all over the place when it's a huge arrai , so it's not a good algorithm for a situat where there's cach which is almost everywher nowadai .
it doesn't have a local refer , like quicksort doe .
it's alwai refer to someth that's nearbi someth els that i just refer to .
so if a big block of thing come into memori , there's no more extra cost , wherea heapsort is go to look far awai from the current place as it goe down the tree and that make it slower in a lot of situat .
and on the other thing is it's not stabl , sometim peopl choos to us mergesort in practic becaus of the stabil but heapsort isnot stabl for the usual reason that it doe long distanc exchang that might bring item that have equal kei back out of order .
so that , that , that's our full summari of sort algorithm to and complet our treatment of sort algorithm with heapsort .
and thi is just ad the heapsort line to the tabl .
it's in place we don't us ani auxiliari arrai it's not stabl , but it worst case guarante time is proport to n lg n as well as the averag and , and the best thi is not a result but that's also the case so it's n lg n guarante n place , but it's not stabl , and we still have the hope that somedai somebodi will develop a simpl in place stabl worst case n lg n algorithm but we're not quit there yet .
and that complet our treatment of sort algorithm with the heapsort algorithm .
now , look at an interest applic of prioriti queue that is actual repres of whole famili of a critic import applic in applic of comput .
it's call event driven simul .
and the idea is we want to studi some properti of the natur world by simul it .
and that's someth that's veri , veri common in , in scientif inquiri nowadai .
and thi is a veri natur idea .
and actual , the idea goe back to einstein .
so , we want to simul the motion of n move particl that might collid with the prioriti .
thi , thi kind of stimul is enabl by prioriti queue .
and without someth like prioriti queue , you couldn't do thi for a larg number of particl becaus it would requir quadrat time and simpli can't be afford for a huge number of particl .
so , and let's take a look at how we can possibl make thi happen .
so we us a simpl scientif model call the hard disc model .
and then , thi is just for simplic to get thi done and just part of a lectur .
clearli , these thing can be extend in mani wai .
so , we're go to have move particl that either collid with each other and with the wall .
and each particl is a disc that's got known posit , veloc , mass , and radiu .
and there's no other forc involv .
it get more complic if there's more forc , like graviti involv .
and thi point by itself is veri signific .
as i mention , it goe back to the studi of physic with the try to understand the pressur and temperatur in einstein's famou experi on a pollen grain show that their motion wa brownian and random .
so whether it's individu atom and molecul or some bigger kind of particl .
it's a complex dynam situat that is better understood through comput simul .
and nowadai that mean prioriti queue .
so , as a wa rm up , here's code to implement bounc ball without the collis .
and thi is an elementari program exercis that is the , the code at the left ha the effect shown at the right .
so , we have a data type call ball that repres just on of the particl and ha instanc variabl that ha the posit and the veloc .
so , that's why we make a bunch of them and then we have a , a while loop which is just everi <num> millisecond clear the , the whole draw and then move the ball a littl bit and then draw them in their current posit .
and then the onli to move oper doe is to updat the posit of the ball by the veloc , which is just anoth number and then it doe the bounc off the wall .
if it happen to hit the left of the wall then you reflect the x coordin in the right wall , you reflect the x coordin bottom to top , you do the same for the y coordin .
so , thi the is an easi program exercis given the right displai primit .
and it's a good exercis in object orient program show how just on implement then we can us that same implement to simul a number of instanc .
so , that's our start point in term of the code .
so thi is the implement of the ball class .
so , it's got posit and veloc as i mention , and everi ball ha a , a radiu .
and then there is a constructor and mayb we have a constructor that take argument that would initi the posit and the veloc or mayb initi them to a random posit if there's no argument .
and then , here's the move method .
and the move method again , most of the time , just take the x and y coordin and add the current veloc time the speed constant .
the dt speed , speed variabl that's given as argument dt .
and then these test ar for whether it hit the wall in which case , you have to flip the x or y veloc .
and then draw , it's just us standard draw .
just draw the ball .
so , that's all the code for do the bounc ball simul .
now , what's miss in thi is what happen when the ball collid with each other .
and to cope with that we need to do both .
a littl bit of high school physic and a littl bit of basic comput scienc .
the physic problem is exactli what happen when two ball hit and thei bounc off each other accord to some well understood physic process , and that's the high school physic .
and the cs problem is how and when to we exactli do these comput for each of the ball .
and how can we do it effici that is in , in log n time versu quadrat time .
becaus if we have a comput process that take quadrat time , then it's not go to scale , we're not go to be abl to do larg number of particl .
simul in the real world , usual , we wind up do huge amount of data and we cannot have a quadrat algorithm .
thi is just first indic of that of why if you want to do thi simul , you better know about some data structur like prioriti queue .
if you try to do it without it , you're not go to be success .
all right , so , let's take a look at what happen .
so there's a number of thing that you might consid try .
so , on idea is the so call time driven simul .
and we just sai , we're go to updat everyth everi dt second .
then we go ahead and then we could check if there's a collis , if the two ball , piec of the two ball ar occupi the same space .
and if there is , then we could roll back time just a littl bit and i'll try to figur out exactli , the moment of which thei collid and then figur out how the posit and veloc should chang accordingli and then continu the simul .
but thi ha a huge problem .
the first on is that you have t o check all pair of ball for overlap so that's quadrat , so it's go to be realli , realli lot of overal textur you're not go to be abl to do it for a huge , huge valu of n .
but the other thing is even if n is small if you do a veri small dt , then you're just do thi calcul over and over again and there's just too much comput move the ball littl bit at a time .
on the other hand , if you try to improv thing by make dt too larg you might complet miss a collis as shown in the exampl at right .
so figur out the valu of dt that would realli work is a huge problem for the time driven simul .
instead , what we want to do is call an event driven simul .
and thi is a veri gener concept that's us in all kind of context .
and we ar go to chang thing when someth happen .
so , sinc the onli thing that matter is collis , we ar go to figur the particl move in a straight line , between collis .
and what we ar go to do is focu onli on the time when the collis ar go to occur .
and the wai we ar go to that , is to maintain a prioriti queue and that prioriti queue is go to have all the possibl collis that could happen in the futur and thei're go to be priorit by time .
and when we remov the minimum element from the prioriti queue , that's the next collis that we have to deal with .
and so we have two phase , we have predict and resolut .
so , that's sometim t , we can take two particl .
we know their posit and veloc shown at the bottom here and we can predict exactli the moment , which thei'll collid assum that someth els doesn't happen to them in between and then so thei will put that predict collis time on the prioriti queue and later on , when that time come to pass we will be right at moment when thei collid and we can figur out what to do .
now , there is a possibl that someth els happen to t hem in between and we'll talk about that chang , too .
so , we have to do collis predict , which is given posit , veloc , and radiu when's it go to hit with anoth particl or , or the wall .
and then there's resolut which is to figur out how to chang the veloc of the particl accord to physic law .
now thi part i'm not go to talk about in that much detail right now becaus it's high school physic .
and so , i think most student have had high school physic and will be abl to do , do thi math or at least be convinc that the code that doe thi math is correct .
so , if you know that you have a particl that's at a certain posit or x or y and ha got a certain veloc , the x in the x direct and y in the y direct , then you can from the distanc to the pro , vertic wall you can figur out how mani second thi is go to take until it hit it .
it's basic that distanc divid by the by the veloc .
and so that's the predict .
and then , the resolut .
when it hit the wall is , is just go to chang the veloc .
so that's in , you know what the posit is .
so that's just an exampl of collis , of collis predict , when's it go to hit the wall and resolut what do you do when it get to the wall .
when you have two particl there's definit more math .
and again , thi is high school physic .
and we're not go to test on it or even go through the detail .
but it's just a littl bit of arithmet with the veloc and posit to deal with what happen when , when how to predict when a given particl is go to collid with anoth given particl know their veloc and posit .
so , you have to take both veloc and divid their distanc by those and , and so forth .
so there's simpl formula to tell us what to do and we can also figur out the formula for what we do o nce thei do collid .
and again nobodi's claim that thi is easi but thi is the physic part and it's work out and it come from newton's second law .
and , and , anybodi take high school physic will , be abl to deal with these formula and the rest of thi mai have to go to a refer book to get up to speed on them .
but onc it's reduc to code we can be , it might have some troubl debug at first but at least we can be convinc that it work .
but now , let's look at the comput scienc code .
so , thi is just extend our ball data type that we us for the bounc ball that didn't collid to take in , into account these extra thing .
so , our will have mass , so there will be some big heavi on that make thing more interest .
and there's also a variabl call count , which is the number of collis of particl have been involv in .
and that's us for a coupl of purpos .
so , we're go to need a bunch of procedur which do the predict and the collis resolut .
i want , what's the , given a particl what's the time till we hit that particl ?
what's the time till we hit vertic horizont wall ?
and the same thing is if we're at the point where we're hit a particl , what would we do , the , the same wai with the vertic and horizont wall .
so , that's the skeleton .
we need those procedur that implement those physic rule for everi particl .
and , and thi is what thei look like and again thi is high school physic so we're not go to do it in detail other than to point out it's realli not a huge amount of code .
lot of the xs and the ys and the vs but realli not a huge amount of code .
and the other point is we're go to return infin if there's no collis at all so that it's go to keep , keep that on the prioriti queue , that ran on the prioriti queue forev .
okai , so that's the procedur that we need and then thei're similar on for the horizont and vertic wall .
so now , let's look at the main loop for the event driven simul .
so , the first thing is we're go to for everi particl we're go to comput the next time that it might hit everi horizont and vertic wall .
well , actual if it's go awai from a wall , it's not go to hit it so that would be infin .
but if it's go toward a wall , then we'll comput the time .
and then that's a time in the futur and we'll put that event on the prioriti queue with that time as the kei .
and then , we'll do the same thing for all pair of particl .
so , we do have a quadrat initi phase that we perform just onc to get the prioriti queue fill up .
now , all collis ar , might not happen so we might have two particl that ar on a collis cours that and we're go to predict that point for both of those particl , you know , even right at the begin .
but it might be the case that there's a third particl that knock on of those out befor that thing happen and that event would be invalid .
so , the simul ha to be care to take that into account .
but that's not difficult to do .
so , here's what the main loop is .
so , we're go to take the next event from the prioriti queue .
that's the next collis that's go to happen from all our calcul .
there's on collis that's go to happen next .
then , we test whether that event ha been invalid .
and we do that by us that count field in the particl .
so , then that tell us what time it's go to be next .
so , then we have to go through all the particl and chang their posit on a straight line trajectori , where would thei'll be after that much time ?
then we have to take the two particl that collid and chang their veloc .
thei bounc off on anoth .
now those two particl' veloc have chang , essenti that invalid the futur collis involv those .
and then we , what we have to do is for those two particl is go through and predict the futur collis with ani wall and collis with ani other particl .
and put all those new event on to the prioriti queue .
but that's it .
you got two particl , chang your veloc figur out the futur collis of those particl with the wall and updat the prioriti queue and then the main loop is take the next thing off the prioriti queue and keep go .
that's the code that we'll look at next .
so we have a , a , a bunch of convent just to reduc the code .
and if we thi the , the thing call event which involv it sai between two particl , someth is go to happen at a certain time and we're go to adopt the convent that , if , neither particl is null then we're talk about two particl .
if on of the particl is null then we're talk about a wall , a vertic or horizont wall .
and if both particl ar null we're sai we just want to redraw thing .
that's a bit of a hack , but it cut down on a lot of code .
our compar to is by time .
and then again , we need an , is valid to check about interven collis .
and then here's the skeleton of what's go to happen with the collis system which is the kei thing is thi predict method that take a particl as argument , and add to the prioriti queue , all the possibl collis involv thi particl .
so , it's go to go through everi particl and call the time to hit method for that particl .
and then , it'll put an event on the prioriti queue for that time , thi particl with that particl .
and then , it'll also put an event for the vertic wall and the horizont wall , again , us thi null convent to sai that the event second argument null is vertic .
first argument null is horizont .
so that's a kei method t hat get us in the simul for each of the two particl that ar go to collid .
so , now we can look final at the main event driven simul loop .
so there's build a prioriti queue .
there's do thi predict for everi on of the particl .
and then , also we're go to put as the first thing that happen alwai a , an event that sai redraw everyth .
so that's just a , a wai of make sure that the simul keep proceed .
it's an easi wai to get thing drawn .
okai .
so , now the main loop is while the prioriti queue is not empti we're go to pull off an event .
we're go to test whether it's valid .
and that's just checker if anyth happen with those two particl .
we're go to pull off the two particl and then we're go to all , we're go to move all particl by the amount of time that ha elaps sinc the last event .
and then , we're go to test which of the four type of event that it is .
it's either redraw , bounc , b of a or , or bounc off a vertic wall or , or a horizont wall .
and then we'll go ahead and do the predict of each of those particl , a and b , against all other particl .
that's the pretti much all the code for the simul .
so thi is data driven code .
so , on thing we can do is just run it for a <num> ball in random posit at random veloc .
but what's nice about data driven code is now that the code's work and again we , we're not sai that thi is a trivial code to write but it's definit manag .
and it's enabl by prioriti queue .
without prioriti queue , it would be quit a bit more complic to figur out how to do thi .
and also , it wouldn't be reason effici at all for larg data set .
so , that's a , a simpl simul to just gener random posit .
peopl might be interest in thi on .
now thi isn't exactli precis wh at would happen in the real world mainli becaus we didn't put in the simul what happen when three particl ar touch or there's two touch in anoth on hit them .
and also nobodi rack up a , a set of billiard ball such that all fifteen ar touch in all place .
so life can be complic when you try to simul the natur world .
thi is a littl bit about einstein's experi .
if you got on big particl like a pollen grain and lot of littl particl like atom molecul and bounc against it the big on is go to move about randomli .
and then thi is anoth famou physic experi show diffus .
and there's mani other thing that you can do with thi basic collis system .
if you have huge number of particl and you measur the number that hit the size and the frequenc with which thei hit thei side you can do experi relat temperatur and pressur and mani other thing or do three dimension version .
again simul of the natur world is an increasingli import applic of comput and need effici data structur like prioriti queue to get it done .
welcom back .
in thi and the next few lectur , we're go to look at symbol tabl .
a fundament and extrem import data type that have led to all kind of fascin implement and we're go to see at sever of them in thi cours .
to begin , we'll take a look at the api and some elementari implement and variou oper that peopl want to perform on symbol tabl .
start with the api .
the idea behind symbol tabl is to implement the follow abstract .
we ar go to have kei , like our kei in prioriti queue but , the whole idea that we ar go want to associ , valu with each kei .
so two oper that we're go to perform in symbol tabl is the insert oper where we're realli put a valu , a kei valu pair into the symbol tabl , a valu with a specifi kei , and then given a kei we want to search for a correspond valu .
those ar the two basic oper .
now the kei and the valu can interchang role .
and that's , that's why we , have the abstract to separ them .
so for exampl , a domain name server might have a look up where you've got a tabl that's got an ip address , and a url associ with that ip address .
and differ client might want to us thi data in differ wai .
on might want to us the url as kei .
given the url , give us the correspond ip .
the address .
anoth client , might want to us the ip address as kei , have an ip address , give me the correspond client .
so those ar just a coupl of exampl .
thi is a veri fundament and basic abstract .
in the list of applic is huge , in fact almost ani comput applic system is go to have symbol tabl or multipl symbol tabl at it core , all the wai down to the basic memori system of the comput or the network system that your comput access inform depend on .
you can think of it intuit , as , like a dictionari .
well , there us to be book , and peopl would open up those book to look for a word , to find the definit .
nowadai , you're more like , to do that onlin .
or , when you're try to find a song to download , you provid the name of the song .
and then a valu will tell you what comput to go to , to get that or in commerci comput , the kei might be an account number , and the valu might be the transact detail , for that account .
web search is someth , we all do multipl time everi dai .
and the kei is a keyword , or a list of keyword .
and the valu is a list of place where that keyword is found .
and there's mani , mani other applic , includ scientif applic where sai in genom peopl us simpl tabl to keep track of find marker in the genom and again mani other applic .
so , it a veri fundament concept and we will look at plenti of applic .
but first we want to look at some algorithm so the wai that it's conveni to set up a symbol tabl is to implement the so call associ arrai abstract .
and the idea behind that is to think about just associ on valu with each kei .
and well it's like in java arrai of integ sai .
we're onli , our kei in that case ar indic that ar restrict between , to be between zero and the arrai size .
but we're onli associ on valu with each index .
we think of store the valu in the arrai posit given by that index .
and a good wai to think of a symbol tabl is as shown in the right here .
when we put a kei valu pair onto the symbol tabl .
think of that as us the kei to index an arrai , and store the valu there .
now thi , isn't legal in java if kei is not an int .
and , and we're go to do thi gener .
it can be ani type of data .
but , it's a good wai to think about it .
and then , to retriev it , you just give that same kei , and it'll return the valu .
so that's our , two primari oper .
put a kei valu pair into the tabl .
so that is associ the valu with kei , and then get the valu pair with the kei .
now th er's particular rule for null that i'll talk about in a second .
and then to properli maintain the symbol tabl in a dynam situat in mani client you want to support and delet oper and contain is , is simpler oper than depth .
it's conveni for mani client where it just tell us whether there's some valu pair with that kei in the tabl isn't in size .
and then anoth thing that you might want to do is iter through all the kei in , in the tabl .
so those ar the basic oper that we're go to want to implement to get the associ arrai abstract .
and then there's mani , mani possibl for client and we'll look at some later on .
now there is a coupl of convent around null .
and these ar not critic , but thei make it bit more conveni for sever implement .
so we ar not go to allow null valu , we cannot associ null with ani kei .
and then we ar go to adopt the convent that the get method return null , if the kei is not present in the tabl .
and also the associ arrai abstract is the put method , well , overwrit an old valu with a new valu .
so these ar our consequ .
so , it's , the contain implement is the same for all our , symbol typal implement .
if get return , a non null valu , then there's a valu correspond to that kei in the tabl if it return null .
it's not get return null kei not present .
and the other thing that we could do is we can us null in some situat or temporari situat to implement a lazi version of the delet oper .
we can associ the kei with null intern and then a client won't know the differ whether that's in there or not .
and some algorithm take advantag of the abil to us null in thi wai .
these ar just convent and somewhat detail but it's import to point them out at front .
so now , we're go to want the valu to be ani gener type at all , but the kei type we have to make some natur assumpt about them .
and actual there's differ assumpt that we make in our implement depend on the applic .
though on of the most us on is to have compar kei .
just as in sort algorithm we'll assum that the kei have valu that have come from a total order .
and we can us compar to , to compar whether on kei is less than , than other or not .
thi is for two reason .
on is we can get more effici app implement if we can us the order of the kei to help us find our wai around the data structur .
and the other reason is that we can support a broader set of simpl tabl oper that ar veri conveni for mani client .
and it's veri typic for kei to come from an order set .
now , for exampl in the dictionari applic or if kei ar sting or number .
or account number or mani other situat .
so if thei're go to be compar we might as well take advantag of it .
both to get more effici algorithm and to be abl to take advantag of a broader set of oper .
now in other situat , mayb thei're not compar .
and all we're allow to us is to , us the equal oper .
that is everyth everi type of data in java ha to support and equal oper that read out to test whether thei're equal .
and there's anoth famili of method where there's no order .
then there is a special method call hash code that help us inject random into the process and that's built into java and also some classic algorithm depend on that .
we're go to start out with the compar mostli .
and again , as with prioriti queue , the best practic is to us immut type , and experienc programm know thi and it's not difficult to arrang for the natur type of data that peopl ar go to us for simpl tabl kei .
unreason to expect the implement to work well if the client can chang the valu of kei that ar in the tabl .
if you want that , you have to provid that as a specif oper .
in the case of symbol tabl , we ar not go to do that .
you have to remov it and put it back in .
all right , so there's equal .
now , equal again we're get into program languag issu but it's still it's import to be explicit about what's go on with , equal .
how do we test if two object ar equal ?
so , the job ha got requir as for compar to in , here's the basic requir about equal .
there is a method that all java for equal , but the default implement is simpli to test whether the refer ar equal .
ar those precis the same object or not .
usual in applic when we want to have someth more gener than that and have a concept of a valu or like a kei in our case .
and then we want to know if two refer refer to object that have the same valu and we want to call that equal , that's what equal is about .
so anywai we're requir to make sure that x is alwai equal to x and that , x y is the same y x , and if x y , y z , then x z .
so that mean that mathemat term equal is call an equival relat .
and also no , no object is equal to null .
so those ar absolut requir for java .
and again , the default implement is to check whether thei refer to the same object .
and that's rare what we want .
java system program mayb want that .
but client program usual have custom implement that ar base on compar some sort of valu and the standard built in type of the java languag ar go to have those custom implement and we can reli on them do what we expect .
if we're go to implement our own type and then us those type as kei and symbol tabl you have to exercis a littl bit of care and we'll talk about that briefli .
sai we have thi simplifi date implement we talk about befor it's a mutabl type and everi dai it's got a month a dai in a year .
it seem like it should be easi to implement equal basic , we're just go to check that all the signific field ar the same .
two date should be equal if thei have the same dai , month , and year .
and if ani on of those ar not the same valu , then just return fals .
so that seem as if it should work .
but that doesn't have all the characterist that we need in a job implement .
and so all of thi code in red show a model for what you might do if you're go to implement your own type of data equal for your own type of data .
so we shouldn't us it in connect with inherit so we don't us inherit that much so i won't talk about that the type of the argument in the equal must be object , do you think it should be date ?
and expert debat about that , and peopl who ar interest can look on the web for that kind of date .
if it is the case that you happen to be test two object that ar the same object for equal , you might as well , optim everyth and just test that .
if y is a refer that's point to the same object as thi object just return true becaus , if you're go to test the valu thei're go to have the same valu anywai .
and that's a good optim for lot of , situat .
why go through all that risk to that code if you know right awai thei're , equal .
there's thi test for null , that ha to be there .
and if not there can lead to nefari plug and , and , unusu problem .
so on your equal test you'd better , test that , the client didn't give you null .
thei have to be in the same class .
and while there's a coupl of differ wai to check about the same class , and that's anoth religi debat .
that we'll ignor .
we'll us , get class and that's someth that's got to work or thei'll get , thei'll get an except in thi later code .
becaus sinc y had to be an object , now we have to , cast it to a date .
and then it better be the right class , or els it's not go to have these field , that , we can test for .
so , detail but anywai , you can us thi code as a model to implement equal for ani data type that you might wind up us as a simpl tabl kei .
okai so that's a standard thi is just in word the standard recip for user find , type optim for refer equal , check against null .
make sure thei're the same type and do the cast , and then compar all the similar , signific field .
it could be that if on of the field is an object , then you us that object's equal , which reappli the world the rule recurs .
and then if you ever feel that it's an arrai you can go ahead and try appli it to each entri .
and there's implement in java .
you don't want to us a , a .
b .
that check if those arrai ar the same object .
and that's not what you want you want to check that all the valu ar the same .
and if it's arrai of object you can see that test for equal can actual involv a lot a code and a lot a cost .
all right so and certainli you want to follow some of these best practic .
so field that ar most like to differ .
those ar the on you might want to compar first .
and your also go to want to make compar to consist with equal .
the rule gener if we're have a compar type we'll us to compar to .
if we don't have a compar type then we'll us equal .
okai , so now let's look at a coupl of test client befor we look at ani particular implement .
so thi is a test client so symbol tabl ar st is the type , symbol tabl , thei're gener on kei and valu .
and so thi , thi statement build a new symbol tabl with string kei and integ valu that's go to associ integ with string .
and so what the test client is go do is go to a just go in a loop as long as standard n is not empti , and it's go to read string , read a string off standard input , and then put it in the symbol tabl associ with the valu i where did it appear in the valu input .
so thi is an index same client where we associ each string with it posit most recent posit in the input .
and , notic it's an associ arrai implement so for exampl , we have two es and at the end e is a associ valu twelv .
the place where it most recent appear .
we could also keep these thing in a bag and do a client that doe all the posit that appear .
thi is a simpl index client that we us for our trace .
for analysi for bigger problem we'll us a client call the frequenc counter client .
and so that on is go to read a sequenc of string from standard input and print out the on that occur with highest frequenc .
so , so for thi small data from the begin of dicken' tale of two citi if we run a frequenc count , or the frequenc counter client .
and thi first argument is just ignor word of fewer than thi mani letter .
it'll sai that the most frequent word where there's no word that appear more frequent than it which appear ten time .
and we'll want thi client to work well for huge data set so liepzeig is a , a data set from the web of about twenti million word .
about half a million distinct on and in that corpu , the word govern appear about <num> , <num> time .
so , if you have a quadrat time algorithm for implement simpl tabl or linear time for each oper .
you're not go to be abl to run thi client in a reason amount of time for a big amount of data .
so that's the client that we're go to us for analysi .
here's the code for that frequenc counter client .
again , it's similar to the other on , we're creat a simpl tabl that associ string with integ .
we take that command line argument which is the minimum length that we care about .
we will read a new word .
we'll ignor the short string .
just trap out if the word length is too small .
and now the integ we ar go to associ with each word is the frequenc of occurr of that word in a symbol tabl .
so if word is not in the symbol tabl , we'll put it there with a frequenc of occurr of on .
that's the first time we saw the word .
if it is in the symbol tabl , we will just over write .
the old valu , which is st get word , with the new valu , st ge t word plu on .
so increment the frequenc in the symbol tabl .
so that's , read , thi loop read in all the data and associ each word with it frequenc of occurr .
and then we'll have a client that us the iter , go through all the kei in the symbol tabl .
it'll get the valu associ with each kei .
and if that's bigger than the maximum found so far , we'll save that awai .
and then print out the , the word that occur the , the most often along with it frequenc .
so thi is a us and non trivial client that's enabl by symbol tabl .
and , but it won't work well unless we have an effici symbol tabl oper .
and we'll us thi client to compar differ symbol tabl implement .
so that's the symbol tabl api .
and next , we'll take a look at implement .
next , we'll look at some elementari symbol tabl implement .
these ar so simpl that we won't go into much detail .
but still , it's worthwhil to take a look at them to set the stage for the more advanc implement we'll consid next .
well , on thing we could do is maintain a link list .
we could keep it in order or keep it unord , thi version keep it unord .
so , we ar go to have node in the link list , that have kei valu pair , thei have everi kei in the symbol tabl and a valu associ to that kei .
for search , we have to , sinc it's unord , scan through the whole list to find a match , a kei that's there .
for insert , i would also have to scan through all kei to find the place to updat a valu , if it's a valu that's alreadi there .
and if there's no match , then we could add it to the front .
so here's our simpl client for trace .
so if we associ s with zero , we just had it that's our on node link , link list that's got that inform .
associ e with on that's not there , so we just add it to the begin of the list .
a with two , r with three , c with four , h with five , and so forth .
so now , when we associ e with six , we have to search through the list to see if there's an e .
in thi case there is , and then we updat , just updat that valu .
that's the associ arrai abstract .
it's possibl to implement symbol tabl that allow multipl valu with the same kei and so forth .
and that lead to differ type of client , differ type of implement .
we're go to stick to thi associ arrai abstract and no duplic kei in the symbol tabl becaus it both simplifi implement and lead to simpler client code .
okai , x7 is a new valu a8 we found a in there and updat the valu eight and then m9 , p10 , l11 ar all out there , and thei go at the begin , and then the last on chang the valu at e again , twelv .
so , thi is a , a simpl implement thi as a exampl of link list process .
slight modif of our stack and queue code .
and we will skip the detail and just a note that what's the cost of implement thi .
well if there's been if there ar n thing on the symbol tabl , you have to , for both search and insert look all the wai through .
and if everyth's random then on averag , you onli have to look halfwai through for a success search .
and well , you still have to insert anoth issu is for mani client if the kei ar order it's nice to be abl to iter through the symbol tabl in order and thi on by definit doesn't provid that .
and thi on just us equal .
so , the kei don't have to be compar for thi it just us equal .
so our challeng is to look for method that give us more effici implement than search and insert search oper .
and we've alreadi look at an algorithm that can do thi and that's binari search .
so for binari search the now , what we're go to do is us an order arrai .
and actual us parallel arrai , on for the kei and on for the valu .
and the idea is to keep the arrai of kei in sort order .
and then find the index associ with the kei that we're search for us binari search and then us that index to get the valu that's associ with that kei that's store in the parallel arrai .
and we look at the binari search algorithm earlier in the cours .
and so , for exampl , if we're do a , if these ar the kei in our symbol tabl .
and we're do a search for the index where p is store .
we look at the middl .
p is bigger than l , so we look to the right .
look in the middl of the right half .
p is less than r so we look to the left .
continu until we find p .
when we find p , we return it index , and we us that index to get us the valu that we need or anoth wai to look at thi is that implement the function , how mani kei ar there that ar less than k .
so , for exampl , for queue that's unsuccess search and you can figur out from the last index when you don't find your the element that you're seek you can figur out the return valu , which is the number of kei that ar less than it .
so , that's a trace of implement binari search to find the rank of a kei in an order arrai , and again , for success , you can us that rank to return the valu and for if it is unsuccess , you can us that rank to figur out where to insert the new kei .
all right .
so , thi is the code for the get oper in thi rank , which is binari search .
so thi is precis the binari search curv that we look at befor .
so , let's look at again .
so if the whole tabl is empti , return null .
otherwis , we call rank and that could give us the number of kei less than the current kei .
and so , that is where we look to check to see if that kei is there .
if it's there , then we return the valu with the same index in the parallel arrai .
if it's not there , then we return null , sai the kei's not there .
now , the problem with minor search well , not necessarili a problem but the situat is that if when it's time to insert a new element , we have to move everyth larger over on posit just like an insert sort .
so , if the tabl ha a , e , r , and s and we have to insert the valu c , then we have to move the e , r , and s over on posit to put the c and then put the valu associ with c if thei're the same thing in the valu arrai .
move all the valu associ with those kei over on posit and put the associ valu in .
so , thi is a trace of what would happen for our trace .
and , and again , everi insert involv , involv make a new posit by move all the larger kei over on posit do the same thing in the valu arrai .
and if it's chang the valu associ with a kei that's alreadi there , then it's just a matter of find where the kei is and chang the valu at that index .
so , those from that trace is pretti easi to see what's involv , what's involv for the code and we'll skip that code .
and just take a look at the comparison between thi elementari implement for symbol tabl with the sequenti search in an unord list .
so , on thing is we're us a differ kei interfac .
we're take advantag of the fact that the kei ar compar to give us an effici search .
ah . , we can do search in worst case in averag case , in time proport to log n .
that's what binari search provid for us .
and thi is a fine data structur for symbol tabl where there's where , that ar rel static , where the valu don't chang much , and most of the oper ar search .
it's hard to beat binari search .
on the other hand , in a dynam situat where there ar a lot of insert .
thi method is go to be problemat becaus the cost of it insert is linear and proport to n <num> .
if you have a huge number of oper and everyon who is proport to the symbol tabl size , then you're just not go to be abl to support huge number of kei .
what we want is effici implement of both search and insert .
those ar elementari implement .
next we'll look at more advanc on .
when kei ar compar and we can put them in order .
we saw that we can us binari search to get an effici symbol tabl implement .
but we can also provid a lot of conveni function for the client that's what we ar go to look at next .
so thi is just an exampl of an applic that might try to associ kei with valu .
an illustr of all the differ oper that a client might want .
so we alreadi look at the get oper so we might want to know what citi is associ with the event that happen at time nine o'clock , thirteenth and so that should return that valu .
but there's plenti of other thing that we might want .
like , for exampl , what's the earliest time ?
that's the min or what's the latest time ?
that's the max .
what about , be abl to iter between , among all the kei between two given time ?
that , certainli is conveni .
then there's , what's the seventh largest time , that's select that like a median , it gener min or max ?
which kei is that , happen second or seventh ?
so that's , order statist , a dynam thing what happen , what the closest time , thing that happen just befor , five past nine .
certainli , plenti of client might want , want that .
so thi on is , i've onli got ten ticket to sell .
so that's the cut off point for , sell , seven ticket that's the cut off point .
for , anybodi after that time doesn't get a ticket .
and , and thi on might be , if there's a time cut off .
i'm not go to sell ticket to anyon that came after that time .
and then the correspond on is , what's the first thing that happen after that time ?
that's call in to the radio show , i'm go to take that caller , the first call that come at nine <num> .
and so forth .
so then see how mani thing happen between nine <num> and nine <num> .
and how mani call were there befor nine <num> <num> ?
so you can see that there's , all of these oper ar quit natur when we have the , tabl in sort order .
and that's what we have for our binari search implement .
so we can , implement these , effici and thei ar , conveni and us for the client .
so typic for order simpl tabl , when kei ar compar will provid a much wider interfac it's veri us for mani client .
so we sai that we're deal with kei that ar compar by simpli ad thi extent compar kei to our declar .
same wai we did for sort method .
so all that mean is that our implement can us compar to but for the client it mean that all these oper have mean .
give me the minimum kei , give me the largest kei , and then i can get the valu associ with that us that .
give me the largest kei less than or equal to thi kei valu or the smallest kei greater than that kei valu , give me the number of kei less than that kei .
you can actual implement prioriti queue thi wai .
delet the minimum kei , delet the largest kei .
now usual we argu against why the interfac is just ad oper to an interfac , usual our reason for do so is that we can't guarante that all the oper can be perform effici .
in thi case , as we'll see , ultim we have wai to guarante that all the oper can be form effici .
and thei're so conveni for client .
it's certainli worth ad them .
so we have iter through all the kei , and iter through all the kei in a given rang , and count the number of kei in a given rang .
all of these oper ar veri us for client and we'll see plenti of exampl later on .
so we have to greatli expand our , our tabl .
what , what ar go to be the cost of all of these thing .
and thi is a big differ between the binari search implement where the kei ar kept in order in an arrai , in the sequenti search implement , when thei're all in a link list .
so , for exampl , to provid order and iter , you have to get them sort .
and that's , go to be a lot of work , and take n lg n time .
wherea binari search , you just iter through , the thing in order .
the give me the seventh kei we just go and look there , thei ar in order .
rank oper , that is essenti what binari search provid .
that's the , our basic implement is provid rank .
floor and ceil that's again is an outgrowth of the rank oper .
minimum and maximum well again those ar like select .
their just right there , you look at the first or the last .
to insert or delet howev take linear time .
to maintain the sort arrai in dynam fashion is go to take linear time you have to go through the whole thing .
and so that's realli ar the kei to think about what ar symbol tabl and symbol tabl in gener .
how could we guarante that all oper ar fast ?
binari research is pretti good but that's a major flaw .
welcom back .
next we're go to talk about binari search tree , a classic data structur that'll enabl us to provid effici implement of symbol tabl and out rhythm .
let's look at the basic binari search tree data structur with heap we talk about implicit represent of tree with an arrai .
for binari search tree we're go to talk about actual explicit tree data structur .
a binari search tree is a binari tree in symmetr order .
let's look at the mean of those word .
so , a binari tree is an explicit data structur .
it's got what we call node which contain inform and everi node's got two link to binari tree that ar disjoint from on anoth , a left tree and right tree associ with each node .
each node ha a left tree and a right tree .
link can be null .
left tree can be null and right tree can be null or both .
we refer to everi node in the tree as the root of a sub tree and refer to , the node below .
each node is it children so thi is the right child of the root .
and that's a left link , and so forth .
so that's the definit of a binari tree .
a binari search tree , each node ha a kei and everi node kei is larger than all the kei in it left subtre and smaller than all the kei in it right subtre .
thi is a differ order than we have to heap if we have a node larger than both it children , thi on , everi node is between the valu , the valu of everi node is between the valu of the node in it two subtre .
so the node to the left of e ar smaller and node to the right of e ar larger .
now we're go to us these to implement symbol tabl and there's valu associ with each kei when appropri , we'll write the valu in smaller number next to the kei .
but usual , we're just go to worri about the kei and we'll keep the valu , in the node along with them so that's binari search tree .
a binari tree in symmetr order that's the data structur e that we're go to us to implement symbol tabl oper .
so how ar we're go to repres binari search tree in java ?
well , we're go to extend our implement of link list structur to have two refer instead of just on .
so first of all , is the , there's a node at the root .
so , a binari search tree in java is just go to be referenc to a root node .
and everi node's got four field , a kei and a valu , and refer to the left subtre , that contain the smaller kei , and the right subtre that contain the larger kei .
so , here's what the , code is base on .
the , inner class that we us to implement node ha , on , two , three , four instanc variabl .
all of which ar privat as usual .
a kei of type kei , a valu of type valu and then refer to a left and a right node .
for conveni , we'll provid a constructor that take the kei and valu as argument and fill in the kei and valu instanc variabl then the left and right link ar initi to null .
and our data structur then will be a root that point to a node in the tree and then that node will point to subtre and that will be the data structur that we us for symbol tabl .
so here's the skeleton of our symbol tabl implement .
it's for compar kei associ with valu and those ar both gener type .
the onli instanc variabl is a link to the root node call root .
the inner class node is the code that wa given on the previou slide , and then we'll need implement of put and get , and we'll also look at an implement of delet , and an iter as well .
so that's our skeleton implement , let's look at the kei .
so let's look at search first .
so here's a binari search tree let's do a demo of what differ search will look like in thi tree .
so there's a tree so s is at the root everybodi to the left of is less than s over to the right is bigger .
so thi is a dynam data structur that kind of follow the same rule as binari search .
so to look for a , to do a search for the kei h in thi tree , we start at the root and we compar our kei against the kei at the root .
and in thi case , h is less so all that sai to us is that if h is in the tree , it ha to be to the left cuz everybodi to the right is greater than s .
so we move to the left and compar h against the root of the left subtre .
in thi case that's e .
now h is greater so that sai we should go right .
now we can pair h against the root of the right subtre of e , and that's r and it's less so we have to go left cuz everybodi to the right of r is bigger and h is smaller .
and eventu if the kei is in the tree , we're go to hit it .
in thi case we , we find h as the left sub tree of r in that's a search hit and then for the get oper , we can return the valu that's store in that node along with the kei h .
what about an unsuccess search ?
well the same rule follow .
if it's in the tree , it's gotta be accord to the left or right , accord to whether it's smaller or larger than the kei at the rout .
in thi case , if we're search for g , it's gotta go left , becaus it's less than s .
when we come against the e , we gotta go right becaus it's bigger than e against the r , we have to go left , becaus it's less than r .
we come against the h , we have to go left .
and then we come off a null link , and all that sai is that there's no place in thi tree where g could be so g is not there .
so that's a search miss .
and the get oper would return null in that case .
what about insert ?
well , to insert a new kei , all we do is follow the same step as we did for search .
that follow off that null link and again , we'll just , for g , travel down the tree until we come to the , null link .
realli , what we're sai is when we go to the left link of h , it sai , if g is in the tree , it ha to be down thi link .
sinc it's not there to in sert g , all we need to do is just put it there and that's how we insert a new node into a binari search tree .
all right , here's the code correspond to the process that we just demo .
and it's quit straight forward simpl code as simpl as binari search realli .
we start at the root then we set variabl x to be the root and that's go to be the pointer to the current node as we move down the tree .
as long as our , our current node x is not null what we'll want to do is a comparison between the kei at node x and our search kei .
if our search kei is less , we go to the left .
if it's greater we go to the right .
and if it's equal we don't even have to test that , that's why it's in grei .
if it's not greater or lesser it ha to be equal , than we return the valu right at that node .
if we get to the bottom and our current node is null and that's fall off the bottom of the tree we return null and that's equival to sai our buyer convent that , that kei is not in our data structur , or not in our symbol tabl .
so that's veri straightforward implement of the get oper for symbol tabl with a binari search tree represent .
now , what's the cost ?
well , we went down a path in the tree so it's on plu the depth of the node in the tree .
so what about search well search for put there's two case .
if the if we're suppos to associ a valu with a kei .
if the kei's alreadi in the tree then we're just go to reset the valu .
if thei kei's not in the tree then we add a new node at the bottom .
so now it's a littl bit tricki the wai that we implement it sinc we're us we us a recurs implement .
and the reason we do thi is that it gener to give us more effici data structur later on .
so , what we'll do is us a recurs implement that as it move down the tree it'll return a link up higher in the tree .
and so when we insert a new node l sai in thi tree we go down that path , we creat a new node and then return the link to that node higher up .
there's wai to implement that don't involv thi , but it , the code is so simpl and it extend to more power data structur later on that we'll introduc thi right now and , and you'll see how it work .
so here's the , thi is veri concis recurs code but it tricki becaus of that last point so it worth read carefulli .
so , we're go to us a recurs method put .
that put a associ a valu with a kei in the tree .
and that recurs method is go to return a node .
so the client method put of cours , just is suppos to do the associ so it ha a void return .
but what we'll do is invok a recurs method start at the root and whatev link get return , we'll set that to root .
so right awai , we can see , let's suppos that we have an empti tree where root is null .
so then if we put with null as the first argument , then null is the first argument .
what we do is we sai if , if the argument is null , return a refer to a new node that associ kei with valu and then that on ha null link .
so in thi case , that first call will return a link and whatev link get return , that will be set to root .
so , without ani extra special code we insert a node into an empti tree .
and that work , again , recurs sai we have on node in the tree , and we have a new kei to associ .
and let's sai that kei is less than the kei at the root .
so , so now we do put in it's actual a link to that on node that's got two null link .
so it's not null so we'll compar our kei against the kei in that node .
if that comparison come out left , here's how we do the insert .
we chang our left link which is right now it's null to whatev put return .
so what's put go to return ?
well , that left link is null , so what's go to happen is , in that call x is null .
it's go to be cre at a new node and the link to that node will be return and that's the link that we'll put in the left .
thi is a veri concis code that otherwis we'd have variou case about save which link we went down in order to reset that later on .
so now the best wai have look at those small exampl , the best wai to understand thi code is recurs .
let's believ that it work for small case which we have just done .
so , let see what the code doe .
so if x is null , we want to creat a new node and return the link to that node .
so , even if it's a huge tree down at the bottom , we just came of a null link .
we just want to creat a new node with our new kei and return a link to that node , that's all we want to do .
now , we can assum that put is go to return a link to a sub tree that contain our new kei and if our new kei is smaller than the kei at the node that , that we're process now , then we want to insert the new kei valu there and the new node on the left otherwis , we want to insert on the right .
most of the time , the link that we get back will be same as the link that we put in but for the bottom node it will be differ .
so , if put work properli insert a new node on the left , then that's what we want our left link to be .
if it work properli , put in the subtre on the right , that's what we want our right link to be .
and by the wai , if we find a kei that's in the tree alreadi , then we just want to reset the valu .
and in all of these case where we're on a node that alreadi exist , we just want to return the link to that node .
again , when we look at more sophist valu we'll be return someth els .
so it's worthwhil you know , check that you believ that thi code implement the simpl binari search tree algorithm that we demo where when we fall off a null link we creat a new node and replac that null link with the new node .
so that's insert for a binari search tree in a symbol tabl .
and again , the cost of thi is the number of compar is equal to on plu the depth of the node .
we just go down a path in the tree .
now , what's interest about binari search tree is that there ar mani differ binari search tree that correspond to the same set of kei .
so the number it compar is go to depend on the order in which the kei come in .
and that's a kei featur of binari search tree that we'll come back to again when we look at more sophist data structur .
so it depend on how the kei come in .
the shape of the , of the tree could be well in the best case so it would be perfectli balanc .
and on of the thing we'll look at is algorithm that come veri , veri close to achiev that goal .
the typic , typic case it'll be sort of balanc .
now but on problem is if the kei come in and , and realli unfortun , if thei come in , in a natur order .
like if thei come in , in order , that's the worst case .
we don't get ani benefit from have it in a tree shape .
it's no differ than a link list .
so we'll , we'll come back to deal with that wors case in the next lectur .
but the point is , the tree shape depend on the order of insert .
now , but let's look at what's happen or visual what happen when kei come in , in random order .
so the tree grow from the bottom in the littl side to side motion it's just accommod room for each new kei as it's ad .
but you could see that even for thi case which is hundr of kei , the length of the path from top to bottom is not so much .
in thi case , the maximum distanc from the top to the bottom is sixteen the averag is onli nine and the best you could in a perfectli balanc tree it would be seven .
so it's pretti well balanc which mean that our search and insert cost in thi case for <num> kei is onli go to be sixteen quit a bit less .
so on remark befor we do the analysi is that actual binari search tree correspond exactli to quicksort partit .
in the binari search tree , we have a node at the root and we have everybodi smaller to the left , and everybodi larger to the right .
in quicksort partit , after the random shuffl we have the partit element and then we process everybodi to the left independ of everybodi to the right .
so it's a there's a direct correspond .
if there is no duplic kei quicksort process them and refer them out in bst and if there's no duplic kei there's a on to on correspond between what happen with quicksort and what happen with binari search tree .
and we point that out becaus that help with the mathemat analysi .
in fact , thi correspond with quicksort partit tell us we can take that proof and prove that if you insert in distinct kei into a bst , in random order , then the expect number of compar for a search and an insert is two natur log n .
so again about <num> . <num> log base two of n almost the best that you could do .
it also ha been shown actual not that long ago , that the expect height of the tree if thei're insert in random order , the height that's the worst case length of a path in the tree .
thi is the averag path in a tree , thi is the , the worst of all the kei .
thi is about four natur log n .
so , if you have the kei in random order the binari search tree give effici search and insert .
now but there is thi problem that the actual worst case height if the kei come in , in order and revers order and other natur order that the time could be proport to n .
so , we have thi summari which is look pretti good , becaus we have the averag case for both oper , the search and insert , to be <num> . <num> log n and that's probabilist if thei ar in random order , it extrem like to be there .
but the problem by comparison with sort is , we don't get to random the order the client is provid the kei .
so we're go to need someth better to provid the guarante than just randomli order the kei .
that's what we're go to be look at next when we look at more effici algorithm .
but first we're go to look at the implement of order and oper with the binari search tree structur .
it expand like binari search to handl all these conveni client oper in a veri natur manner .
that's the implement of binari search tree for symbol tabl .
thei give suffici implement of both search and insert .
now , we're go to take a look at order symbol tabl oper us the binari search tree data structur as the underli implement .
well , each on of these oper ar fairli straight forward but just to check our abil to manipul thi data structur , we'll take a look at each .
suppos , we want to find the minimum kei in a binari search tree , or the maximum kei .
well , just look at on exampl you can see almost immedi what to do to find the minimum , we move left from the root until we find a null kei , that's where the smallest kei in the data structur is .
to find the maximum , we move right from the root , until we find a null kei .
what about floor and ceil ?
well , those ar a littl bit more complic and we'll have to , not quit the same as in the order arrai for the binari search so we have to do a littl bit more work for that .
so just for exampl , let's take a look at the problem of comput the floor .
so , what we want to find is so sai , we're seek the floor of g .
so , that's the largest kei in the data structur that is less than g .
in thi case , the answer is e .
so let's just take a look at what we have to do in the tree , the path we have to take in the tree to figur that out .
well so , we ar look for the largest kei that's less than g .
and have s well , that kei is definit go to be in the left subtre .
it not go to be bigger than s becaus s is bigger than g so we go to the left .
so now , we ar sit at e .
and so what's the largest kei that's less than g in thi , in thi tree here .
well , it might be e but there's no wai it's to the left of e becaus those kei ar all smaller than e and therefor smaller than g .
so , e is a kei candid .
but it might also be in the right so we move to the right in thi case .
all right so that's if k is equal to the kei at the root , the floor of k is k .
if k is less than the kei , it root i n the left subtre .
that's the on we just did .
if it's greater than the kei at the root .
the floor of k is in the right subtre , if there is ani kei smaller than k in the right subtre .
so , in thi case , there's no kei smaller than g in the right subtre .
so therefor , the answer is e .
so , our code ha to check for these three case .
and here's the code that doe it .
it's not that much code .
it's just complic code to understand .
so if we find our kei , that's the floor .
if we're go to the left we find the floor , the on on the left .
and in on the right we have to do a , a littl bit of tricki code to make sure that we return the floor on the right subtre , if there's some tree there .
if there's , if there's no node there then , then , then we , we return the root itself .
so , that's a , a implement that , that code is definit tricki and a similar code for ceil .
so now , what about oper like rank and select ?
how mani kei ar there less than a given kei ?
and , give us the seventh largest kei to facilit implement those oper and also size all we do is keep an extra field in each node , which is the number of the node in the subtre root at that node .
so , thi tree ha got eight node in it .
thi subtre ha six node in it and so forth .
and those count ar go to not onli enabl us to immedi implement the size function , just return the count at the root but also , thei'll give us good implement of rank and select .
so , let's look at those now .
so , we add account field to everi node and then to implement the size function well , if it's null , we return zero .
so a client might call us for a null tree or or an empti tree .
otherwis we return , x . count , which is the number of node in that , in that subtre by definit .
the wai we maintain , there's a number of wai we can maintain the thing but the on that we'll adopt un iformli becaus it adapt to more complic situat is just befor we're done with the put oper we'll sai , okai we've done all our work and befor we return the pointer to the given subtre we're go to take the size of what's on the left and the size of what's on the right and add on for us and that's go to be our count .
so , whether or not there wa a new node ad we don't have to test for that thi recurs take care of the problem of maintain the size in everi node when there's a new node insert .
and , it also handl more gener situat , as we'll see later on .
so , that's how to maintain size .
so now , how do we implement rank ?
well , it's a littl like floor .
it's an easi recurs algorithm , but there ar three case .
so let's look at the , at the three case .
so , we want to know the number of kei less than k .
so we're go to have a recurs algorithm for our given kei .
so , let's , on of the easi on is , if our kei is equal to the , if were to the , the kei at the current node then the number of kei less than our kei is the size of the left subtre of that node .
so , if we're look for the rank of e sai , how mani kei ar there less than e there's exactli two , that's by definit in the data structur that's the number of kei that ar less than e .
so , that's that on for rank .
what about the start at the root if we have the case where e is less than s .
so , the rank of e in thi whole tree is the same as the rank of e in the left subtre .
so , there's that case and then if we're go to the right , then we have to add on for the root and on for the left subtre of the root and then find the rank of us on the right .
so , that's an easi recurs algorithm for find out the rank .
and it's definit an instruct exercis to check that you believ that , that method work .
the other thing we h av to do is iter .
and iter is a fundament oper on tree structur .
and it's base on so call in order travers .
and that's also a simpl recurs algorithm .
travers the left subtre enqueu the kei , travers the right subtre .
so , to iter we're go to maintain a queue of kei .
and then , we're go to call thi recurs in order method .
and that method is go to add all the kei in the tree to the queue .
and then we'll just return that queue .
and that's , a queue is an iter data structur , and the client can iter that .
and , in order , it's just a simpl recurs method .
put everybodi to the left on the queue then put the root on the queue , then put everybodi to the right on the queue .
and to believ thi method , you just have to think recurs and prove by induct that thi in order method put all the kei in the data structur on the queue in their natur order .
first , it put all the on to the left on the queue .
if that , that happen in their natur order , then the next thing that ha to appear is the kei at the root .
and then if the on on the right go in their natur order , and then , by induct , thei're all in their natur order .
that's a veri simpl implement of an iter for these symbol tabl with compar kei .
so we have to again prove that properti by induct .
and that's easi to do .
the diagram at the right give anoth simpl wai to look at it pictori .
all the kei that ar smaller on the left we ar go to put them out , and then we put the kei at the root and then we put all the kei on the right out in order .
and then that kei is go to have all those kei in order by induct .
so , here's the oper summari for order symbol tabl .
and the quick summari is that everi on of those oper , while order iter is optim , it just get them in linear time .
and all the re t of'em take time proport to the height of the tree .
now , if the , the kei ar insert in random order , we know that height by analysi , is go to be proport to log n .
or if it's some applic where the order of insert of the kei is well model by random order and that's not unusu at all .
a binari search tree is a simpl and extrem effect data structur that can support all of these oper in a quickli , much better than binari search in an order arrai which is not dynam and slow for insert .
so , that's a look at binari search tree implement of order oper when kei ar compar .
if our symbol tabl's realli go to be dynam , we need to be abl to delet kei valu pair from the tabl .
as we'll see , all symbol tabl implement have , lead to complic when we try to do thi oper .
binari search trace is our first exampl .
so we need to fill in thi on tabl .
what's , what's the cost of delet in a binari search tree ?
how ar we go to realli do that ?
well let's take a look at a veri lazi approach which we set up for in our basic convent for simpl tabl .
what we can do to remov a node with a give kei is just mark it with a tombston .
sai , well , we'll leav the kei in the tree to guid search , but we won't , count it as be in the symbol tabl .
and actual you can , make some progress with thi kind of method .
leav tombston throughout the tree .
and , make sure that you keep , as long as there aren't too mani delet , you can keep the search cost , and delet and insert cost to be logarithm .
but it definit becom , inconveni to manag larg number of tombston in highli dynam situat with larg number of kei and valu .
eventu you're go to get an overload of memori and you're go to have to rebuild the thing or clean out the tombston in some wai so we need to look for a better wai .
thi is a gener method that peopl often us on all differ type of implement , but in modern system it's rather unsatisfactori .
also got a simpler problem .
what about delet the minimum ?
well actual , that's mayb not too difficult to delet the minimum in a binari search tree .
again , we just go to the left until we get a null left link .
and then , what we can do is just return that node's right link then that old node , nobodi's point to it , so it's avail for garbag collect .
and then we us our usual trick of return the link that we went down to updat the other link after the recurs call .
and also we have to updat the count , someth happen down below and we us that code to updat the count , in a co nsistent wai , so thi code implement delet , not too bad at all .
if x .
left null , return x right .
otherwis x left delet min x left .
and then when you're done with that , it fix the count so mayb a node got delet down there , but alwai , the invari is that the count of the node is on size of the left and right .
and then return x and fix the link and the count on the wai up .
that's a fine implement for delet min , and it also work for delet max .
and that's the basi for a gener method for delet node from bst known as hibberd delet .
so , that's the second case , the first case for hibberd delet is what we want to do to delet a , a node with kei k , is we search for the node that contain the kei , and the easiest case is that node ha no children .
so to , to delet a node that ha no children just return null .
and then go back up to updat the count as usual , that's the easi case .
the next most difficult case is like the delet min case we find a node t that contain our kei , so like delet r in thi tree , it onli ha on child .
just go ahead and return the link to that child and that updat the link and everyth work fine and then the node that the lead that avail for garbag collect that nobodi's point to it .
and then again updat all the account after the recurs call .
zero children no problem on child no problem .
the problem is what happen when there is two children .
so sai we want to delet node e in thi tree .
we have onli on link , and we can get rid of the node but we have onli on link point to it .
but we have two link point down from it .
so what ar we go to do with those two link ?
well the hibbard delet mechan which is pretti old .
<num> year ago , it wa propos .
sai , go ahead and find the next smallest node in the right subtre of that tree .
so in the case that's h and what's that node ?
well it's the minimum in t's right sub tree .
and we know how to delet the minimum .
so we just find that minimum node and , in thi case it's h , and we put that node in t spot and then delet the minimum .
so , find the h that's the minimum , hang on to it , and then delet the minimum nt sub tree and then , so we take the e , replac it with the h , delet the h , and then everyth is fine .
it is still a bst .
so we , essenti we ar find a node that ha onli on link , delet that node , and then replac the node that we need to delet with that on .
that's hibbard delet .
it's a littl bit asymmetr .
why ar we us the successor and not the predecessor ?
no real reason .
and it's not realli satisfactori becaus of that , and we'll come back to thi but it work .
so thi is the code for hibbard delet .
so we search for the kei .
if it's got no right child , we're fine .
we just return , x out left , and that handl both case zero and on .
if it doe have a right child , then we do thi , find the minimum , on the right .
delet min on the right and then fix the link and then updat our count that cover all case .
so actual not that much code , it's complic but not particularli more complic than other code we have seen like rank and floor and ceil and that implement hibbard delet .
so now we have a fulli dynam symbol tabl where we can insert and delet .
the number of node that we have in the tree as alwai proport to the number of kei valu pair in the symbol tabl .
and the problem is , and thi wa quit a surpris when it wa first discov actual mani year after hibbard propos the algorithm is thi lack of symmetri that tend to lead to difficulti .
and here we ar just insert the lead altern insert and delet a random kei .
so that mayb well model a situat , practic situat .
and as you watch it go for awhil .
you can see that thi thing about go to the right and take the successor all the time .
the tree's becom much less balanc than it wa .
and , thi seem to be a , a problem .
we can't be have , supposedli have a dynam situat , that is go to , allow support of lot of differ insert and de lete .
and in the end , win up with a less balanc tree .
what's wors , if you , so how you ar go to fix it ?
at the end research show that after , suffici long sequenc of random insert and delet , the height of the tree becom squar root of n not lg n .
squar root of n is usual bigger than lg n .
it might make differ between accept and unaccept perform in real applic .
then what's wors is you try to fix it by sai randomli choos between the left and the right , that doesn't work , it still becom squar root of n .
and that's a veri long stand open problem to find a natur , simpl , effici delet for binari search tree .
that's anoth on like merg in place , that you think there ought to be anoth easi wai to do it , but in <num> year no on's realli discov on .
now we're go to look at someth pretti close in the next lectur , but here's the situat that we're left with .
we have a binari search tree algorithm , which is fine in that give us lg n perform for search and insert , in a situat where we can think that these thing ar happen randomli .
but we're kind of stuck if we allow delet .
in fact everyth regener to squar root of n , and we also have a problem with , with the worst case if the kei happen to have some order in them our tree ar not go to be balanc at all .
and that's go to make the differ between accept and not accept perform .
what we're go to look at next time , call a red black minor search tree , will guarante logarithm perform for all oper .
so that's extrem signific and much better then binari search tree but the delet oper for binari search tree show us the kind of complex that we can encount with work with these kind of data structur .
